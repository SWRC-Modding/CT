/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2011 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

// extern void *GLog; weak
// extern void *GError; weak
// extern void *FName::Names; weak
// extern void *GMalloc; weak
// extern void *APlayerController::PrivateStaticClass; weak
// extern void *CDKeyResponseInterface::msCDKeyString; weak
// extern void *UGameEngine::PrivateStaticClass; weak
// extern void *CDKeyResponseInterface::mpCDKeyInterface; weak
// extern void *CDKeyResponseInterface::_vftable_; weak
extern char aFriendlyfire[13]; // weak
extern char aDedicatedserve[16]; // weak
extern int (__stdcall *GameSpyCDKeyResponseInterface::_vftable_)(int, int, int); // weak
extern char aS[3]; // weak
extern char aSDDDD[21]; // weak
extern char aPlayer[7]; // weak
extern char aNoName[10]; // weak
extern char aScore[6]; // weak
extern char aDeaths[7]; // weak
extern char aPing[5]; // weak
extern char aTeam[5]; // weak
extern char aCdAuthFailedFo[29]; // weak
extern char aErrorReceivedW[43]; // weak
extern char aCdAuthReturned[44]; // weak
extern char aSendingCdAuthF[32]; // weak
extern char aReleasingCdKey[27]; // weak
extern char aReleasingAllCd[22]; // weak
extern char aGamespymgrErro[26]; // weak
extern char ValueName[]; // idb
extern char SubKey[]; // idb
extern char aCastOfSToSFail[24]; // weak
extern char aNull[5]; // weak
extern char aSSDDDSSDDDDD[48]; // weak
extern char aHostname[9]; // weak
extern char aHostport[9]; // weak
extern char aNumplayers[11]; // weak
extern char aMaxplayers[11]; // weak
extern char aMapname[8]; // weak
extern char aNoMap[9]; // weak
extern char aGametype[9]; // weak
extern char aNoGame[10]; // weak
extern char aFraglimit[10]; // weak
extern char aTimelimit[10]; // weak
extern char aNumteams[9]; // weak
extern char a2SDSD[32]; // weak
extern char aFriendlyFirePc[18]; // weak
extern char aDedicatedServe[17]; // weak
extern char aFriendlyfirepc[21]; // weak
extern char aGamespymenutem[20]; // weak
extern char aDedicatedser_0[21]; // weak
extern char aXinterfacegame[18]; // weak
extern char aGet_cdkey_resu[17]; // weak
extern char aCheck_cdkey[12]; // weak
extern char aSet_query_filt[24]; // weak
extern char aGet_ext_server[29]; // weak
extern char aGet_ext_player[29]; // weak
extern char aCancel_query[13]; // weak
extern char aClear_query_re[20]; // weak
extern char aSort_query_res[19]; // weak
extern char aGet_query_resu[18]; // weak
extern char aD[]; // idb
extern char aGet_query_coun[16]; // weak
extern char aGet_query_stat[17]; // weak
extern char aBegin_lan_quer[16]; // weak
extern char aBegin_internet[21]; // weak
extern _UNKNOWN unk_1000E7EB; // weak
extern char aOpenplaying[12]; // weak
extern char aErrorTryingToI[39]; // weak
extern char Format[4]; // idb
extern char aS_D[]; // idb
extern char aFinal_0[6]; // weak
extern char aQueryid[8]; // weak
extern char aSD[]; // idb
extern char a0123456789abcd[63]; // weak
extern char aCrypt[]; // idb
extern char aSoftwareGamesp[]; // idb
extern char aS_available_ga[]; // idb
extern _UNKNOWN unk_1000E9E4; // weak
extern char aGamename[9]; // weak
extern char a255_255_255_25[16]; // weak
extern char a08x04x[]; // idb
extern char aUnknown[8]; // weak
extern char aFinalQueryid1_[19]; // weak
extern char aS_master_games[]; // idb
extern char aPublicport[11]; // weak
extern char aPublicip[9]; // weak
extern char aStatechanged[13]; // weak
extern char a0[2]; // weak
extern char a1[2]; // weak
extern char aNatneg[7]; // weak
extern char aLocalport[10]; // weak
extern char aLocalipD[]; // idb
extern char aNoChallengeVal[56]; // weak
extern char aSDS[]; // idb
extern char a_8x[]; // idb
extern char aCdKeyOrChallen[29]; // weak
extern int dword_1000EBBC; // weak
extern int dword_1000EBC0; // weak
extern int dword_1000EBC8; // weak
extern int dword_1000EBCC; // weak
extern int dword_1000EBD0; // weak
extern char byte_1000EBD4; // weak
extern char SubStr[]; // idb
extern char aS_msD_gamespy_[]; // idb
extern _UNKNOWN unk_1000EC14; // weak
extern char aEchoTest[]; // idb
extern char a02x[]; // idb
extern _UNKNOWN unk_1000EDC0; // weak
extern _UNKNOWN unk_1000EDC8; // weak
extern _UNKNOWN unk_1000EE44; // weak
extern int off_10011014; // idb
extern char *off_10011018[8]; // weak
extern char *off_10011030[2]; // weak
extern int (__thiscall **off_10011038)(void *, char); // weak
extern char *off_1001105C[15]; // weak
extern char *off_10011060[14]; // weak
extern char *off_10011064[13]; // weak
extern char *off_10011068[12]; // weak
extern char *off_1001106C[11]; // weak
extern char *off_10011070[10]; // weak
extern char *off_10011074[9]; // weak
extern char *off_10011078[8]; // weak
extern char *off_1001107C[7]; // weak
extern char *off_10011080[6]; // weak
extern char *off_10011084[5]; // weak
extern char *off_10011088[4]; // weak
extern char *off_1001108C[3]; // weak
extern char *off_10011090[2]; // weak
extern char *off_10011094; // weak
extern unsigned __int16 word_1001109C; // idb
extern __int16 word_1001109E; // weak
extern void *off_100110A0; // weak
extern SOCKET dword_10011498; // idb
extern _UNKNOWN unk_100114A0; // weak
extern void *Memory; // idb
extern char *Str2; // idb
extern _UNKNOWN unk_100115C0; // weak
extern int dword_10011640; // weak
extern void *dword_10011644; // idb
extern int dword_10011648; // weak
extern BYTE Data; // idb
extern _UNKNOWN unk_10011664; // weak
extern _UNKNOWN unk_10011665; // weak
extern _UNKNOWN unk_10011668; // weak
extern _UNKNOWN unk_1001166A; // weak
extern _UNKNOWN unk_1001166C; // weak
extern _UNKNOWN unk_1001166F; // weak
extern char byte_10011670; // weak
extern SOCKET s; // idb
extern struct sockaddr to; // idb
extern char buf; // idb
extern _UNKNOWN unk_10011781; // weak
extern int len; // idb
extern int dword_100117C0; // weak
extern int dword_100117C4; // weak
extern int dword_100117C8; // weak
extern char byte_100117D0; // weak
extern char byte_100117D1; // weak
extern char byte_100117D2; // weak
extern char byte_100117D3; // weak
extern char byte_100117D4; // weak
extern char byte_100117D5; // weak
extern char byte_100117D6; // weak
extern char byte_100117D7; // weak
extern int dword_100117DC; // weak
extern char byte_100117E0; // idb
extern struct sockaddr stru_10011BE0; // idb
extern _UNKNOWN unk_10011BF0; // weak
extern __int16 word_10011E30; // weak
extern int dword_10011E34; // weak
extern int dword_10011E38[]; // weak
extern char byte_10011E50; // idb
extern int dword_10011F50; // weak
extern int dword_10011F54; // weak
extern int dword_10011F58; // weak
extern char byte_10011F60; // weak
extern int dword_10011FA0[]; // weak
extern int dword_10011FA8[]; // weak
extern int dword_10011FE0; // weak
extern _BYTE byte_10012000[64]; // idb
extern char byte_10012040; // weak
extern int dword_1001208C; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl sub_10001020(int a1);
void *__thiscall GameSpyMgr::GameSpyMgr(void *this);
int __thiscall GameSpyMgr::GameSpyMgr(int this, int a2, int a3);
int __thiscall GameSpyMgr::GetLocalID(int this);
int __cdecl GameSpyMgr::SetUplinkCB(int a1, int a2, int a3);
int __thiscall GameSpyMgr::GameSpyMgr(int this, int a2);
int __thiscall GameSpyMgr::operator_(int this, int a2);
void *__thiscall GameSpyCDKeyResponseInterface::_GameSpyCDKeyResponseInterface(void *this);
void *__thiscall GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface(void *this, int a2);
void *__thiscall GameSpyCDKeyResponseInterface::operator_(void *this, int a2);
int __thiscall GameSpyMgr::GetServerQueryNumResults(int this);
int __thiscall GameSpyMgr::GetExtPlayerQueryResult(void *this, int a2, int a3, int a4);
int __thiscall GameSpyMgr::CancelServerQuery(int this);
int __thiscall GameSpyMgr::ClearServerQueryResults(int this);
char __cdecl GameSpyMgr::SBCallback(int a1, int a2, int a3, int a4);
bool __cdecl GameSpyMgr::IsBackEndAvailable();
bool __thiscall GameSpyMgr::CreateServerBrowser(int this);
void __thiscall GameSpyMgr::DeleteServerBrowser(int this);
signed int __cdecl GameSpyMgr::RegisterCustomKeys();
char __thiscall GameSpyMgr::Tick(int this, int a2);
int __cdecl GameSpyMgr::CDAuthCallback(int a1, int a2, int a3, int a4, int a5);
// void __usercall sub_10001680(int a1<ebp>);
void __cdecl sub_10001694();
int __thiscall GameSpyMgr::AuthCDKey(int this, int a2, int a3, char a4, int a5, char a6, int a7);
// void __usercall sub_1000179D(int a1<ebp>);
void __cdecl sub_100017B1();
void __stdcall GameSpyMgr::ReleaseCDKey(int a1);
// void __usercall sub_10001837(int a1<ebp>);
void __cdecl sub_1000184B();
void __cdecl GameSpyMgr::ReleaseAllCDKey();
// void __usercall sub_100018C8(int a1<ebp>);
void __cdecl sub_100018DC();
char __thiscall GameSpyMgr::UpdateState(int this);
int __cdecl sub_10001910(int a1, int a2);
int GameSpyMgr::teamkey_callback(); // weak
int __cdecl GameSpyMgr::keylist_callback(int a1, int a2);
int __cdecl GameSpyMgr::adderror_callback(int a1, int a2);
// void __usercall sub_10001AC8(int a1<ebp>);
void __cdecl sub_10001ADC();
int GameSpyMgr::nn_callback(); // weak
int GameSpyMgr::cm_callback(); // weak
void *__thiscall GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface(void *this);
int __stdcall GameSpyCDKeyResponseInterface::GetResponse(const char *a1, const char *a2, int a3);
int __thiscall GameSpyMgr::GetServerQueryResult(void *this, int a2, int a3, int a4);
// void __usercall sub_10001EA2(int a1<ebp>);
void __cdecl sub_10001EB6();
int __thiscall GameSpyMgr::GetExtServerQueryResult(void *this, int a2, int a3);
// void __usercall sub_10002117(int a1<ebp>);
void __cdecl sub_1000212B();
char __thiscall GameSpyMgr::BeginServerQuery(int this);
// void __usercall sub_10002251(int a1<ebp>);
void __cdecl sub_10002265();
void __thiscall GameSpyMgr::UnRegisterGame(int this);
// void __usercall sub_100022EE(int a1<ebp>);
void __cdecl sub_10002302();
signed int __thiscall GameSpyMgr::Exec(void *this, int a2, int a3);
// void __usercall sub_10002787(int a1<ebp>);
void __cdecl sub_1000279B();
int __cdecl GameSpyMgr::serverkey_callback(int a1, int a2, int a3);
// void __usercall sub_10002A49(int a1<ebp>);
void __cdecl sub_10002A5D();
int __cdecl GameSpyMgr::playerkey_callback(int a1, int a2, int a3, int a4);
// void __usercall sub_10002CF0(int a1<ebp>);
void __cdecl sub_10002D04();
int __cdecl GameSpyMgr::count_callback(int a1, int a2);
// void __usercall sub_10002E4B(int a1<ebp>);
void __cdecl sub_10002E5F();
char __thiscall GameSpyMgr::RegisterGame(void *this, int a2);
// void __usercall sub_10003017(int a1<ebp>);
void __cdecl sub_1000302B();
int __thiscall GameSpyMgr::_GameSpyMgr(int this);
// void __usercall sub_100030AE(int a1<ebp>);
void __cdecl sub_100030C2();
int sub_10003100(); // weak
int sub_100032A0(); // weak
int __cdecl sub_10003310(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl sub_100033A0(char *Memory);
signed int __cdecl sub_100034A0(int a1);
int __cdecl sub_100034C0(int a1);
int __cdecl sub_100034E0(int a1);
int __cdecl sub_100035B0(int a1);
int __cdecl sub_100035C0(int a1, int a2);
int __cdecl sub_10003620(int a1);
void __cdecl sub_10003630(int a1, int a2, int a3, int a4);
int __cdecl sub_10003660(int a1);
signed int __cdecl sub_10003690(int a1, int a2, int a3, int a4, int a5, const char *a6, u_long hostlong, int a8);
signed int __cdecl sub_10003790(int a1, int a2, int a3, int a4, int a5, const char *a6);
signed int __cdecl sub_10003800(int a1, int a2, u_short hostshort, unsigned __int16 a4);
// signed int __usercall sub_10003870<eax>(int a1<ebx>, int a2<edi>);
signed int __cdecl sub_100039C0(int a1, int a2, int a3, int a4);
int sub_10003A70(); // weak
int sub_10003A90(); // weak
void __cdecl sub_10003AA0();
void __cdecl sub_10003AD0(int a1);
void __cdecl sub_10003B00(int a1, const char *a2, const char *a3);
void __cdecl sub_10003B40(int a1, const char *a2, int a3);
int __cdecl sub_10003B90(int a1, int a2);
int __cdecl sub_10003BE0(int a1, int a2, int a3);
double __cdecl sub_10003C20(int a1, int a2, double a3);
int __cdecl sub_10003CC0(int a1, int a2, int a3, int a4);
bool __cdecl sub_10003E80(int a1);
bool __cdecl sub_10003EA0(int a1);
char *__cdecl sub_10003EC0(struct in_addr *a1);
int __cdecl sub_10003ED0(int a1);
__int16 __cdecl sub_10003F00(int a1);
bool __cdecl sub_10003F10(int a1);
char *__cdecl sub_10003F50(int a1);
int __cdecl sub_10003F90(int a1, int a2);
int __cdecl sub_10003FA0(int a1);
signed int __cdecl sub_10003FB0(const char *a1);
int __fastcall sub_10004030(int a1, char a2);
int __cdecl sub_10004080(int a1, int a2);
void __cdecl sub_10004160(int a1, int a2, signed int a3);
// int __usercall sub_10004350<eax>(int a1<eax>, unsigned int a2);
int sub_10004390(); // weak
int sub_100043B0(); // weak
int sub_100043D0(); // weak
int __cdecl sub_100043F0(int a1);
void *__cdecl sub_10004400(int a1, int a2, __int16 a3);
char __cdecl sub_10004480(int a1, char a2);
int __cdecl sub_100044B0(int a1, int a2, __int16 a3);
int __cdecl sub_100044D0(int a1, int a2);
char __cdecl sub_100044E0(int a1, char a2);
char __cdecl sub_100044F0(int a1);
bool __cdecl sub_10004510(int a1);
int sub_10004530(); // weak
void *__cdecl sub_10004550();
int __cdecl sub_10004580(int a1, int a2, int a3);
int __cdecl sub_10004600(int a1, int a2, int a3, int a4);
// DWORD __stdcall GetTickCount();
void __cdecl sub_10004730(DWORD dwMilliseconds);
int __cdecl sub_10004740();
int __stdcall j_WSACleanup();
void *__cdecl sub_10004770(const char *a1);
int __cdecl sub_10004A40(SOCKET fd); // idb
struct hostent *__cdecl sub_10004B40();
int __stdcall sub_10004C20(int a1);
int __cdecl sub_10004DB0();
// char __usercall sub_10004E90<al>(unsigned int a1<eax>, const void *a2, int a3);
// DWORD __usercall sub_10005170<eax>(int a1<ebx>);
BYTE *__cdecl sub_10005220();
DWORD __cdecl sub_10005390();
int __cdecl sub_100053C0(const char *a1);
// signed int __usercall sub_100054E0<eax>(int a1<eax>, signed int a2<edx>, int a3<ecx>, int a4);
int __cdecl sub_10005550();
void *__cdecl sub_10005660(int a1);
signed int __cdecl sub_100056F0(signed int a1, void *a2);
signed int __cdecl sub_10005740(int a1);
int __fastcall sub_100057C0(int a1, const char *a2, int a3);
char *__cdecl sub_100058A0(const char *Str, const char *a2);
// struct hostent *__usercall sub_100059E0<eax>(int a1<edi>, const char *name, u_short hostshort, int a4);
signed int __cdecl sub_10005BB0();
void *__cdecl sub_10005C30(const char *Str, int a2);
int __cdecl sub_10005D20(const char *Str, const struct sockaddr *to);
// int __usercall sub_10005E40<eax>(const char *a1<eax>, const struct sockaddr *to);
int __fastcall sub_10005FA0(int a1, int a2, int a3);
// void *__usercall sub_100060A0<eax>(int a1<esi>, int a2, int a3, int a4);
void *__cdecl sub_100062F0(int a1, int a2, int a3, int a4, const char *Source, int a6, int a7);
void __cdecl sub_10006510(int a1, int a2);
void __cdecl sub_100065B0(int a1);
char __cdecl sub_10006640(signed int Str, int a2, const struct sockaddr *to);
signed int __cdecl sub_10006870(SOCKET *a1, int a2);
int __cdecl sub_10006900();
char __cdecl sub_10006960();
void *__cdecl sub_10006C20(int a1, int a2);
void *__cdecl sub_10006C50(int a1, int a2);
int __cdecl sub_10006CB0(int a1, signed int a2);
int __cdecl sub_10006CE0(int a1, const char *a2);
// char __usercall sub_10006E80<al>(int a1<eax>, int a2<edx>, int a3);
// signed int __usercall sub_10006F40<eax>(signed int a1<eax>, int a2, int a3, signed int a4);
// int __usercall sub_10007090<eax>(int result<eax>, signed int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_10007120<eax>(const char *a1<edx>, int a2<esi>);
// void __usercall sub_10007190(int a1<ebx>, int a2, int a3, int a4, int a5);
// void __usercall sub_10007440(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>, int a5, int a6, int a7, int a8);
void __fastcall sub_10007480(unsigned __int8 *a1, signed int a2, int a3, int a4);
int __cdecl sub_10007520(int a1, int a2, int a3);
// int __usercall sub_100077C0<eax>(int a1<edi>, int a2<esi>);
// u_long __usercall sub_10007810<eax>(signed int a1<edx>, int a2<edi>, int a3);
// signed int __usercall sub_100078B0<eax>(int a1<edi>, int a2<esi>);
int __cdecl sub_100078F0(void *a1, int a2, signed int a3, const struct sockaddr *to);
// DWORD __usercall sub_10007BC0<eax>(int a1<esi>);
signed int __cdecl sub_10007C10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
signed int __cdecl sub_10007F40(int a1, const char *name, int *a3);
signed int __thiscall sub_10008070(int this, int a2, const char *name, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
// int __usercall sub_100081D0<eax>(int a1<esi>);
int __cdecl sub_10008250(int a1, int a2);
DWORD __cdecl sub_10008280(int a1, int a2);
// DWORD __usercall sub_100088E0<eax>(int a1<eax>);
DWORD __cdecl sub_100089B0(int a1);
void __cdecl sub_10008A00(int a1);
int __cdecl sub_10008A70(int a1);
int __cdecl sub_10008AA0(const char *a1, const char *a2, int a3);
// signed int __usercall sub_10008C20<eax>(int a1<eax>, int a2<edx>);
// int __usercall sub_10008C80<eax>(int a1<ebx>, int a2);
void __cdecl sub_10008DD0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10008E30(int a1, int a2);
int __cdecl sub_10008E40(int a1);
int __cdecl sub_10008E60(int a1);
int __cdecl sub_10008E90(int a1, int a2, int a3, int a4);
int __cdecl sub_10008F10(int a1, const char *cp, u_short hostshort, int a4, int a5);
// int __usercall sub_10008F60<eax>(int result<eax>, int a2<ebx>, int a3, int a4);
// int __usercall sub_10009080<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_100090F0<eax>(int a1<esi>);
// int __usercall sub_100091C0<eax>(int a1<esi>);
// int __usercall sub_10009220<eax>(int a1<eax>);
int __cdecl sub_10009270(int a1);
int __cdecl sub_100092B0(int a1, char a2);
signed int __cdecl sub_100092D0(int a1, int a2);
void *__cdecl sub_10009330(int a1, signed int a2, int a3);
int __cdecl sub_100093A0(int a1);
int __cdecl sub_100093B0(int a1, int a2);
void __cdecl sub_10009400(int a1, int (__cdecl *PtFuncCompare)(const void *, const void *));
int __cdecl sub_10009420(int a1, void (__cdecl *a2)(_DWORD, _DWORD), int a3);
int __cdecl sub_10009460(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3);
int __cdecl sub_10009490(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3);
int __cdecl sub_100094E0(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3);
// int __usercall sub_10009520<eax>(int a1<ebx>, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD));
// int __usercall sub_10009560<eax>(int a1<eax>, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD), int a6);
void __cdecl sub_10009610(void *Memory);
void *__cdecl sub_100096C0(int a1, const void *a2, int a3);
int __cdecl sub_10009790(int a1, int a2);
int __cdecl sub_100097F0(int a1, const void *a2, int a3);
int __cdecl sub_10009840(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD), int a4, int a5);
void __cdecl sub_100098D0(int a1);
void *__cdecl sub_10009940(int a1, const void *a2);
int __cdecl PtFuncCompare(int *a1, int *a2);
signed int __cdecl sub_100099C0(int *a1, int *a2);
int sub_10009A70(); // weak
int sub_10009B00(); // weak
int __cdecl sub_10009BE0(int a1, int a2);
signed int __cdecl sub_10009C10(int a1, int a2);
signed int __cdecl sub_10009C60(int a1, int a2, __int16 a3);
int __cdecl sub_10009D00(int a1, int a2);
int __cdecl sub_10009D80(int a1, int a2);
int __cdecl sub_10009DA0(int a1);
int __cdecl sub_10009DE0(int a1);
void *__cdecl sub_10009EA0(int a1, const char *a2);
int __cdecl sub_10009F20(int a1, int a2);
signed int __cdecl sub_10009F70(int a1, signed int a2);
// int __usercall sub_10009FA0<eax>(int a1<eax>, unsigned int a2);
// signed int __usercall sub_10009FE0<eax>(int a1<edi>);
// unsigned int __usercall sub_1000A0F0<eax>(const void *a1<eax>, void **a2<edx>, int a3<ebx>);
int __cdecl sub_1000A190(int a1);
// int __usercall sub_1000A220<eax>(int a1<esi>);
// void __usercall sub_1000A2B0(int a1<esi>);
int __cdecl sub_1000A350(int a1);
void __cdecl sub_1000A3B0(int a1);
// char __usercall sub_1000A3F0<al>(int a1<eax>, int a2<ebx>, signed int a3);
int __fastcall sub_1000A4A0(int a1, int a2);
// signed int __usercall sub_1000A500<eax>(signed int a1<eax>, int a2<ecx>, int a3);
// __int16 __usercall sub_1000A5A0<ax>(int a1<eax>, signed int a2<edx>, int a3<ebx>, int a4<esi>, int a5);
// int __usercall sub_1000A5E0<eax>(int a1<eax>, char *a2<ecx>, int a3<ebx>, int a4, int a5);
// signed int __usercall sub_1000A800<eax>(int a1<eax>, int a2, signed int a3);
// signed int __usercall sub_1000A920<eax>(int a1<esi>);
// signed int __usercall sub_1000ACA0<eax>(signed int *a1<eax>, int a2<ecx>, int a3);
// signed int __usercall sub_1000AD70<eax>(signed int a1<eax>, int a2<ecx>, int a3);
// signed int __usercall sub_1000AEA0<eax>(signed int a1<eax>, int a2<ecx>, int a3);
// signed int __usercall sub_1000AFB0<eax>(int a1<esi>, int a2, int a3);
// signed int __usercall sub_1000B080<eax>(int a1<esi>);
void __cdecl sub_1000B1C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_1000B2B0<eax>(int a1<esi>);
signed int __cdecl sub_1000B350(int a1, const char *a2, const char *a3, u_long hostlong, int a5);
signed int __cdecl sub_1000B540(char optval, u_short hostshort, unsigned __int16 a3, int a4);
// signed int __usercall sub_1000B690<eax>(int a1<eax>);
signed int __cdecl sub_1000B8A0(int a1);
// signed int __usercall sub_1000B8E0<eax>(int a1<eax>, const char *buf, int len);
signed int __cdecl sub_1000B990(int a1, int a2, __int16 a3);
signed int __cdecl sub_1000BA00(int a1, int a2, __int16 a3, const char *buf, int len);
int __cdecl sub_1000BBF0(int, int, __int16, u_long hostlong); // idb
void *__cdecl sub_1000BC40(int a1, int a2, signed int a3, int a4, int a5, int a6);
void __cdecl sub_1000BCB0(void *Memory);
int __cdecl sub_1000BCF0(int a1);
void __cdecl sub_1000BD30(int a1, int a2);
signed int __cdecl sub_1000BD90(int a1, int a2);
int __cdecl sub_1000BDF0(int a1, int a2);
int __cdecl sub_1000BE50(int a1, void (__cdecl *a2)(_DWORD, _DWORD), int a3);
signed int __cdecl sub_1000BFD0(int a1, int a2);
int __cdecl sub_1000C170(int a1, int a2);
int __cdecl sub_1000C200(int a1, int a2);
int __cdecl sub_1000C250(int a1);
int __cdecl sub_1000C2B0(unsigned __int16 *a1);
int __cdecl sub_1000C320(int a1);
int __cdecl sub_1000C450(int a1, int a2);
int __cdecl sub_1000C5E0(int, char *Dest); // idb
int __thiscall sub_1000C620(void *this, int a2);
unsigned int __cdecl sub_1000CF00(int a1, const void *a2, unsigned int a3);
int __cdecl sub_1000CFC0(int a1, int a2);
int __cdecl sub_1000D070(const void *a1, unsigned int a2, char *Dest);
// char __usercall sub_1000D0E0<al>(int a1<ecx>, int a2<esi>, int a3, unsigned int a4, int a5, unsigned __int8 a6);
signed int __cdecl sub_1000D160(int a1);
char __cdecl sub_1000D1A0(int a1, int a2, unsigned __int8 a3);
char __cdecl sub_1000D260(int a1, char a2);
char __cdecl sub_1000D390(int a1, char a2);
void __cdecl sub_1000D480(int a1, int a2, int a3);
// int _CxxFrameHandler(void); weak
// int __cdecl CxxThrowException(_DWORD, _DWORD); weak
void __cdecl sub_1000DA6A();
void __cdecl sub_1000DAAE(); // idb
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// u_short __stdcall htons(u_short hostshort);
// char *__stdcall inet_ntoa(struct in_addr in);
// u_short __stdcall ntohs(u_short netshort);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall _WSAFDIsSet(SOCKET fd, fd_set *);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall gethostname(char *name, int namelen);
// u_long __stdcall ntohl(u_long netlong);
// int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall closesocket(SOCKET s);
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// u_long __stdcall htonl(u_long hostlong);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __usercall sub_1000DC40<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::GameSpyMgr();
// int __usercall sub_1000DC60<eax>(int a1<ebp>);
// int __usercall sub_1000DC69<eax>(int a1<ebp>);
// int __usercall sub_1000DC72<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::GetExtPlayerQueryResult();
int __cdecl GameSpyMgr::CDAuthCallback();
// int __usercall sub_1000DCB0<eax>(int a1<ebp>);
// int __usercall sub_1000DCB9<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::AuthCDKey();
int __cdecl GameSpyMgr::ReleaseCDKey();
int __cdecl GameSpyMgr::ReleaseAllCDKey();
int __cdecl GameSpyMgr::adderror_callback();
// int __usercall sub_1000DD00<eax>(int a1<ebp>);
int __cdecl GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface();
// int __usercall sub_1000DD20<eax>(int a1<ebp>);
// int __usercall sub_1000DD29<eax>(int a1<ebp>);
// int __usercall sub_1000DD32<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::GetServerQueryResult();
// int __usercall sub_1000DD60<eax>(int a1<ebp>);
// int __usercall sub_1000DD69<eax>(int a1<ebp>);
// int __usercall sub_1000DD72<eax>(int a1<ebp>);
// int __usercall sub_1000DD7B<eax>(int a1<ebp>);
// int __usercall sub_1000DD84<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::GetExtServerQueryResult();
int __cdecl GameSpyMgr::BeginServerQuery();
int __cdecl GameSpyMgr::UnRegisterGame();
// int __usercall sub_1000DDD0<eax>(int a1<ebp>);
// int __usercall sub_1000DDD9<eax>(int a1<ebp>);
// int __usercall sub_1000DDE2<eax>(int a1<ebp>);
// int __usercall sub_1000DDEB<eax>(int a1<ebp>);
// int __usercall sub_1000DDF4<eax>(int a1<ebp>);
// int __usercall sub_1000DDFD<eax>(int a1<ebp>);
// int __usercall sub_1000DE06<eax>(int a1<ebp>);
// int __usercall sub_1000DE0F<eax>(int a1<ebp>);
// int __usercall sub_1000DE18<eax>(int a1<ebp>);
// int __usercall sub_1000DE21<eax>(int a1<ebp>);
// int __usercall sub_1000DE2A<eax>(int a1<ebp>);
// int __usercall sub_1000DE33<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::Exec();
int __cdecl GameSpyMgr::serverkey_callback();
int __cdecl GameSpyMgr::playerkey_callback();
int __cdecl GameSpyMgr::count_callback();
int __cdecl GameSpyMgr::RegisterGame();
// int __usercall sub_1000DE90<eax>(int a1<ebp>);
int __cdecl GameSpyMgr::_GameSpyMgr();
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// int __thiscall FString::_FString(_DWORD); weak
// int __thiscall FString::FString(_DWORD, _DWORD); weak
// int __thiscall FString::operator_(_DWORD, _DWORD); weak
// void appUnwindf(const char *, ...); weak
// int __thiscall FStringTemp::_FStringTemp(_DWORD); weak
// int __thiscall TArray<char>::operator_(_DWORD, _DWORD); weak
// int FString::Printf(_DWORD, const char *, ...); weak
// int FOutputDevice::Logf(_DWORD, const char *, ...); weak
// int __thiscall FString::MakeCharArray(_DWORD); weak
// int __thiscall FOutputDevice::Log(_DWORD, _DWORD); weak
// int __thiscall FString::operator_(_DWORD, _DWORD); weak
// int __thiscall UObject::GetFullName(_DWORD, _DWORD); weak
// int __thiscall FString::operator_(_DWORD); weak
// int __cdecl appAtoi(const char *); weak
// int __cdecl ParseToken(_DWORD, _DWORD, _DWORD); weak
// int __cdecl ParseCommand(const char **, const char *); weak
// int __thiscall FString::FString(_DWORD); weak
// int __thiscall CDKeyResponseInterface::_CDKeyResponseInterface(_DWORD); weak
// int __thiscall UGameEngine::LocalizeHack(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall UGameEngine::GetLanguageHack(_DWORD); weak
// int __fastcall AGameInfo::GetFriendlyFirePercent(_DWORD, _DWORD); weak
// int __fastcall AGameReplicationInfo::GetNumberofTeams(_DWORD, _DWORD); weak
// int __fastcall AGameInfo::GetServerPort(_DWORD, _DWORD); weak
// int __thiscall ULevel::GetLevelInfo(_DWORD); weak
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// clock_t __cdecl clock();
// time_t __cdecl time(time_t *Time);
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// int __cdecl isdigit(int C);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// int __cdecl rand();
// char *__cdecl strchr(const char *Str, int Val);
// int sscanf(const char *Src, const char *Format, ...);
// void *__cdecl realloc(void *Memory, size_t NewSize);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl atoi(const char *Str);
// int __cdecl tolower(int C);
// double __cdecl atof(const char *String);
// int sprintf(char *Dest, const char *Format, ...);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Memory);
// void __cdecl srand(unsigned int Seed);


//----- (10001020) --------------------------------------------------------
int __cdecl sub_10001020(int a1)
{
  return (*(int (__stdcall **)(int))(*(_DWORD *)GMalloc + 12))(a1);
}
// 1000E064: using guessed type void *GMalloc;

//----- (10001090) --------------------------------------------------------
void *__thiscall GameSpyMgr::GameSpyMgr(void *this)
{
  void *v1; // esi@1

  v1 = this;
  FString::FString((char *)this + 24);
  return v1;
}
// 1000E068: using guessed type int __thiscall FString__FString(_DWORD);

//----- (100010A0) --------------------------------------------------------
int __thiscall GameSpyMgr::GameSpyMgr(int this, int a2, int a3)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = a2;
  *(_BYTE *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 2;
  FString::FString(this + 24);
  *(_BYTE *)(v3 + 32) = 0;
  *(_BYTE *)(v3 + 40) = 0;
  *(_BYTE *)(v3 + 33) = 1;
  *(_DWORD *)(v3 + 36) = 1;
  *(_BYTE *)(v3 + 16) = 121;
  *(_BYTE *)(v3 + 17) = 50;
  *(_BYTE *)(v3 + 18) = 115;
  *(_BYTE *)(v3 + 19) = 56;
  *(_BYTE *)(v3 + 20) = 70;
  *(_BYTE *)(v3 + 21) = 104;
  *(_BYTE *)(v3 + 22) = 0;
  return v3;
}
// 1000E068: using guessed type int __thiscall FString__FString(_DWORD);

//----- (10001120) --------------------------------------------------------
int __thiscall GameSpyMgr::GetLocalID(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 36);
  *(_DWORD *)(this + 36) = result + 1;
  return result;
}

//----- (10001130) --------------------------------------------------------
int __cdecl GameSpyMgr::SetUplinkCB(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)(a1 + 48) = a3;
  return result;
}

//----- (10001150) --------------------------------------------------------
int __thiscall GameSpyMgr::GameSpyMgr(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_BYTE *)(this + 4) = *(_BYTE *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 20) = *(_DWORD *)(a2 + 20);
  FString::FString(this + 24, a2 + 24);
  *(_BYTE *)(v2 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(v2 + 33) = *(_BYTE *)(a2 + 33);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(a2 + 36);
  *(_BYTE *)(v2 + 40) = *(_BYTE *)(a2 + 40);
  *(_DWORD *)(v2 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(v2 + 48) = *(_DWORD *)(a2 + 48);
  return v2;
}
// 1000E01C: using guessed type int __thiscall FString__FString(_DWORD, _DWORD);

//----- (100011C0) --------------------------------------------------------
int __thiscall GameSpyMgr::operator_(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_BYTE *)(this + 4) = *(_BYTE *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(this + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(this + 17) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(this + 18) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(this + 19) = *(_BYTE *)(a2 + 19);
  *(_BYTE *)(this + 20) = *(_BYTE *)(a2 + 20);
  *(_BYTE *)(this + 21) = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(this + 22) = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(this + 23) = *(_BYTE *)(a2 + 23);
  FString::operator_(this + 24, a2 + 24);
  *(_BYTE *)(v2 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(v2 + 33) = *(_BYTE *)(a2 + 33);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(a2 + 36);
  *(_BYTE *)(v2 + 40) = *(_BYTE *)(a2 + 40);
  *(_DWORD *)(v2 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(v2 + 48) = *(_DWORD *)(a2 + 48);
  return v2;
}
// 1000E020: using guessed type int __thiscall FString__operator_(_DWORD, _DWORD);

//----- (10001250) --------------------------------------------------------
void *__thiscall GameSpyCDKeyResponseInterface::_GameSpyCDKeyResponseInterface(void *this)
{
  void *result; // eax@1

  result = CDKeyResponseInterface::_vftable_;
  *(_DWORD *)this = CDKeyResponseInterface::_vftable_;
  CDKeyResponseInterface::mpCDKeyInterface = 0;
  return result;
}
// 1000E098: using guessed type void *CDKeyResponseInterface__mpCDKeyInterface;
// 1000E09C: using guessed type void *CDKeyResponseInterface___vftable_;

//----- (10001270) --------------------------------------------------------
void *__thiscall GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface(void *this, int a2)
{
  void *result; // eax@1

  result = this;
  *(_DWORD *)this = &GameSpyCDKeyResponseInterface::_vftable_;
  return result;
}
// 1000E288: using guessed type int (__stdcall *GameSpyCDKeyResponseInterface___vftable_)(int, int, int);

//----- (10001280) --------------------------------------------------------
void *__thiscall GameSpyCDKeyResponseInterface::operator_(void *this, int a2)
{
  return this;
}

//----- (10001290) --------------------------------------------------------
int __thiscall GameSpyMgr::GetServerQueryNumResults(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 12) == 5 )
    result = sub_10003620(*(_DWORD *)(this + 8));
  else
    result = 0;
  return result;
}

//----- (100012B0) --------------------------------------------------------
int __thiscall GameSpyMgr::GetExtPlayerQueryResult(void *this, int a2, int a3, int a4)
{
  void *v4; // esi@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ST1C_4@3
  int v10; // ST18_4@3
  int v11; // ST14_4@3
  int v12; // ST10_4@3
  int v13; // eax@3
  int v14; // eax@3
  int v16; // [sp+0h] [bp-38h]@1
  char v17; // [sp+Ch] [bp-2Ch]@3
  char v18; // [sp+14h] [bp-24h]@1
  int v19; // [sp+24h] [bp-14h]@1
  int *v20; // [sp+28h] [bp-10h]@1
  int v21; // [sp+34h] [bp-4h]@1

  v4 = this;
  v19 = 0;
  v20 = &v16;
  v21 = 1;
  FString::FString(&v18);
  v5 = *((_DWORD *)v4 + 2);
  LOBYTE(v21) = 2;
  v6 = sub_100035C0(v5, a3);
  v7 = v6;
  if ( v6 )
  {
    LOBYTE(v8) = sub_10003EA0(v6);
    if ( v8 )
    {
      v9 = sub_10004600(v7, a4, (int)"team", 0);
      v10 = sub_10004600(v7, a4, (int)"ping", 999);
      v11 = sub_10004600(v7, a4, (int)"deaths", 999);
      v12 = sub_10004600(v7, a4, (int)"score", 999);
      v13 = sub_10003CC0(v7, a4, (int)"player", (int)"(NO NAME)");
      v14 = FString::Printf(&v17, "\"%s\" %d %d %d %d ###", v13, v12, v11, v10, v9);
      LOBYTE(v21) = 3;
      TArray<char>::operator_(&v18, v14);
      LOBYTE(v21) = 2;
      FStringTemp::_FStringTemp(&v17);
    }
  }
  FString::FString(a2, &v18);
  v19 = 1;
  LOBYTE(v21) = 1;
  FString::_FString(&v18);
  return a2;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);
// 1000E01C: using guessed type int __thiscall FString__FString(_DWORD, _DWORD);
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);
// 1000E02C: using guessed type int __thiscall TArray_char___operator_(_DWORD, _DWORD);
// 1000E030: using guessed type int FString__Printf(_DWORD, const char *, ...);
// 1000E068: using guessed type int __thiscall FString__FString(_DWORD);

//----- (10001420) --------------------------------------------------------
int __thiscall GameSpyMgr::CancelServerQuery(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 8);
  if ( result )
    result = sub_100034C0(*(_DWORD *)(this + 8));
  return result;
}

//----- (10001430) --------------------------------------------------------
int __thiscall GameSpyMgr::ClearServerQueryResults(int this)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = this;
  result = *(_DWORD *)(this + 8);
  if ( result )
  {
    result = sub_100034E0(*(_DWORD *)(this + 8));
    *(_DWORD *)(v1 + 12) = 2;
  }
  else
  {
    *(_DWORD *)(this + 12) = 1;
  }
  return result;
}

//----- (10001460) --------------------------------------------------------
char __cdecl GameSpyMgr::SBCallback(int a1, int a2, int a3, int a4)
{
  int v4; // eax@2

  if ( a2 )
  {
    LOBYTE(v4) = a2 - 4;
    if ( a2 == 4 )
    {
      *(_DWORD *)(a4 + 12) = 5;
    }
    else
    {
      LOBYTE(v4) = a2 - 5;
      if ( a2 == 5 )
      {
        LOBYTE(v4) = a4;
        *(_DWORD *)(a4 + 12) = 0;
      }
    }
  }
  else
  {
    LOBYTE(v4) = *(_BYTE *)(a4 + 32);
    if ( !(_BYTE)v4 )
    {
      v4 = sub_100035B0(a1);
      if ( !v4 )
        *(_DWORD *)(a4 + 12) = 5;
    }
  }
  return v4;
}

//----- (100014B0) --------------------------------------------------------
bool __cdecl GameSpyMgr::IsBackEndAvailable()
{
  int i; // eax@1

  sub_100053C0((const char *)off_10011014);
  for ( i = sub_10005550(); !i; i = sub_10005550() )
    sub_10004730(1u);
  return i == 1;
}

//----- (100014F0) --------------------------------------------------------
bool __thiscall GameSpyMgr::CreateServerBrowser(int this)
{
  int v1; // esi@1

  v1 = this;
  if ( !*(_DWORD *)(this + 8) )
    *(_DWORD *)(this + 8) = sub_10003310(
                              off_10011014,
                              off_10011014,
                              this + 16,
                              0,
                              10,
                              1,
                              (int)GameSpyMgr::SBCallback,
                              this);
  return *(_DWORD *)(v1 + 8) != 0;
}

//----- (10001530) --------------------------------------------------------
void __thiscall GameSpyMgr::DeleteServerBrowser(int this)
{
  int v1; // esi@1

  v1 = this;
  if ( *(_DWORD *)(this + 8) )
  {
    sub_100033A0(*(char **)(this + 8));
    *(_DWORD *)(v1 + 8) = 0;
  }
}

//----- (10001550) --------------------------------------------------------
signed int __cdecl GameSpyMgr::RegisterCustomKeys()
{
  signed int v0; // edi@1
  void **v1; // esi@1
  signed int result; // eax@2

  v0 = 50;
  v1 = (void **)off_10011030;
  do
  {
    result = sub_100056F0(v0, *v1);
    ++v1;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&off_10011038 );
  return result;
}
// 10011030: using guessed type char *off_10011030[2];
// 10011038: using guessed type int (__thiscall **off_10011038)(void *, char);

//----- (10001580) --------------------------------------------------------
char __thiscall GameSpyMgr::Tick(int this, int a2)
{
  int v2; // esi@1
  char result; // al@1
  int v4; // esi@4

  v2 = this;
  result = *(_BYTE *)(this + 4);
  if ( result )
  {
    sub_10008A70(0);
    result = *(_BYTE *)(v2 + 40);
    if ( result )
      result = sub_10006960();
  }
  v4 = *(_DWORD *)(v2 + 8);
  if ( v4 )
    result = sub_100034A0(v4);
  return result;
}

//----- (100015C0) --------------------------------------------------------
int __cdecl GameSpyMgr::CDAuthCallback(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  int v6; // ecx@6
  int v7; // [sp+0h] [bp-24h]@1
  int *v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+20h] [bp-4h]@1

  v8 = &v7;
  v9 = 0;
  FOutputDevice::Logf(GLog, "CD Auth returned: id: %d, auth: %d, msg: %s", a2, a3, a4);
  if ( a1 == 987 )
  {
    if ( !a3 )
      FOutputDevice::Logf(GLog, "CD AUTH FAILED for id %d: %s", a2, a4);
    v6 = a5;
    result = *(_DWORD *)(a5 + 44);
    if ( result )
    {
      LOBYTE(v6) = a3 != 0;
      result = ((int (__cdecl *)(int, int, _DWORD))result)(a2, v6, *(_DWORD *)(a5 + 48));
    }
  }
  else
  {
    result = FOutputDevice::Logf(GLog, "ERROR: Received wrong game id?!  howwww!!?");
  }
  return result;
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E038: using guessed type void *GLog;

//----- (10001680) --------------------------------------------------------
void __usercall sub_10001680(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10001694) --------------------------------------------------------
void __cdecl sub_10001694()
{
  appUnwindf("%s", off_1001105C[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 1001105C: using guessed type char *off_1001105C[15];

//----- (100016C0) --------------------------------------------------------
int __thiscall GameSpyMgr::AuthCDKey(int this, int a2, int a3, char a4, int a5, char a6, int a7)
{
  int v7; // esi@1
  const char *v8; // edi@1
  int v10; // [sp+0h] [bp-28h]@1
  int v11; // [sp+14h] [bp-14h]@1
  int *v12; // [sp+18h] [bp-10h]@1
  int v13; // [sp+24h] [bp-4h]@1

  v12 = &v10;
  v11 = this;
  v13 = 0;
  LOBYTE(v13) = 2;
  v7 = FString::MakeCharArray(&a4);
  v8 = (const char *)FString::MakeCharArray(&a6);
  FOutputDevice::Logf(GLog, "Sending CD Auth for %i.%i.%i.%i", (unsigned __int8)a3, BYTE1(a3), BYTE2(a3), BYTE3(a3));
  sub_100062F0(987, a2, a3, v7, v8, (int)GameSpyMgr::CDAuthCallback, v11);
  (*(void (__stdcall **)(int))(*(_DWORD *)GMalloc + 12))(v7);
  (*(void (__stdcall **)(const char *))(*(_DWORD *)GMalloc + 12))(v8);
  v13 = 0;
  FString::_FString(&a4);
  v13 = -1;
  return FString::_FString(&a6);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E038: using guessed type void *GLog;
// 1000E03C: using guessed type int __thiscall FString__MakeCharArray(_DWORD);
// 1000E064: using guessed type void *GMalloc;

//----- (1000179D) --------------------------------------------------------
void __usercall sub_1000179D(int a1<ebp>)
{
  *(_DWORD *)(a1 - 24) = *(_DWORD *)(a1 - 28);
  CxxThrowException(a1 - 24, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (100017B1) --------------------------------------------------------
void __cdecl sub_100017B1()
{
  appUnwindf("%s", off_10011060[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011060: using guessed type char *off_10011060[14];

//----- (100017D0) --------------------------------------------------------
void __stdcall GameSpyMgr::ReleaseCDKey(int a1)
{
  int v1; // [sp+0h] [bp-24h]@1
  int *v2; // [sp+14h] [bp-10h]@1
  int v3; // [sp+20h] [bp-4h]@1

  v2 = &v1;
  v3 = 0;
  if ( a1 >= 0 )
  {
    FOutputDevice::Logf(GLog, "Releasing CD Key for ID %d", a1);
    sub_10006510(987, a1);
  }
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E038: using guessed type void *GLog;

//----- (10001837) --------------------------------------------------------
void __usercall sub_10001837(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (1000184B) --------------------------------------------------------
void __cdecl sub_1000184B()
{
  appUnwindf("%s", off_10011064[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011064: using guessed type char *off_10011064[13];

//----- (10001870) --------------------------------------------------------
void __cdecl GameSpyMgr::ReleaseAllCDKey()
{
  int v0; // [sp+0h] [bp-24h]@1
  int *v1; // [sp+14h] [bp-10h]@1
  int v2; // [sp+20h] [bp-4h]@1

  v1 = &v0;
  v2 = 0;
  FOutputDevice::Log(GLog, "Releasing all CD Keys");
  sub_100065B0(987);
}
// 1000E038: using guessed type void *GLog;
// 1000E040: using guessed type int __thiscall FOutputDevice__Log(_DWORD, _DWORD);

//----- (100018C8) --------------------------------------------------------
void __usercall sub_100018C8(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (100018DC) --------------------------------------------------------
void __cdecl sub_100018DC()
{
  appUnwindf("%s", off_10011068[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011068: using guessed type char *off_10011068[12];

//----- (10001900) --------------------------------------------------------
char __thiscall GameSpyMgr::UpdateState(int this)
{
  char result; // al@1

  result = *(_BYTE *)(this + 4);
  if ( result )
    result = sub_100089B0(0);
  return result;
}

//----- (10001910) --------------------------------------------------------
int __cdecl sub_10001910(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ecx@6
  int v6; // ecx@8

  result = *(_DWORD *)(a2 + 1172);
  v3 = 0;
  while ( result )
  {
    v4 = *(_DWORD *)(result + 36);
    if ( v4 )
    {
      while ( (void *)v4 != APlayerController::PrivateStaticClass )
      {
        v4 = *(_DWORD *)(v4 + 48);
        if ( !v4 )
          goto LABEL_5;
      }
    }
    else
    {
LABEL_5:
      if ( APlayerController::PrivateStaticClass )
        goto LABEL_9;
    }
    v5 = *(_DWORD *)(result + 768);
    if ( v5 )
    {
      if ( !(*(_BYTE *)(v5 + 720) & 8) )
      {
        v6 = v3++;
        if ( v6 == a1 )
          return result;
      }
    }
LABEL_9:
    result = *(_DWORD *)(result + 688);
  }
  return 0;
}
// 1000E070: using guessed type void *APlayerController__PrivateStaticClass;

//----- (10001990) --------------------------------------------------------
int __cdecl GameSpyMgr::keylist_callback(int a1, int a2)
{
  int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_10006CB0(a2, 21);
      sub_10006CB0(a2, 22);
      sub_10006CB0(a2, 26);
      sub_10006CB0(a2, 24);
      result = sub_10006CB0(a2, 25);
    }
    else
    {
      result = a1 - 2;
      if ( a1 == 2 )
      {
        sub_10006CB0(a2, 28);
        result = sub_10006CB0(a2, 29);
      }
    }
  }
  else
  {
    sub_10006CB0(a2, 1);
    sub_10006CB0(a2, 3);
    sub_10006CB0(a2, 4);
    sub_10006CB0(a2, 5);
    sub_10006CB0(a2, 6);
    sub_10006CB0(a2, 8);
    sub_10006CB0(a2, 10);
    sub_10006CB0(a2, 11);
    sub_10006CB0(a2, 9);
    sub_10006CB0(a2, 13);
    sub_10006CB0(a2, 16);
    sub_10006CB0(a2, 50);
    result = sub_10006CB0(a2, 51);
  }
  return result;
}

//----- (10001A70) --------------------------------------------------------
int __cdecl GameSpyMgr::adderror_callback(int a1, int a2)
{
  int v3; // [sp+0h] [bp-24h]@1
  int *v4; // [sp+14h] [bp-10h]@1
  int v5; // [sp+20h] [bp-4h]@1

  v4 = &v3;
  v5 = 0;
  return FOutputDevice::Logf(GLog, "GameSpyMgr Error: %d - %s", a1, a2);
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E038: using guessed type void *GLog;

//----- (10001AC8) --------------------------------------------------------
void __usercall sub_10001AC8(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10001ADC) --------------------------------------------------------
void __cdecl sub_10001ADC()
{
  appUnwindf("%s", off_1001106C[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 1001106C: using guessed type char *off_1001106C[11];

//----- (10001B20) --------------------------------------------------------
void *__thiscall GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface(void *this)
{
  void *v1; // esi@1
  HKEY hKey; // [sp+4h] [bp-98h]@1
  DWORD cbData; // [sp+8h] [bp-94h]@1
  void *v5; // [sp+Ch] [bp-90h]@1
  BYTE Data; // [sp+10h] [bp-8Ch]@2
  int v7; // [sp+98h] [bp-4h]@1

  v1 = this;
  *(_DWORD *)this = CDKeyResponseInterface::_vftable_;
  v5 = this;
  CDKeyResponseInterface::mpCDKeyInterface = this;
  v7 = 0;
  *(_DWORD *)this = &GameSpyCDKeyResponseInterface::_vftable_;
  cbData = 128;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\LucasArts\\Star Wars Republic Commando\\1.0", 0, 1u, &hKey)
    && !RegQueryValueExA(hKey, "CD Key", 0, 0, &Data, &cbData)
    && cbData <= 0x80 )
  {
    RegCloseKey(hKey);
    FString::operator_(CDKeyResponseInterface::msCDKeyString, &Data);
  }
  return v1;
}
// 1000E044: using guessed type int __thiscall FString__operator_(_DWORD, _DWORD);
// 1000E078: using guessed type void *CDKeyResponseInterface__msCDKeyString;
// 1000E098: using guessed type void *CDKeyResponseInterface__mpCDKeyInterface;
// 1000E09C: using guessed type void *CDKeyResponseInterface___vftable_;
// 1000E288: using guessed type int (__stdcall *GameSpyCDKeyResponseInterface___vftable_)(int, int, int);

//----- (10001BF0) --------------------------------------------------------
int __stdcall GameSpyCDKeyResponseInterface::GetResponse(const char *a1, const char *a2, int a3)
{
  return sub_10008AA0(a2, a1, a3);
}

//----- (10001CA0) --------------------------------------------------------
int __thiscall GameSpyMgr::GetServerQueryResult(void *this, int a2, int a3, int a4)
{
  void *v4; // edi@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // esi@1
  char v8; // bl@2
  int v9; // eax@2
  int v10; // eax@5
  char *v11; // eax@7
  char *v12; // edi@9
  int v13; // eax@9
  int v14; // ST34_4@11
  int v15; // ST30_4@11
  int v16; // ST2C_4@11
  int v17; // ST28_4@11
  int v18; // ST24_4@11
  int v19; // ST20_4@11
  int v20; // ST1C_4@11
  int v21; // ST18_4@11
  int v22; // ST14_4@11
  int v23; // ST10_4@11
  int v24; // eax@11
  int v25; // eax@11
  int v26; // eax@12
  int v28; // [sp+0h] [bp-3Ch]@1
  char v29; // [sp+Ch] [bp-30h]@11
  char v30; // [sp+14h] [bp-28h]@1
  int v31; // [sp+24h] [bp-18h]@1
  void *v32; // [sp+28h] [bp-14h]@1
  int *v33; // [sp+2Ch] [bp-10h]@1
  int v34; // [sp+38h] [bp-4h]@1
  int v35; // [sp+48h] [bp+Ch]@3

  v4 = this;
  v31 = 0;
  v33 = &v28;
  v32 = this;
  v34 = 1;
  FString::FString(&v30);
  v5 = *((_DWORD *)v4 + 2);
  LOBYTE(v34) = 2;
  v6 = sub_100035C0(v5, a3);
  v7 = v6;
  if ( v6 )
  {
    v8 = 0;
    LOBYTE(v9) = sub_10003F10(v6);
    if ( v9 )
    {
      v35 = sub_10003ED0(v7);
      if ( sub_10003660(*((_DWORD *)v4 + 2)) == v35 )
        v8 = 1;
    }
    LOBYTE(v10) = sub_10003E80(v7);
    if ( v10 )
    {
      if ( v8 )
        v11 = sub_10003F50(v7);
      else
        v11 = sub_10003EC0((struct in_addr *)v7);
      v12 = v11;
      v13 = sub_100043F0(v7);
      if ( v13 >= 999 )
        v13 = 999;
      v14 = v13;
      v15 = sub_10004580(v7, (int)"dedicatedserver", 0);
      v16 = sub_10004580(v7, (int)"numteams", 0);
      v17 = sub_10004580(v7, (int)"timelimit", 0);
      v18 = sub_10004580(v7, (int)"fraglimit", 0);
      v19 = sub_10003BE0(v7, (int)"gametype", (int)"(NO GAME)");
      v20 = sub_10003BE0(v7, (int)"mapname", (int)"(NO MAP)");
      v21 = sub_10004580(v7, (int)"maxplayers", 0);
      v22 = sub_10004580(v7, (int)"numplayers", 0);
      v23 = sub_10004580(v7, (int)"hostport", 7777);
      v24 = sub_10003BE0(v7, (int)"hostname", (int)"(NO NAME)");
      v25 = FString::Printf(
              &v29,
              "\"%s\" \"%s\" %d %d %d \"%s\" \"%s\" %d %d %d %d %d ###",
              v24,
              v12,
              v23,
              v22,
              v21,
              v20,
              v19,
              v18,
              v17,
              v16,
              v15,
              v14);
      LOBYTE(v34) = 3;
      TArray<char>::operator_(&v30, v25);
      LOBYTE(v34) = 2;
      FStringTemp::_FStringTemp(&v29);
    }
  }
  LOBYTE(v26) = sub_10003EA0(v7);
  if ( !v26 )
    sub_100039C0(*((_DWORD *)v32 + 2), v7, 1, 1);
  FString::FString(a2, &v30);
  v31 = 1;
  LOBYTE(v34) = 1;
  FString::_FString(&v30);
  return a2;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);
// 1000E01C: using guessed type int __thiscall FString__FString(_DWORD, _DWORD);
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);
// 1000E02C: using guessed type int __thiscall TArray_char___operator_(_DWORD, _DWORD);
// 1000E030: using guessed type int FString__Printf(_DWORD, const char *, ...);
// 1000E068: using guessed type int __thiscall FString__FString(_DWORD);

//----- (10001EA2) --------------------------------------------------------
void __usercall sub_10001EA2(int a1<ebp>)
{
  *(_DWORD *)(a1 - 28) = *(_DWORD *)(a1 - 32);
  CxxThrowException(a1 - 28, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10001EB6) --------------------------------------------------------
void __cdecl sub_10001EB6()
{
  appUnwindf("%s", off_10011070[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011070: using guessed type char *off_10011070[10];

//----- (10001EE0) --------------------------------------------------------
int __thiscall GameSpyMgr::GetExtServerQueryResult(void *this, int a2, int a3)
{
  void *v3; // edi@1
  int v4; // esi@1
  bool v5; // zf@1
  void *v6; // ecx@1
  int i; // eax@2
  int v8; // eax@8
  int v9; // edx@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@15
  int v15; // eax@16
  int v16; // eax@19
  int v17; // edi@22
  int v18; // esi@22
  int v19; // ST14_4@22
  int v20; // eax@22
  int v21; // eax@22
  int v23; // [sp+0h] [bp-48h]@1
  char v24; // [sp+Ch] [bp-3Ch]@22
  char v25; // [sp+14h] [bp-34h]@1
  char v26; // [sp+1Ch] [bp-2Ch]@14
  int v27; // [sp+20h] [bp-28h]@16
  char v28; // [sp+24h] [bp-24h]@14
  int v29; // [sp+28h] [bp-20h]@19
  int v30; // [sp+34h] [bp-14h]@1
  int *v31; // [sp+38h] [bp-10h]@1
  int v32; // [sp+44h] [bp-4h]@1
  int v33; // [sp+54h] [bp+Ch]@13

  v3 = this;
  v30 = 0;
  v31 = &v23;
  v32 = 1;
  FString::FString(&v25);
  v4 = *(_DWORD *)v3;
  v5 = *(_DWORD *)v3 == 0;
  v6 = UGameEngine::PrivateStaticClass;
  LOBYTE(v32) = 2;
  if ( v5 )
    goto LABEL_9;
  for ( i = *(_DWORD *)(v4 + 36); i; i = *(_DWORD *)(i + 48) )
  {
    if ( (void *)i == UGameEngine::PrivateStaticClass )
      goto LABEL_13;
  }
  if ( UGameEngine::PrivateStaticClass )
  {
    if ( v4 )
    {
      v8 = UObject::GetFullName(v4, UGameEngine::PrivateStaticClass == 0);
      v6 = UGameEngine::PrivateStaticClass;
      v9 = v8;
LABEL_10:
      v10 = *((_DWORD *)v6 + 8);
      if ( !v10 )
        v10 = *(_DWORD *)FName::Names;
      FOutputDevice::Logf(GError, "Cast of %s to %s failed", v9, v10 + 12);
      goto LABEL_13;
    }
LABEL_9:
    v9 = (int)"NULL";
    goto LABEL_10;
  }
LABEL_13:
  v33 = sub_100035C0(*((_DWORD *)v3 + 2), a3);
  if ( v33 )
  {
    FString::FString(&v26);
    LOBYTE(v32) = 3;
    FString::FString(&v28);
    LOBYTE(v32) = 4;
    if ( v4 )
    {
      v11 = UGameEngine::GetLanguageHack(v4);
      v12 = UGameEngine::LocalizeHack(v4, "GameSpyMenuTemplate", "DedicatedServerLabel", "XInterfaceGamespy", v11, 1);
      FString::operator_(&v26, v12);
      v13 = UGameEngine::GetLanguageHack(v4);
      v14 = UGameEngine::LocalizeHack(v4, "GameSpyMenuTemplate", "FriendlyFirePctLabel", "XInterfaceGamespy", v13, 1);
      FString::operator_(&v28, v14);
    }
    v15 = 8 * v27 >> 3;
    if ( !v15 || v15 == 1 )
      FString::operator_(&v26, "Dedicated Server");
    v16 = 8 * v29 >> 3;
    if ( !v16 || v16 == 1 )
      FString::operator_(&v28, "Friendly Fire Pct");
    v17 = FString::operator_(&v28);
    v18 = FString::operator_(&v26);
    v19 = sub_10004580(v33, (int)"friendlyfire", 0);
    v20 = sub_10004580(v33, (int)"dedicatedserver", 0);
    v21 = FString::Printf(&v24, "2 \"%s\" %d ### \"%s\" \"%d%%%%\" ###", v18, v20, v17, v19);
    LOBYTE(v32) = 5;
    TArray<char>::operator_(&v25, v21);
    LOBYTE(v32) = 4;
    FStringTemp::_FStringTemp(&v24);
    LOBYTE(v32) = 3;
    FString::_FString(&v28);
    LOBYTE(v32) = 2;
    FString::_FString(&v26);
  }
  FString::FString(a2, &v25);
  v30 |= 1u;
  LOBYTE(v32) = 1;
  FString::_FString(&v25);
  return a2;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);
// 1000E01C: using guessed type int __thiscall FString__FString(_DWORD, _DWORD);
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);
// 1000E02C: using guessed type int __thiscall TArray_char___operator_(_DWORD, _DWORD);
// 1000E030: using guessed type int FString__Printf(_DWORD, const char *, ...);
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E044: using guessed type int __thiscall FString__operator_(_DWORD, _DWORD);
// 1000E048: using guessed type void *GError;
// 1000E04C: using guessed type void *FName__Names;
// 1000E050: using guessed type int __thiscall UObject__GetFullName(_DWORD, _DWORD);
// 1000E054: using guessed type int __thiscall FString__operator_(_DWORD);
// 1000E068: using guessed type int __thiscall FString__FString(_DWORD);
// 1000E07C: using guessed type void *UGameEngine__PrivateStaticClass;
// 1000E080: using guessed type int __thiscall UGameEngine__LocalizeHack(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000E084: using guessed type int __thiscall UGameEngine__GetLanguageHack(_DWORD);

//----- (10002117) --------------------------------------------------------
void __usercall sub_10002117(int a1<ebp>)
{
  *(_DWORD *)(a1 - 24) = *(_DWORD *)(a1 - 28);
  CxxThrowException(a1 - 24, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (1000212B) --------------------------------------------------------
void __cdecl sub_1000212B()
{
  appUnwindf("%s", off_10011074[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011074: using guessed type char *off_10011074[9];

//----- (10002150) --------------------------------------------------------
char __thiscall GameSpyMgr::BeginServerQuery(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  signed int v3; // eax@2
  char v4; // al@6
  const char *v5; // eax@7
  int v7; // [sp+0h] [bp-30h]@1
  char v8; // [sp+Ch] [bp-24h]@1
  char v9; // [sp+Dh] [bp-23h]@1
  char v10; // [sp+Eh] [bp-22h]@1
  char v11; // [sp+Fh] [bp-21h]@1
  char v12; // [sp+10h] [bp-20h]@1
  char v13; // [sp+11h] [bp-1Fh]@1
  char v14; // [sp+12h] [bp-1Eh]@1
  char v15; // [sp+13h] [bp-1Dh]@1
  char v16; // [sp+14h] [bp-1Ch]@1
  char v17; // [sp+15h] [bp-1Bh]@1
  char v18; // [sp+16h] [bp-1Ah]@1
  int *v19; // [sp+20h] [bp-10h]@1
  int v20; // [sp+2Ch] [bp-4h]@1

  v1 = this;
  v2 = *(_DWORD *)(this + 8);
  v19 = &v7;
  v20 = 0;
  v8 = 1;
  v9 = 4;
  v10 = 8;
  v11 = 10;
  v12 = 5;
  v13 = 6;
  v14 = 13;
  v15 = 16;
  v16 = 9;
  v17 = 50;
  v18 = 51;
  if ( v2
    || (LOBYTE(v3) = GameSpyMgr::IsBackEndAvailable(), (_BYTE)v3)
    && (GameSpyMgr::RegisterCustomKeys(), LOBYTE(v3) = GameSpyMgr::CreateServerBrowser(v1), (_BYTE)v3) )
  {
    GameSpyMgr::CancelServerQuery(v1);
    GameSpyMgr::ClearServerQueryResults(v1);
    v4 = *(_BYTE *)(v1 + 32);
    *(_DWORD *)(v1 + 12) = 3;
    if ( v4 )
    {
      v3 = sub_10003800(*(_DWORD *)(v1 + 8), *(_BYTE *)(v1 + 33), 0x2B82u, 0x2BB4u);
    }
    else
    {
      v5 = (const char *)FString::operator_(v1 + 24);
      v3 = sub_10003790(*(_DWORD *)(v1 + 8), *(_BYTE *)(v1 + 33), 0, (int)&v8, 11, v5);
    }
    if ( v3 )
      *(_DWORD *)(v1 + 12) = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 12) = 1;
  }
  return v3;
}
// 1000E054: using guessed type int __thiscall FString__operator_(_DWORD);

//----- (10002251) --------------------------------------------------------
void __usercall sub_10002251(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10002265) --------------------------------------------------------
void __cdecl sub_10002265()
{
  appUnwindf("%s", off_10011078[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011078: using guessed type char *off_10011078[8];

//----- (10002290) --------------------------------------------------------
void __thiscall GameSpyMgr::UnRegisterGame(int this)
{
  int v1; // esi@1
  char v2; // al@1
  int v3; // [sp+0h] [bp-24h]@1
  int *v4; // [sp+14h] [bp-10h]@1
  int v5; // [sp+20h] [bp-4h]@1

  v1 = this;
  v2 = *(_BYTE *)(this + 4);
  v4 = &v3;
  v5 = 0;
  if ( v2 )
  {
    if ( *(_BYTE *)(this + 40) )
    {
      GameSpyMgr::ReleaseAllCDKey();
      sub_10006900();
      *(_BYTE *)(v1 + 40) = 0;
    }
    sub_10008A00(0);
    *(_BYTE *)(v1 + 4) = 0;
  }
}

//----- (100022EE) --------------------------------------------------------
void __usercall sub_100022EE(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10002302) --------------------------------------------------------
void __cdecl sub_10002302()
{
  appUnwindf("%s", off_1001107C[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 1001107C: using guessed type char *off_1001107C[7];

//----- (10002330) --------------------------------------------------------
signed int __thiscall GameSpyMgr::Exec(void *this, int a2, int a3)
{
  int v3; // edi@1
  int v5; // eax@10
  int v6; // eax@12
  const char *v7; // eax@12
  int v8; // ebx@12
  int v9; // eax@12
  const char *v10; // eax@12
  int v11; // esi@12
  int v12; // eax@12
  int v13; // eax@14
  int v14; // eax@14
  const char *v15; // eax@14
  int v16; // ebx@14
  int v17; // eax@14
  const char *v18; // eax@14
  int v19; // eax@14
  int v20; // esi@14
  int v21; // eax@14
  int v22; // eax@22
  const char *v23; // eax@22
  int v24; // ebx@22
  int v25; // eax@22
  const char *v26; // eax@22
  int v27; // esi@22
  int v28; // eax@22
  int v29; // eax@24
  const char *v30; // eax@24
  int v31; // esi@24
  int v32; // eax@24
  int v33; // eax@29
  const char *v34; // eax@29
  int v35; // [sp-8h] [bp-38h]@12
  int v36; // [sp-4h] [bp-34h]@12
  int v37; // [sp+0h] [bp-30h]@1
  char v38; // [sp+Ch] [bp-24h]@12
  void *v39; // [sp+1Ch] [bp-14h]@1
  int *v40; // [sp+20h] [bp-10h]@1
  int v41; // [sp+2Ch] [bp-4h]@1

  v40 = &v37;
  v3 = (int)this;
  v39 = this;
  v41 = 0;
  if ( ParseCommand((const char **)&a2, "BEGIN_INTERNET_QUERY") )
  {
    *(_BYTE *)(v3 + 32) = 0;
LABEL_3:
    *(_BYTE *)(v3 + 33) = 1;
    GameSpyMgr::BeginServerQuery(v3);
LABEL_4:
    FOutputDevice::Log(a3, off_10011018[*(_DWORD *)(v3 + 12)]);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "BEGIN_LAN_QUERY") )
  {
    *(_BYTE *)(v3 + 32) = 1;
    goto LABEL_3;
  }
  if ( ParseCommand((const char **)&a2, "GET_QUERY_STATUS") )
    goto LABEL_4;
  if ( ParseCommand((const char **)&a2, "GET_QUERY_COUNT") )
  {
    v5 = GameSpyMgr::GetServerQueryNumResults(v3);
    FOutputDevice::Logf(a3, "%d", v5);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "GET_QUERY_RESULTS") )
  {
    v6 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 1;
    v7 = (const char *)FString::operator_(v6);
    v8 = appAtoi(v7);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v9 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 2;
    v10 = (const char *)FString::operator_(v9);
    v11 = appAtoi(v10);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v12 = GameSpyMgr::GetServerQueryResult(v39, (int)&v38, v8, v11);
    LOBYTE(v41) = 3;
    v36 = FString::operator_(v12);
    v35 = a3;
LABEL_25:
    FOutputDevice::Logf(v35, (const char *)v36);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "SORT_QUERY_RESULTS") )
  {
    v13 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 4;
    a3 = FString::MakeCharArray(v13);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v14 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 5;
    v15 = (const char *)FString::operator_(v14);
    v16 = appAtoi(v15);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v17 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 6;
    v18 = (const char *)FString::operator_(v17);
    v19 = appAtoi(v18);
    LOBYTE(v41) = 0;
    v20 = v19 == 0;
    FString::_FString(&v38);
    v21 = *((_DWORD *)v39 + 2);
    if ( v21 )
      sub_10003630(v21, v20, a3, v16);
    (*(void (__stdcall **)(int))(*(_DWORD *)GMalloc + 12))(a3);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "CLEAR_QUERY_RESULTS") )
  {
    GameSpyMgr::ClearServerQueryResults(v3);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "CANCEL_QUERY") )
  {
    GameSpyMgr::CancelServerQuery(v3);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "GET_EXT_PLAYER_QUERY_RESULTS") )
  {
    v22 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 7;
    v23 = (const char *)FString::operator_(v22);
    v24 = appAtoi(v23);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v25 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 8;
    v26 = (const char *)FString::operator_(v25);
    v27 = appAtoi(v26);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v28 = GameSpyMgr::GetExtPlayerQueryResult(v39, (int)&v38, v24, v27);
    LOBYTE(v41) = 9;
    v36 = FString::operator_(v28);
    v35 = a3;
    goto LABEL_25;
  }
  if ( ParseCommand((const char **)&a2, "GET_EXT_SERVER_QUERY_RESULTS") )
  {
    v29 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 10;
    v30 = (const char *)FString::operator_(v29);
    v31 = appAtoi(v30);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    v32 = GameSpyMgr::GetExtServerQueryResult((void *)v3, (int)&v38, v31);
    LOBYTE(v41) = 11;
    v36 = FString::operator_(v32);
    v35 = a3;
    goto LABEL_25;
  }
  if ( ParseCommand((const char **)&a2, "SET_QUERY_FILTER_STRING") )
  {
    FString::operator_(v3 + 24, a2);
    return 1;
  }
  if ( ParseCommand((const char **)&a2, "CHECK_CDKEY") )
  {
    v33 = ParseToken(&v38, &a2, 0);
    LOBYTE(v41) = 12;
    v34 = (const char *)FString::operator_(v33);
    appAtoi(v34);
    LOBYTE(v41) = 0;
    FString::_FString(&v38);
    return 1;
  }
  return ParseCommand((const char **)&a2, "GET_CDKEY_RESULT") != 0;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E03C: using guessed type int __thiscall FString__MakeCharArray(_DWORD);
// 1000E040: using guessed type int __thiscall FOutputDevice__Log(_DWORD, _DWORD);
// 1000E044: using guessed type int __thiscall FString__operator_(_DWORD, _DWORD);
// 1000E054: using guessed type int __thiscall FString__operator_(_DWORD);
// 1000E058: using guessed type int __cdecl appAtoi(const char *);
// 1000E05C: using guessed type int __cdecl ParseToken(_DWORD, _DWORD, _DWORD);
// 1000E060: using guessed type int __cdecl ParseCommand(const char **, const char *);
// 1000E064: using guessed type void *GMalloc;
// 10011018: using guessed type char *off_10011018[8];

//----- (10002787) --------------------------------------------------------
void __usercall sub_10002787(int a1<ebp>)
{
  *(_DWORD *)(a1 - 24) = *(_DWORD *)(a1 - 28);
  CxxThrowException(a1 - 24, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (1000279B) --------------------------------------------------------
void __cdecl sub_1000279B()
{
  appUnwindf("%s", off_10011080[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011080: using guessed type char *off_10011080[6];

//----- (100027C0) --------------------------------------------------------
int __cdecl GameSpyMgr::serverkey_callback(int a1, int a2, int a3)
{
  void *v3; // ecx@1
  int v4; // esi@1
  bool v5; // zf@1
  int result; // eax@2
  int v7; // eax@8
  int v8; // edx@8
  int v9; // eax@10
  int v10; // eax@14
  int v11; // ecx@14
  int v12; // edx@14
  int v13; // ecx@16
  int v14; // eax@21
  int v15; // eax@27
  int v16; // eax@30
  int v17; // eax@31
  int v18; // [sp-8h] [bp-2Ch]@15
  int v19; // [sp-4h] [bp-28h]@15
  int v20; // [sp+0h] [bp-24h]@1
  int *v21; // [sp+14h] [bp-10h]@1
  int v22; // [sp+20h] [bp-4h]@1

  v3 = UGameEngine::PrivateStaticClass;
  v4 = *(_DWORD *)a3;
  v5 = *(_DWORD *)a3 == 0;
  v21 = &v20;
  v22 = 0;
  if ( v5 )
    goto LABEL_9;
  for ( result = *(_DWORD *)(v4 + 36); result; result = *(_DWORD *)(result + 48) )
  {
    if ( (void *)result == UGameEngine::PrivateStaticClass )
      goto LABEL_13;
  }
  result = UGameEngine::PrivateStaticClass == 0;
  if ( UGameEngine::PrivateStaticClass )
  {
    if ( v4 )
    {
      v7 = UObject::GetFullName(v4, UGameEngine::PrivateStaticClass == 0);
      v3 = UGameEngine::PrivateStaticClass;
      v8 = v7;
LABEL_10:
      v9 = *((_DWORD *)v3 + 8);
      if ( !v9 )
        v9 = *(_DWORD *)FName::Names;
      result = FOutputDevice::Logf(GError, "Cast of %s to %s failed", v8, v9 + 12);
      goto LABEL_13;
    }
LABEL_9:
    v8 = (int)"NULL";
    goto LABEL_10;
  }
LABEL_13:
  if ( v4 )
  {
    v10 = ULevel::GetLevelInfo(*(_DWORD *)(v4 + 280));
    v11 = *(_DWORD *)(v10 + 1132);
    v12 = a1 - 1;
    switch ( a1 )
    {
      case 1:
        v19 = FString::operator_(*(_DWORD *)(v11 + 900) + 736);
        v18 = a2;
        goto LABEL_19;
      case 3:
        v13 = v10 + 1100;
        goto LABEL_17;
      case 4:
        v14 = AGameInfo::GetServerPort(v11, v12);
        return sub_10008250(a2, v14);
      case 5:
        v19 = FString::operator_(v10 + 832);
        v18 = a2;
        goto LABEL_19;
      case 6:
        v13 = v11 + 952;
LABEL_17:
        v19 = FString::operator_(v13);
        goto LABEL_18;
      case 8:
        return sub_10008250(a2, *(_DWORD *)(v11 + 776));
      case 10:
        return sub_10008250(a2, *(_DWORD *)(v11 + 772));
      case 11:
        v19 = (int)"openplaying";
        v18 = a2;
        goto LABEL_19;
      case 9:
        v15 = AGameReplicationInfo::GetNumberofTeams(*(_DWORD *)(v11 + 900), v12);
        result = sub_10008250(a2, v15);
        break;
      case 13:
        result = sub_10008250(a2, *(_DWORD *)(*(_DWORD *)(v11 + 900) + 680));
        break;
      case 16:
        result = sub_10008250(a2, *(_DWORD *)(*(_DWORD *)(v11 + 900) + 684));
        break;
      case 50:
        v16 = (*(int (**)(void))(**(_DWORD **)(v4 + 280) + 172))();
        result = sub_10008250(a2, v16 != 0);
        break;
      case 51:
        v17 = AGameInfo::GetFriendlyFirePercent(v11, v12);
        result = sub_10008250(a2, v17);
        break;
      default:
        v19 = (int)&unk_1000E7EB;
LABEL_18:
        v18 = a2;
LABEL_19:
        result = sub_10006CE0(v18, (const char *)v19);
        break;
    }
  }
  return result;
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E048: using guessed type void *GError;
// 1000E04C: using guessed type void *FName__Names;
// 1000E050: using guessed type int __thiscall UObject__GetFullName(_DWORD, _DWORD);
// 1000E054: using guessed type int __thiscall FString__operator_(_DWORD);
// 1000E07C: using guessed type void *UGameEngine__PrivateStaticClass;
// 1000E088: using guessed type int __fastcall AGameInfo__GetFriendlyFirePercent(_DWORD, _DWORD);
// 1000E08C: using guessed type int __fastcall AGameReplicationInfo__GetNumberofTeams(_DWORD, _DWORD);
// 1000E090: using guessed type int __fastcall AGameInfo__GetServerPort(_DWORD, _DWORD);
// 1000E094: using guessed type int __thiscall ULevel__GetLevelInfo(_DWORD);

//----- (10002A49) --------------------------------------------------------
void __usercall sub_10002A49(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10002A5D) --------------------------------------------------------
void __cdecl sub_10002A5D()
{
  appUnwindf("%s", off_10011084[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011084: using guessed type char *off_10011084[5];

//----- (10002AF0) --------------------------------------------------------
int __cdecl GameSpyMgr::playerkey_callback(int a1, int a2, int a3, int a4)
{
  void *v4; // ecx@1
  int v5; // esi@1
  bool v6; // zf@1
  int result; // eax@2
  int v8; // eax@8
  int v9; // edx@8
  int v10; // eax@10
  int v11; // eax@14
  int v12; // eax@15
  int v13; // eax@23
  int v14; // [sp-8h] [bp-2Ch]@17
  const char *v15; // [sp-4h] [bp-28h]@17
  int v16; // [sp+0h] [bp-24h]@1
  int *v17; // [sp+14h] [bp-10h]@1
  int v18; // [sp+20h] [bp-4h]@1

  v4 = UGameEngine::PrivateStaticClass;
  v5 = *(_DWORD *)a4;
  v6 = *(_DWORD *)a4 == 0;
  v17 = &v16;
  v18 = 0;
  if ( v6 )
    goto LABEL_9;
  for ( result = *(_DWORD *)(v5 + 36); result; result = *(_DWORD *)(result + 48) )
  {
    if ( (void *)result == UGameEngine::PrivateStaticClass )
      goto LABEL_13;
  }
  result = UGameEngine::PrivateStaticClass == 0;
  if ( UGameEngine::PrivateStaticClass )
  {
    if ( v5 )
    {
      v8 = UObject::GetFullName(v5, UGameEngine::PrivateStaticClass == 0);
      v4 = UGameEngine::PrivateStaticClass;
      v9 = v8;
LABEL_10:
      v10 = *((_DWORD *)v4 + 8);
      if ( !v10 )
        v10 = *(_DWORD *)FName::Names;
      result = FOutputDevice::Logf(GError, "Cast of %s to %s failed", v9, v10 + 12);
      goto LABEL_13;
    }
LABEL_9:
    v9 = (int)"NULL";
    goto LABEL_10;
  }
LABEL_13:
  if ( v5 )
  {
    v11 = ULevel::GetLevelInfo(*(_DWORD *)(v5 + 280));
    if ( a2 < *(_DWORD *)(*(_DWORD *)(v11 + 1132) + 776) )
    {
      v12 = sub_10001910(a2, v11);
      if ( v12 )
      {
        switch ( a1 )
        {
          case 21:
            v15 = (const char *)FString::operator_(*(_DWORD *)(v12 + 768) + 664);
            v14 = a3;
            goto LABEL_18;
          case 22:
            return sub_10008250(a3, *(_DWORD *)(*(_DWORD *)(v12 + 768) + 756));
          case 26:
            return sub_10008250(a3, (signed int)ffloor(*(float *)(*(_DWORD *)(v12 + 768) + 648)));
          case 24:
            return sub_10008250(a3, *(_BYTE *)(*(_DWORD *)(v12 + 768) + 760));
          case 25:
            v13 = *(_DWORD *)(*(_DWORD *)(v12 + 768) + 708);
            if ( v13 )
              result = sub_10008250(a3, *(_DWORD *)(v13 + 664));
            else
              result = sub_10008250(a3, 0);
            return result;
          default:
            break;
        }
      }
    }
    v15 = (const char *)&unk_1000E7EB;
    v14 = a3;
LABEL_18:
    result = sub_10006CE0(v14, v15);
  }
  return result;
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E048: using guessed type void *GError;
// 1000E04C: using guessed type void *FName__Names;
// 1000E050: using guessed type int __thiscall UObject__GetFullName(_DWORD, _DWORD);
// 1000E054: using guessed type int __thiscall FString__operator_(_DWORD);
// 1000E07C: using guessed type void *UGameEngine__PrivateStaticClass;
// 1000E094: using guessed type int __thiscall ULevel__GetLevelInfo(_DWORD);

//----- (10002CF0) --------------------------------------------------------
void __usercall sub_10002CF0(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10002D04) --------------------------------------------------------
void __cdecl sub_10002D04()
{
  appUnwindf("%s", off_10011088[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011088: using guessed type char *off_10011088[4];

//----- (10002D40) --------------------------------------------------------
int __cdecl GameSpyMgr::count_callback(int a1, int a2)
{
  void *v2; // ecx@1
  int v3; // esi@1
  bool v4; // zf@1
  int i; // eax@2
  int v6; // eax@8
  int v7; // edx@8
  int v8; // eax@10
  int v9; // eax@14
  int v10; // edx@14
  int result; // eax@15
  int v12; // [sp+0h] [bp-24h]@1
  int *v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+20h] [bp-4h]@1

  v2 = UGameEngine::PrivateStaticClass;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)a2 == 0;
  v13 = &v12;
  v14 = 0;
  if ( v4 )
    goto LABEL_21;
  for ( i = *(_DWORD *)(v3 + 36); i; i = *(_DWORD *)(i + 48) )
  {
    if ( (void *)i == UGameEngine::PrivateStaticClass )
      goto LABEL_13;
  }
  if ( !UGameEngine::PrivateStaticClass )
    goto LABEL_13;
  if ( !v3 )
  {
LABEL_21:
    v7 = (int)"NULL";
  }
  else
  {
    v6 = UObject::GetFullName(v3, UGameEngine::PrivateStaticClass == 0);
    v2 = UGameEngine::PrivateStaticClass;
    v7 = v6;
  }
  v8 = *((_DWORD *)v2 + 8);
  if ( !v8 )
    v8 = *(_DWORD *)FName::Names;
  FOutputDevice::Logf(GError, "Cast of %s to %s failed", v7, v8 + 12);
  if ( !v3 )
    goto LABEL_22;
LABEL_13:
  v9 = *(_DWORD *)(ULevel::GetLevelInfo(*(_DWORD *)(v3 + 280)) + 1132);
  if ( a1 == 1 )
    return *(_DWORD *)(v9 + 776);
  if ( a1 == 2 )
    result = AGameReplicationInfo::GetNumberofTeams(*(_DWORD *)(v9 + 900), v10);
  else
LABEL_22:
    result = 0;
  return result;
}
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E048: using guessed type void *GError;
// 1000E04C: using guessed type void *FName__Names;
// 1000E050: using guessed type int __thiscall UObject__GetFullName(_DWORD, _DWORD);
// 1000E07C: using guessed type void *UGameEngine__PrivateStaticClass;
// 1000E08C: using guessed type int __fastcall AGameReplicationInfo__GetNumberofTeams(_DWORD, _DWORD);
// 1000E094: using guessed type int __thiscall ULevel__GetLevelInfo(_DWORD);

//----- (10002E4B) --------------------------------------------------------
void __usercall sub_10002E4B(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (10002E5F) --------------------------------------------------------
void __cdecl sub_10002E5F()
{
  appUnwindf("%s", off_1001108C[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 1001108C: using guessed type char *off_1001108C[3];

//----- (10002E80) --------------------------------------------------------
char __thiscall GameSpyMgr::RegisterGame(void *this, int a2)
{
  int v2; // esi@1
  int v3; // edi@2
  void *v4; // ecx@2
  int i; // eax@3
  int v6; // eax@9
  int v7; // edx@9
  int v8; // eax@11
  char v9; // al@15
  int v11; // [sp+0h] [bp-24h]@1
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@1

  v12 = &v11;
  v2 = (int)this;
  v13 = 0;
  if ( !GameSpyMgr::IsBackEndAvailable() )
    return 0;
  v3 = *(_DWORD *)v2;
  v4 = UGameEngine::PrivateStaticClass;
  if ( !*(_DWORD *)v2 )
    goto LABEL_10;
  for ( i = *(_DWORD *)(v3 + 36); i; i = *(_DWORD *)(i + 48) )
  {
    if ( (void *)i == UGameEngine::PrivateStaticClass )
      goto LABEL_14;
  }
  if ( UGameEngine::PrivateStaticClass )
  {
    if ( v3 )
    {
      v6 = UObject::GetFullName(v3, UGameEngine::PrivateStaticClass == 0);
      v4 = UGameEngine::PrivateStaticClass;
      v7 = v6;
LABEL_11:
      v8 = *((_DWORD *)v4 + 8);
      if ( !v8 )
        v8 = *(_DWORD *)FName::Names;
      FOutputDevice::Logf(GError, "Cast of %s to %s failed", v7, v8 + 12);
      goto LABEL_14;
    }
LABEL_10:
    v7 = (int)"NULL";
    goto LABEL_11;
  }
LABEL_14:
  if ( !*(_DWORD *)v2 || (v9 = *(_BYTE *)(ULevel::GetLevelInfo(*(_DWORD *)(v3 + 280)) + 1088), v9 != 1) && v9 != 2 )
    return 0;
  if ( !*(_BYTE *)(v2 + 4) )
  {
    GameSpyMgr::RegisterCustomKeys();
    if ( sub_10008070(
           a2 - 1,
           0,
           0,
           11138,
           off_10011014,
           v2 + 16,
           a2 - 1,
           0,
           (int)GameSpyMgr::serverkey_callback,
           (int)GameSpyMgr::playerkey_callback,
           (int)GameSpyMgr::teamkey_callback,
           (int)GameSpyMgr::keylist_callback,
           (int)GameSpyMgr::count_callback,
           (int)GameSpyMgr::adderror_callback,
           v2) )
      return 0;
    sub_10006C50(0, (int)GameSpyMgr::cm_callback);
    sub_10006C20(0, (int)GameSpyMgr::nn_callback);
    *(_BYTE *)(v2 + 4) = 1;
    if ( sub_10006870(0, 987) )
    {
      FOutputDevice::Logf(GLog, "Error trying to initialize CD Key Auth");
      return 0;
    }
    *(_BYTE *)(v2 + 40) = 1;
  }
  return 1;
}
// 10001980: using guessed type int GameSpyMgr__teamkey_callback();
// 10001B00: using guessed type int GameSpyMgr__nn_callback();
// 10001B10: using guessed type int GameSpyMgr__cm_callback();
// 1000E034: using guessed type int FOutputDevice__Logf(_DWORD, const char *, ...);
// 1000E038: using guessed type void *GLog;
// 1000E048: using guessed type void *GError;
// 1000E04C: using guessed type void *FName__Names;
// 1000E050: using guessed type int __thiscall UObject__GetFullName(_DWORD, _DWORD);
// 1000E07C: using guessed type void *UGameEngine__PrivateStaticClass;
// 1000E094: using guessed type int __thiscall ULevel__GetLevelInfo(_DWORD);

//----- (10003017) --------------------------------------------------------
void __usercall sub_10003017(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 24);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (1000302B) --------------------------------------------------------
void __cdecl sub_1000302B()
{
  appUnwindf("%s", off_10011090[0]);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011090: using guessed type char *off_10011090[2];

//----- (10003050) --------------------------------------------------------
int __thiscall GameSpyMgr::_GameSpyMgr(int this)
{
  int v1; // esi@1
  int v3; // [sp+0h] [bp-28h]@1
  int v4; // [sp+10h] [bp-18h]@1
  int *v5; // [sp+18h] [bp-10h]@1
  int v6; // [sp+24h] [bp-4h]@1

  v1 = this;
  v5 = &v3;
  v4 = this;
  v6 = 0;
  LOBYTE(v6) = 1;
  GameSpyMgr::UnRegisterGame(this);
  GameSpyMgr::DeleteServerBrowser(v1);
  v6 = -1;
  return FString::_FString(v1 + 24);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (100030AE) --------------------------------------------------------
void __usercall sub_100030AE(int a1<ebp>)
{
  *(_DWORD *)(a1 - 20) = *(_DWORD *)(a1 - 28);
  CxxThrowException(a1 - 20, &unk_1000EE44);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);

//----- (100030C2) --------------------------------------------------------
void __cdecl sub_100030C2()
{
  appUnwindf("%s", off_10011094);
  CxxThrowException(0, 0);
}
// 1000D5A0: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 1000E024: using guessed type void appUnwindf(const char *, ...);
// 10011094: using guessed type char *off_10011094;

//----- (10003310) --------------------------------------------------------
int __cdecl sub_10003310(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@2
  int v9; // esi@3

  if ( dword_10011FE0 == 1 )
  {
    result = (int)malloc(0x62Cu);
    v9 = result;
    if ( result )
    {
      *(_DWORD *)(result + 1572) = a7;
      *(_DWORD *)(result + 1576) = a8;
      *(_DWORD *)(result + 1560) = 0;
      sub_1000B1C0(result + 72, a1, a2, a3, a4, (int)sub_10003100, result);
      sub_10008DD0(v9, a5, a6, (int)sub_100032A0, v9);
      result = v9;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10003100: using guessed type int sub_10003100();
// 100032A0: using guessed type int sub_100032A0();
// 10011FE0: using guessed type int dword_10011FE0;

//----- (100033A0) --------------------------------------------------------
void __cdecl sub_100033A0(char *Memory)
{
  sub_1000A3B0((int)(Memory + 72));
  sub_10008E60((int)Memory);
  free(Memory);
}

//----- (100034A0) --------------------------------------------------------
signed int __cdecl sub_100034A0(int a1)
{
  sub_10009270(a1);
  return sub_1000B8A0(a1 + 72);
}

//----- (100034C0) --------------------------------------------------------
int __cdecl sub_100034C0(int a1)
{
  sub_1000A350(a1 + 72);
  return sub_10008E40(a1);
}

//----- (100034E0) --------------------------------------------------------
int __cdecl sub_100034E0(int a1)
{
  sub_1000A350(a1 + 72);
  sub_10008E40(a1);
  return sub_10009DE0(a1 + 72);
}

//----- (100035B0) --------------------------------------------------------
int __cdecl sub_100035B0(int a1)
{
  return *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 28);
}

//----- (100035C0) --------------------------------------------------------
int __cdecl sub_100035C0(int a1, int a2)
{
  return sub_10009D80(a1 + 72, a2);
}

//----- (10003620) --------------------------------------------------------
int __cdecl sub_10003620(int a1)
{
  return sub_100093A0(*(_DWORD *)(a1 + 76));
}

//----- (10003630) --------------------------------------------------------
void __cdecl sub_10003630(int a1, int a2, int a3, int a4)
{
  int (__cdecl *v4)(int *, int *); // ecx@2
  int v5; // [sp+4h] [bp+4h]@1

  v5 = a1 + 72;
  switch ( a4 )
  {
    case 0:
      v4 = PtFuncCompare;
      break;
    case 1:
      v4 = sub_100099C0;
      break;
    case 2:
      v4 = (int (__cdecl *)(int *, int *))sub_10009A70;
      break;
    default:
      v4 = (int (__cdecl *)(int *, int *))sub_10009B00;
      break;
  }
  *(_DWORD *)(v5 + 1168) = a3;
  *(_DWORD *)(v5 + 1172) = a2;
  dword_10011F54 = v5;
  sub_10009400(*(_DWORD *)(v5 + 4), (int (__cdecl *)(const void *, const void *))v4);
}
// 10009A70: using guessed type int sub_10009A70();
// 10009B00: using guessed type int sub_10009B00();
// 10011F54: using guessed type int dword_10011F54;

//----- (10003660) --------------------------------------------------------
int __cdecl sub_10003660(int a1)
{
  return *(_DWORD *)(a1 + 1248);
}

//----- (10003690) --------------------------------------------------------
signed int __cdecl sub_10003690(int a1, int a2, int a3, int a4, int a5, const char *a6, u_long hostlong, int a8)
{
  int v8; // esi@1
  int v9; // edi@1
  int v10; // eax@2
  char v11; // dl@3
  signed int result; // eax@6
  int v13; // [sp+Ch] [bp-104h]@2
  char Dest; // [sp+10h] [bp-100h]@1
  char v15; // [sp+11h] [bp-FFh]@1
  __int16 v16; // [sp+10Dh] [bp-3h]@1
  char v17; // [sp+10Fh] [bp-1h]@1

  Dest = 0;
  memset(&v15, 0, 0xFCu);
  v16 = 0;
  v17 = 0;
  v8 = 0;
  *(_DWORD *)(a1 + 1556) = a3;
  v9 = 0;
  *(_DWORD *)(a1 + 60) = 0;
  while ( v8 < a5 )
  {
    v10 = (int)*(&off_100110A0 + *(_BYTE *)(v8 + a4));
    v13 = v10 + 1;
    do
      v11 = *(_BYTE *)v10++;
    while ( v11 );
    if ( v10 - v13 + v9 + 1 >= 256 )
      break;
    v9 += sprintf(&Dest + v9, "\\%s", *(&off_100110A0 + *(_BYTE *)(v8 + a4)));
    sub_100092B0(a1, *(_BYTE *)(v8++ + a4));
  }
  result = sub_1000B350(a1 + 72, &Dest, a6, hostlong, a8);
  if ( !result && !a2 )
  {
    while ( *(_DWORD *)(a1 + 72) == 3 || *(_DWORD *)(a1 + 16) > 0 && !result )
    {
      sub_10004730(0xAu);
      sub_10009270(a1);
      result = sub_1000B8A0(a1 + 72);
    }
  }
  return result;
}
// 100110A0: using guessed type void *off_100110A0;

//----- (10003790) --------------------------------------------------------
signed int __cdecl sub_10003790(int a1, int a2, int a3, int a4, int a5, const char *a6)
{
  return sub_10003690(a1, a2, a3, a4, a5, a6, 0, 0);
}

//----- (10003800) --------------------------------------------------------
signed int __cdecl sub_10003800(int a1, int a2, u_short hostshort, unsigned __int16 a4)
{
  int v4; // edi@1
  signed int v5; // ebx@1

  v4 = a1 + 72;
  v5 = 0;
  sub_1000A350(a1 + 72);
  sub_10008E40(a1);
  sub_1000B540(a1 + 72, hostshort, a4, *(_DWORD *)a1);
  if ( !a2 )
  {
    while ( !*(_DWORD *)v4 || *(_DWORD *)(a1 + 16) > 0 && !v5 )
    {
      sub_10004730(0xAu);
      sub_10009270(a1);
      v5 = sub_1000B8A0(v4);
    }
  }
  return v5;
}

//----- (10003870) --------------------------------------------------------
signed int __usercall sub_10003870<eax>(int a1<ebx>, int a2<edi>)
{
  signed int result; // eax@1

  result = 0;
  while ( *(_DWORD *)(a2 + 1564) )
  {
    if ( result )
      break;
    sub_10004730(0xAu);
    sub_10009270(a2);
    result = sub_1000B8A0(a2 + 72);
    if ( a1 )
    {
      if ( !*(_DWORD *)(a2 + 72) )
        break;
    }
  }
  return result;
}

//----- (100039C0) --------------------------------------------------------
signed int __cdecl sub_100039C0(int a1, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  int v5; // eax@2
  signed int result; // eax@6

  *(_DWORD *)(a1 + 1560) = 1;
  v4 = 0;
  if ( *(_BYTE *)(a2 + 21) & 1 )
  {
    sub_100092D0(a1, a2);
    sub_10008E90(a1, a2, 1, a4 != 0);
    v5 = 0;
  }
  else
  {
    v4 = sub_1000B990(a1 + 72, *(_DWORD *)a2, *(_WORD *)(a2 + 4));
    v5 = 1;
  }
  if ( a3 || v4 )
  {
    *(_DWORD *)(a1 + 1560) = 0;
    result = v4;
  }
  else
  {
    *(_DWORD *)(a1 + 1564) = *(_DWORD *)a2;
    *(_WORD *)(a1 + 1568) = *(_WORD *)(a2 + 4);
    result = sub_10003870(v5, a1);
    *(_DWORD *)(a1 + 1560) = 0;
  }
  return result;
}

//----- (10003AA0) --------------------------------------------------------
void __cdecl sub_10003AA0()
{
  if ( dword_10011644 )
  {
    if ( !sub_1000BCF0((int)dword_10011644) )
    {
      sub_1000BCB0(dword_10011644);
      dword_10011644 = 0;
    }
  }
}

//----- (10003AD0) --------------------------------------------------------
void __cdecl sub_10003AD0(int a1)
{
  int v1; // esi@1

  v1 = *(_DWORD *)a1;
  sub_1000BCB0(*(void **)(*(_DWORD *)a1 + 24));
  *(_DWORD *)(v1 + 24) = 0;
  free((void *)v1);
}

//----- (10003B00) --------------------------------------------------------
void __cdecl sub_10003B00(int a1, const char *a2, const char *a3)
{
  void *v3; // [sp+0h] [bp-8h]@1
  void *v4; // [sp+4h] [bp-4h]@1

  v3 = sub_10009EA0(0, a2);
  v4 = sub_10009EA0(0, a3);
  sub_1000BD30(*(_DWORD *)(a1 + 24), (int)&v3);
}

//----- (10003B40) --------------------------------------------------------
void __cdecl sub_10003B40(int a1, const char *a2, int a3)
{
  void *v3; // [sp+0h] [bp-1Ch]@1
  void *v4; // [sp+4h] [bp-18h]@1
  char Dest; // [sp+8h] [bp-14h]@1

  sprintf(&Dest, "%d", a3);
  v3 = sub_10009EA0(0, a2);
  v4 = sub_10009EA0(0, &Dest);
  sub_1000BD30(*(_DWORD *)(a1 + 24), (int)&v3);
}

//----- (10003B90) --------------------------------------------------------
int __cdecl sub_10003B90(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))a2)(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a2 + 4));
}

//----- (10003BE0) --------------------------------------------------------
int __cdecl sub_10003BE0(int a1, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@2
  int v5; // [sp+0h] [bp-8h]@1

  v5 = a2;
  v3 = sub_1000BDF0(*(_DWORD *)(a1 + 24), (int)&v5);
  if ( v3 )
    result = *(_DWORD *)(v3 + 4);
  else
    result = a3;
  return result;
}

//----- (10003C20) --------------------------------------------------------
double __cdecl sub_10003C20(int a1, int a2, double a3)
{
  int v3; // eax@1
  const char *v4; // eax@2
  double result; // st7@3
  int v6; // [sp+0h] [bp-8h]@1

  v6 = a2;
  v3 = sub_1000BDF0(*(_DWORD *)(a1 + 24), (int)&v6);
  if ( v3 && (v4 = *(const char **)(v3 + 4)) != 0 )
    result = atof(v4);
  else
    result = a3;
  return result;
}

//----- (10003CC0) --------------------------------------------------------
int __cdecl sub_10003CC0(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int result; // eax@2
  char *v6; // [sp+0h] [bp-88h]@1
  char Dest; // [sp+8h] [bp-80h]@1

  sprintf(&Dest, "%s_%d", a3, a2);
  v6 = &Dest;
  v4 = sub_1000BDF0(*(_DWORD *)(a1 + 24), (int)&v6);
  if ( v4 )
    result = *(_DWORD *)(v4 + 4);
  else
    result = a4;
  return result;
}

//----- (10003E80) --------------------------------------------------------
bool __cdecl sub_10003E80(int a1)
{
  return (*(_BYTE *)(a1 + 20) & 1) == 1;
}

//----- (10003EA0) --------------------------------------------------------
bool __cdecl sub_10003EA0(int a1)
{
  return (*(_BYTE *)(a1 + 20) & 2) == 2;
}

//----- (10003EC0) --------------------------------------------------------
char *__cdecl sub_10003EC0(struct in_addr *a1)
{
  return inet_ntoa(*a1);
}

//----- (10003ED0) --------------------------------------------------------
int __cdecl sub_10003ED0(int a1)
{
  return *(_DWORD *)a1;
}

//----- (10003F00) --------------------------------------------------------
__int16 __cdecl sub_10003F00(int a1)
{
  return *(_WORD *)(a1 + 4);
}

//----- (10003F10) --------------------------------------------------------
bool __cdecl sub_10003F10(int a1)
{
  return (*(_BYTE *)(a1 + 21) & 2) == 2;
}

//----- (10003F50) --------------------------------------------------------
char *__cdecl sub_10003F50(int a1)
{
  return inet_ntoa(*(struct in_addr *)(a1 + 8));
}

//----- (10003F90) --------------------------------------------------------
int __cdecl sub_10003F90(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 32) = a2;
  return result;
}

//----- (10003FA0) --------------------------------------------------------
int __cdecl sub_10003FA0(int a1)
{
  return *(_DWORD *)(a1 + 32);
}

//----- (10003FB0) --------------------------------------------------------
signed int __cdecl sub_10003FB0(const char *a1)
{
  unsigned int v1; // edi@1
  int v3; // [sp+10h] [bp-8h]@1
  int v4; // [sp+14h] [bp-4h]@1

  v3 = (int)"queryid";
  v4 = (int)"final";
  v1 = 0;
  while ( strcmp(a1, (const char *)*(&v3 + v1)) )
  {
    ++v1;
    if ( v1 >= 2 )
      return 1;
  }
  return 0;
}

//----- (10004030) --------------------------------------------------------
int __fastcall sub_10004030(int a1, char a2)
{
  int result; // eax@4
  char v3; // bl@6

  if ( a1 )
    dword_10011640 = a1;
  else
    a1 = dword_10011640;
  result = a1;
  if ( !*(_BYTE *)a1 )
    goto LABEL_13;
  do
  {
    if ( *(_BYTE *)a1 == a2 )
      break;
    v3 = *(_BYTE *)(a1++ + 1);
  }
  while ( v3 );
  dword_10011640 = a1;
  if ( a1 == result )
LABEL_13:
    result = 0;
  if ( *(_BYTE *)a1 )
  {
    *(_BYTE *)a1 = 0;
    dword_10011640 = a1 + 1;
  }
  return result;
}
// 10011640: using guessed type int dword_10011640;

//----- (10004080) --------------------------------------------------------
int __cdecl sub_10004080(int a1, int a2)
{
  int result; // eax@1
  const char *v3; // ebx@1
  int v4; // esi@2
  const char *v5; // edi@3
  char v6; // al@5
  void *v7; // eax@13
  int v8; // ecx@13
  char v9; // cl@16
  void *v10; // [sp+4h] [bp-8h]@13
  void *v11; // [sp+8h] [bp-4h]@13

  result = sub_10004030(a2 + 1, 92);
  v3 = (const char *)result;
  if ( result )
  {
    v4 = dword_10011640;
    do
    {
      v5 = (const char *)v4;
      if ( !*(_BYTE *)v4 )
        goto LABEL_24;
      do
      {
        if ( *(_BYTE *)v4 == 92 )
          break;
        v6 = *(_BYTE *)(v4++ + 1);
      }
      while ( v6 );
      dword_10011640 = v4;
      if ( (const char *)v4 == v5 )
LABEL_24:
        v5 = 0;
      if ( *(_BYTE *)v4 )
      {
        *(_BYTE *)v4++ = 0;
        dword_10011640 = v4;
      }
      if ( !v5 )
        v5 = (const char *)&unk_1000E7EB;
      if ( sub_10003FB0(v3) )
      {
        v10 = sub_10009EA0(0, v3);
        v7 = sub_10009EA0(0, v5);
        v8 = *(_DWORD *)(a1 + 24);
        v11 = v7;
        sub_1000BD30(v8, (int)&v10);
        v4 = dword_10011640;
      }
      result = v4;
      if ( !*(_BYTE *)v4 )
        goto LABEL_25;
      do
      {
        if ( *(_BYTE *)v4 == 92 )
          break;
        v9 = *(_BYTE *)(v4++ + 1);
      }
      while ( v9 );
      dword_10011640 = v4;
      if ( v4 == result )
LABEL_25:
        result = 0;
      if ( *(_BYTE *)v4 )
      {
        *(_BYTE *)v4++ = 0;
        dword_10011640 = v4;
      }
      v3 = (const char *)result;
    }
    while ( result );
  }
  return result;
}
// 10011640: using guessed type int dword_10011640;

//----- (10004160) --------------------------------------------------------
void __cdecl sub_10004160(int a1, int a2, signed int a3)
{
  int v3; // esi@1
  signed int v4; // eax@2
  int v5; // ebx@3
  int v6; // esi@3
  signed int v7; // eax@3
  int v8; // ebx@4
  const char *v9; // edi@4
  int v10; // esi@7
  signed int v11; // ebx@7
  u_short v12; // ax@9
  int v13; // esi@9
  signed int v14; // ebx@9
  u_short v15; // di@9
  signed int v16; // eax@10
  void *v17; // eax@13
  const char *v18; // edi@14
  signed int v19; // ebx@15
  bool v20; // sf@19
  unsigned __int8 v21; // of@19
  const char *v22; // [sp+Ch] [bp-A4h]@3
  int v23; // [sp+Ch] [bp-A4h]@7
  int v24; // [sp+10h] [bp-A0h]@9
  signed int v25; // [sp+14h] [bp-9Ch]@13
  int v26; // [sp+18h] [bp-98h]@14
  void *v27; // [sp+1Ch] [bp-94h]@4
  void *v28; // [sp+20h] [bp-90h]@4
  int v29; // [sp+24h] [bp-8Ch]@9
  void *v30; // [sp+28h] [bp-88h]@16
  void *v31; // [sp+2Ch] [bp-84h]@16
  char Dest; // [sp+30h] [bp-80h]@16
  signed int v33; // [sp+C0h] [bp+10h]@13

  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    while ( 1 )
    {
      v4 = sub_10009F70(v3, a3);
      if ( v4 < 0 )
        break;
      v5 = a3 - v4;
      v22 = (const char *)v3;
      v6 = v4 + v3;
      v7 = sub_10009F70(v6, a3 - v4);
      if ( v7 < 0 )
        break;
      v8 = v5 - v7;
      v9 = (const char *)v6;
      v3 = v7 + v6;
      a3 = v8;
      v27 = sub_10009EA0(0, v22);
      v28 = sub_10009EA0(0, v9);
      sub_1000BD30(*(_DWORD *)(a1 + 24), (int)&v27);
      if ( !*(_BYTE *)v3 )
        goto LABEL_7;
    }
  }
  else
  {
    v8 = a3;
LABEL_7:
    v10 = v3 + 1;
    v11 = v8 - 1;
    v23 = 0;
    while ( v11 >= 2 )
    {
      v12 = ntohs(*(_WORD *)v10);
      v13 = v10 + 2;
      v14 = v11 - 2;
      v29 = v13;
      v24 = 0;
      v15 = v12;
      if ( *(_BYTE *)v13 )
      {
        while ( 1 )
        {
          v16 = sub_10009F70(v13, v14);
          if ( v16 < 0 )
            break;
          if ( v16 > 100 )
            break;
          v13 += v16;
          v14 -= v16;
          ++v24;
          if ( !*(_BYTE *)v13 )
            goto LABEL_13;
        }
        return;
      }
LABEL_13:
      v17 = (void *)v15;
      v10 = v13 + 1;
      v11 = v14 - 1;
      v33 = v11;
      v25 = 0;
      v27 = (void *)v15;
      if ( (signed int)v15 > 0 )
      {
        while ( 1 )
        {
          v18 = (const char *)v29;
          v26 = 0;
          if ( v24 > 0 )
            break;
LABEL_18:
          ++v25;
          if ( v25 >= (signed int)v17 )
            goto LABEL_19;
        }
        while ( 1 )
        {
          v19 = sub_10009F70(v10, v11);
          if ( v19 < 0 )
            return;
          sprintf(&Dest, "%s%d", v18, v25);
          v30 = sub_10009EA0(0, &Dest);
          v31 = sub_10009EA0(0, (const char *)v10);
          sub_1000BD30(*(_DWORD *)(a1 + 24), (int)&v30);
          v10 += v19;
          v33 -= v19;
          v11 = v33;
          v18 += strlen(v18) + 1;
          ++v26;
          if ( v26 >= v24 )
          {
            v17 = v27;
            goto LABEL_18;
          }
        }
      }
LABEL_19:
      v21 = __OFSUB__(v23 + 1, 2);
      v20 = v23++ - 1 < 0;
      if ( !(v20 ^ v21) )
        return;
    }
  }
}

//----- (10004350) --------------------------------------------------------
int __usercall sub_10004350<eax>(int a1<eax>, unsigned int a2)
{
  int v2; // edi@1
  char v3; // al@1
  unsigned int v4; // esi@1

  v2 = a1;
  v3 = *(_BYTE *)a1;
  v4 = 0;
  if ( v3 )
  {
    do
    {
      ++v2;
      v4 = tolower(v3) - 1664117991 * v4;
      v3 = *(_BYTE *)v2;
    }
    while ( *(_BYTE *)v2 );
  }
  return v4 % a2;
}

//----- (100043F0) --------------------------------------------------------
int __cdecl sub_100043F0(int a1)
{
  return *(_DWORD *)(a1 + 28);
}

//----- (10004400) --------------------------------------------------------
void *__cdecl sub_10004400(int a1, int a2, __int16 a3)
{
  void *v3; // esi@1
  void *v4; // eax@2

  v3 = malloc(0x24u);
  if ( !v3 )
    return 0;
  v4 = sub_1000BC40(8, 8, 4, (int)sub_100043B0, (int)sub_100043D0, (int)sub_10004390);
  *((_DWORD *)v3 + 6) = v4;
  if ( !v4 )
  {
    free(v3);
    return 0;
  }
  *(_DWORD *)v3 = a2;
  *((_BYTE *)v3 + 20) = 0;
  *((_BYTE *)v3 + 21) = 0;
  *((_DWORD *)v3 + 8) = 0;
  *((_DWORD *)v3 + 7) = 0;
  *((_DWORD *)v3 + 4) = 0;
  *((_DWORD *)v3 + 2) = 0;
  *((_WORD *)v3 + 6) = 0;
  *((_WORD *)v3 + 2) = a3;
  return v3;
}
// 10004390: using guessed type int sub_10004390();
// 100043B0: using guessed type int sub_100043B0();
// 100043D0: using guessed type int sub_100043D0();

//----- (10004480) --------------------------------------------------------
char __cdecl sub_10004480(int a1, char a2)
{
  char result; // al@1

  result = a2;
  *(_BYTE *)(a1 + 21) = a2;
  return result;
}

//----- (100044B0) --------------------------------------------------------
int __cdecl sub_100044B0(int a1, int a2, __int16 a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  *(_WORD *)(a1 + 12) = a3;
  return result;
}

//----- (100044D0) --------------------------------------------------------
int __cdecl sub_100044D0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (100044E0) --------------------------------------------------------
char __cdecl sub_100044E0(int a1, char a2)
{
  char result; // al@1

  result = a2;
  *(_BYTE *)(a1 + 20) = a2;
  return result;
}

//----- (100044F0) --------------------------------------------------------
char __cdecl sub_100044F0(int a1)
{
  return *(_BYTE *)(a1 + 20);
}

//----- (10004510) --------------------------------------------------------
bool __cdecl sub_10004510(int a1)
{
  return a1 == dword_10011648;
}
// 10011648: using guessed type int dword_10011648;

//----- (10004550) --------------------------------------------------------
void *__cdecl sub_10004550()
{
  void *result; // eax@1

  result = dword_10011644;
  if ( !dword_10011644 )
  {
    result = sub_1000BC40(8, 500, 4, (int)sub_10004530, (int)sub_10003A70, (int)sub_10003A90);
    dword_10011644 = result;
  }
  return result;
}
// 10003A70: using guessed type int sub_10003A70();
// 10003A90: using guessed type int sub_10003A90();
// 10004530: using guessed type int sub_10004530();

//----- (10004580) --------------------------------------------------------
int __cdecl sub_10004580(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  signed int v5; // ecx@1
  bool v6; // zf@1
  int result; // eax@5
  int v8; // eax@6
  const char *v9; // esi@7
  int v10; // [sp+8h] [bp-8h]@6

  v3 = (int)"ping";
  v4 = a2;
  v5 = 5;
  v6 = 1;
  do
  {
    if ( !v5 )
      break;
    v6 = *(_BYTE *)v4++ == *(_BYTE *)v3++;
    --v5;
  }
  while ( v6 );
  if ( v6 )
  {
    result = *(_DWORD *)(a1 + 28);
  }
  else
  {
    v10 = a2;
    v8 = sub_1000BDF0(*(_DWORD *)(a1 + 24), (int)&v10);
    if ( v8 && (v9 = *(const char **)(v8 + 4)) != 0 && isdigit((unsigned __int8)*v9) )
      result = atoi(v9);
    else
      result = a3;
  }
  return result;
}

//----- (10004600) --------------------------------------------------------
int __cdecl sub_10004600(int a1, int a2, int a3, int a4)
{
  char Dest; // [sp+0h] [bp-80h]@1

  sprintf(&Dest, "%s_%d", a3, a2);
  return sub_10004580(a1, (int)&Dest, a4);
}

//----- (10004730) --------------------------------------------------------
void __cdecl sub_10004730(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (10004740) --------------------------------------------------------
int __cdecl sub_10004740()
{
  char v1; // [sp+0h] [bp-190h]@1

  return WSAStartup(0x101u, (LPWSADATA)&v1);
}

//----- (10004770) --------------------------------------------------------
void *__cdecl sub_10004770(const char *a1)
{
  void *result; // eax@2
  const char *v2; // ecx@4
  const char v3; // dl@5

  if ( a1 )
  {
    result = malloc(strlen(a1) + 1);
    if ( result )
    {
      v2 = a1;
      do
      {
        v3 = *v2;
        v2[result - a1] = *v2;
        ++v2;
      }
      while ( v3 );
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10004A40) --------------------------------------------------------
signed int __cdecl sub_10004A40(SOCKET fd)
{
  int v1; // eax@1
  int v2; // esi@1
  signed int result; // eax@4
  struct timeval timeout; // [sp+8h] [bp-10Ch]@1
  fd_set readfds; // [sp+10h] [bp-104h]@1

  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  readfds.fd_array[0] = fd;
  readfds.fd_count = 1;
  v1 = select(64, &readfds, 0, 0, &timeout);
  v2 = v1;
  if ( v1 == -1 || (v1 <= 0 || !_WSAFDIsSet(fd, &readfds) ? (result = 0) : (result = 1), v2 != 1) )
    result = 0;
  return result;
}

//----- (10004B40) --------------------------------------------------------
struct hostent *__cdecl sub_10004B40()
{
  char name; // [sp+8h] [bp-100h]@1
  char v2; // [sp+9h] [bp-FFh]@1
  __int16 v3; // [sp+105h] [bp-3h]@1
  char v4; // [sp+107h] [bp-1h]@1

  name = 0;
  memset(&v2, 0, 0xFCu);
  v3 = 0;
  v4 = 0;
  gethostname(&name, 256);
  return gethostbyname(&name);
}

//----- (10004C20) --------------------------------------------------------
int __stdcall sub_10004C20(int a1)
{
  struct hostent *v1; // eax@1
  struct WSAData WSAData; // [sp+4h] [bp-190h]@1

  WSAStartup(0x101u, &WSAData);
  v1 = gethostbyname(*(const char **)a1);
  if ( v1 )
    *(_DWORD *)(a1 + 4) = **(_DWORD **)v1->h_addr_list;
  else
    *(_DWORD *)(a1 + 4) = -1;
  WSACleanup();
  *(_DWORD *)(a1 + 8) = 1;
  return 0;
}

//----- (10004DB0) --------------------------------------------------------
int __cdecl sub_10004DB0()
{
  int v0; // eax@1
  int result; // eax@3

  v0 = ((16807 * word_1001109E & 0x7FFF) << 16) + 16807 * word_1001109C;
  if ( (unsigned int)v0 > 0x7FFFFFFF )
    v0 = (v0 & 0x7FFFFFFF) + 1;
  result = (16807 * (unsigned int)(unsigned __int16)word_1001109E >> 15) + v0;
  if ( (unsigned int)result > 0x7FFFFFFF )
    result = (result & 0x7FFFFFFF) + 1;
  *(_DWORD *)&word_1001109C = result;
  return result;
}
// 1001109E: using guessed type __int16 word_1001109E;

//----- (10004E90) --------------------------------------------------------
char __usercall sub_10004E90<al>(unsigned int a1<eax>, const void *a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  void *v5; // edi@3
  unsigned int v6; // edx@3
  int v7; // edi@3
  int i; // ecx@3
  char v9; // cl@6
  char v10; // al@6
  char v11; // dl@6
  unsigned __int8 v12; // cl@6
  char result; // al@6

  v3 = a3;
  v4 = 0;
  if ( (signed int)a1 <= 0 || (v4 = a1, memcpy(&a3, a2, a1), (signed int)a1 < 3) )
  {
    v5 = (char *)&a3 + v4;
    v6 = 3 - v4;
    memset(v5, 0, 4 * (v6 >> 2));
    v7 = (int)((char *)v5 + 4 * (v6 >> 2));
    for ( i = v6 & 3; i; --i )
      *(_BYTE *)v7++ = 0;
  }
  v9 = a3;
  *(_BYTE *)v3 = (unsigned __int8)a3 >> 2;
  v10 = BYTE1(a3);
  v11 = 16 * (v9 & 3) | (BYTE1(a3) >> 4);
  v12 = BYTE2(a3);
  *(_BYTE *)(v3 + 1) = v11;
  result = (v12 >> 6) | 4 * (v10 & 0xF);
  *(_BYTE *)(v3 + 2) = result;
  *(_BYTE *)(v3 + 3) = v12 & 0x3F;
  return result;
}

//----- (10005170) --------------------------------------------------------
DWORD __usercall sub_10005170<eax>(int a1<ebx>)
{
  DWORD v1; // edi@2
  time_t v2; // esi@4
  __int32 v3; // esi@4
  DWORD result; // eax@4
  int v5; // esi@4
  signed int v6; // esi@7
  int v7; // eax@11
  signed __int64 v8; // qtt@11
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-48h]@1
  char v10; // [sp+10h] [bp-40h]@1
  __int16 v11; // [sp+4Ch] [bp-4h]@1
  char v12; // [sp+4Eh] [bp-2h]@1

  memcpy(&v10, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 0x3Cu);
  v11 = *(_WORD *)"YZ";
  v12 = a0123456789abcd[62];
  if ( QueryPerformanceCounter(&PerformanceCount) )
    v1 = PerformanceCount.LowPart ^ PerformanceCount.HighPart;
  else
    v1 = 0;
  v2 = time(0);
  v3 = clock() ^ v2;
  result = GetTickCount();
  v5 = v1 ^ result ^ v3;
  if ( v5 )
    *(_DWORD *)&word_1001109C = v5 & 0x7FFFFFFF;
  else
    *(_DWORD *)&word_1001109C = 1;
  v6 = 0;
  do
  {
    if ( v6 == 4 || v6 == 9 || v6 == 14 )
    {
      *(_BYTE *)(v6 + a1) = 45;
    }
    else
    {
      v7 = sub_10004DB0();
      v8 = v7;
      result = v7 / 62;
      *(_BYTE *)(v6 + a1) = *(&v10 + (unsigned __int64)(v8 % 62));
    }
    ++v6;
  }
  while ( v6 < 19 );
  *(_BYTE *)(a1 + 19) = 0;
  return result;
}
// 10005170: using guessed type char var_40[64];

//----- (10005220) --------------------------------------------------------
BYTE *__cdecl sub_10005220()
{
  int v0; // esi@1
  HKEY hKey; // [sp+4h] [bp-10h]@1
  DWORD cbData; // [sp+8h] [bp-Ch]@1
  DWORD Type; // [sp+Ch] [bp-8h]@1
  DWORD dwDisposition; // [sp+10h] [bp-4h]@4

  Type = 1;
  cbData = 260;
  v0 = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\GameSpy\\GameSpy 3D\\Registration", 0, 0xF003Fu, &hKey) != 0;
  if ( RegQueryValueExA(hKey, "Crypt", 0, &Type, &Data, &cbData) || strlen((const char *)&Data) != 19 )
  {
    sub_10005170((int)&Data);
    if ( v0 )
      RegCreateKeyExA(
        HKEY_CURRENT_USER,
        "Software\\GameSpy\\GameSpy 3D\\Registration",
        0,
        0,
        0,
        0xF003Fu,
        0,
        &hKey,
        &dwDisposition);
    RegSetValueExA(hKey, "Crypt", 0, 1u, &Data, strlen((const char *)&Data) + 1);
  }
  RegCloseKey(hKey);
  memmove(&unk_10011664, &unk_10011665, 4u);
  memmove(&unk_10011668, &unk_1001166A, 4u);
  memmove(&unk_1001166C, &unk_1001166F, 4u);
  byte_10011670 = 0;
  return &Data;
}
// 10011670: using guessed type char byte_10011670;

//----- (10005390) --------------------------------------------------------
DWORD __cdecl sub_10005390()
{
  DWORD result; // eax@1

  sendto(s, &buf, len, 0, &to, 16);
  result = GetTickCount();
  dword_100117C0 = result;
  return result;
}
// 100117C0: using guessed type int dword_100117C0;

//----- (100053C0) --------------------------------------------------------
int __cdecl sub_100053C0(const char *a1)
{
  const char *v1; // eax@1
  const char v2; // cl@2
  char *v3; // edi@4
  int result; // eax@6
  unsigned int v5; // eax@9
  char name; // [sp+8h] [bp-40h]@4

  v1 = a1;
  do
  {
    v2 = *v1;
    v1[byte_10012000 - a1] = *v1;
    ++v1;
  }
  while ( v2 );
  s = -1;
  sub_10004740();
  if ( byte_10012040 )
  {
    v3 = &byte_10012040;
  }
  else
  {
    sprintf(&name, "%s.available.gamespy.com", a1);
    v3 = &name;
  }
  to.sa_family = 2;
  *(_WORD *)&to.sa_data[0] = htons(0x6CFCu);
  *(_DWORD *)&to.sa_data[2] = inet_addr(v3);
  if ( *(_DWORD *)&to.sa_data[2] == -1 )
  {
    result = (int)gethostbyname(v3);
    if ( !result )
      return result;
    *(_DWORD *)&to.sa_data[2] = ***(_DWORD ***)(result + 12);
  }
  result = socket(2, 2, 17);
  s = result;
  if ( result != -1 )
  {
    buf = 9;
    v5 = strlen(a1);
    memcpy(&unk_10011781, a1, v5 + 1);
    len = v5 + 6;
    sendto(s, &buf, v5 + 6, 0, &to, 16);
    result = GetTickCount();
    dword_100117C0 = result;
    dword_100117C4 = 0;
  }
  return result;
}
// 100117C0: using guessed type int dword_100117C0;
// 100117C4: using guessed type int dword_100117C4;
// 10012040: using guessed type char byte_10012040;

//----- (100054E0) --------------------------------------------------------
signed int __usercall sub_100054E0<eax>(int a1<eax>, signed int a2<edx>, int a3<ecx>, int a4)
{
  signed int result; // eax@2
  signed int v5; // ecx@5
  _UNKNOWN *v6; // edi@5
  int v7; // esi@5
  bool v8; // zf@5

  if ( a2 >= 7 )
  {
    if ( *(_DWORD *)(a3 + 4) != *(_DWORD *)&to.sa_data[2] || *(_WORD *)(a3 + 2) != *(_WORD *)&to.sa_data[0] )
      goto LABEL_13;
    v5 = 3;
    v6 = &unk_1000E9E4;
    v7 = a1;
    v8 = 1;
    do
    {
      if ( !v5 )
        break;
      v8 = *(_BYTE *)v7++ == *(_BYTE *)v6;
      v6 = (char *)v6 + 1;
      --v5;
    }
    while ( v8 );
    if ( v8 )
    {
      *(_DWORD *)a4 = *(_BYTE *)(a1 + 6) | ((*(_BYTE *)(a1 + 5) | ((*(_BYTE *)(a1 + 4) | (*(_BYTE *)(a1 + 3) << 8)) << 8)) << 8);
      result = 0;
    }
    else
    {
LABEL_13:
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10005550) --------------------------------------------------------
int __cdecl sub_10005550()
{
  int v0; // eax@3
  int result; // eax@5
  int v2; // [sp+0h] [bp-58h]@1
  char v3; // [sp+4h] [bp-54h]@3
  struct sockaddr from; // [sp+8h] [bp-50h]@3
  char buf; // [sp+18h] [bp-40h]@3

  v2 = 16;
  if ( s == -1 )
    goto LABEL_10;
  if ( !sub_10004A40(s)
    || (v0 = recvfrom(s, &buf, 64, 0, &from, &v2), sub_100054E0((int)&buf, v0, (int)&from, (int)&v3)) )
  {
    if ( GetTickCount() > dword_100117C0 + 2000 )
    {
      if ( dword_100117C4 == 1 )
      {
        closesocket(s);
LABEL_10:
        dword_10011FE0 = 1;
        return 1;
      }
      sub_10005390();
      ++dword_100117C4;
    }
    return 0;
  }
  closesocket(s);
  if ( v3 & 1 )
  {
    result = 2;
    dword_10011FE0 = 2;
  }
  else
  {
    result = v3 & 2 | 1;
    dword_10011FE0 = v3 & 2 | 1;
  }
  return result;
}
// 100117C0: using guessed type int dword_100117C0;
// 100117C4: using guessed type int dword_100117C4;
// 10011FE0: using guessed type int dword_10011FE0;

//----- (10005660) --------------------------------------------------------
void *__cdecl sub_10005660(int a1)
{
  void *result; // eax@1
  int v2; // edx@1
  bool v3; // zf@1
  int v4; // ecx@3
  int v5; // esi@4

  result = malloc(8u);
  v2 = dword_100117C8;
  v3 = dword_100117C8 == 0;
  *(_DWORD *)result = a1;
  *((_DWORD *)result + 1) = 0;
  if ( v3 )
  {
    dword_100117C8 = (int)result;
  }
  else
  {
    v4 = v2 + 4;
    if ( *(_DWORD *)(v2 + 4) )
    {
      do
      {
        v2 = *(_DWORD *)v4;
        v5 = *(_DWORD *)(*(_DWORD *)v4 + 4);
        v4 = *(_DWORD *)v4 + 4;
      }
      while ( v5 );
    }
    *(_DWORD *)(v2 + 4) = result;
  }
  return result;
}
// 100117C8: using guessed type int dword_100117C8;

//----- (100056F0) --------------------------------------------------------
signed int __cdecl sub_100056F0(signed int a1, void *a2)
{
  signed int result; // eax@1

  result = a1;
  if ( a1 >= 50 )
  {
    if ( a1 <= 254 )
      *(&off_100110A0 + a1) = a2;
  }
  return result;
}
// 100110A0: using guessed type void *off_100110A0;

//----- (10005740) --------------------------------------------------------
signed int __cdecl sub_10005740(int a1)
{
  signed int result; // eax@2
  int *v2; // eax@3
  unsigned int v3; // eax@3

  if ( dword_10011E34 < 4 )
  {
    v2 = &dword_10011FA0[4 * dword_10011E34++];
    *v2 = a1;
    v2[2] = 0;
    v2[3] = 0;
    v2[1] = 0;
    v3 = GetTickCount();
    srand(v3);
    byte_100117D7 = 0;
    byte_100117D0 = 103;
    byte_100117D1 = 97;
    byte_100117D2 = 109;
    byte_100117D3 = 101;
    byte_100117D4 = 115;
    byte_100117D5 = 112;
    byte_100117D6 = 121;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 100117D0: using guessed type char byte_100117D0;
// 100117D1: using guessed type char byte_100117D1;
// 100117D2: using guessed type char byte_100117D2;
// 100117D3: using guessed type char byte_100117D3;
// 100117D4: using guessed type char byte_100117D4;
// 100117D5: using guessed type char byte_100117D5;
// 100117D6: using guessed type char byte_100117D6;
// 100117D7: using guessed type char byte_100117D7;
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];

//----- (100057C0) --------------------------------------------------------
int __fastcall sub_100057C0(int a1, const char *a2, int a3)
{
  int v3; // edi@3
  bool v4; // sf@8
  unsigned __int8 v5; // of@8
  int result; // eax@9
  int v7; // [sp+10h] [bp-8h]@2
  int v8; // [sp+14h] [bp-4h]@1

  v8 = 0;
  if ( dword_10011E34 <= 0 )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    v7 = (int)dword_10011FA8;
    while ( 1 )
    {
      v3 = *(_DWORD *)v7;
      if ( *(_DWORD *)v7 )
        break;
LABEL_8:
      v5 = __OFSUB__(v8 + 1, dword_10011E34);
      v4 = v8++ + 1 - dword_10011E34 < 0;
      v7 += 16;
      if ( !(v4 ^ v5) )
        goto LABEL_9;
    }
    while ( strcmp(a2, (const char *)(*(_DWORD *)v3 + 4)) || a3 != -1 && *(_DWORD *)(*(_DWORD *)v3 + 40) != a3 )
    {
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        goto LABEL_8;
    }
    result = *(_DWORD *)v3;
  }
  return result;
}
// 10011E34: using guessed type int dword_10011E34;
// 10011FA8: using guessed type int dword_10011FA8[];

//----- (100058A0) --------------------------------------------------------
char *__cdecl sub_100058A0(const char *Str, const char *a2)
{
  int v2; // eax@1
  char v3; // cl@2
  unsigned int v4; // eax@3
  void *v5; // edi@3
  char v6; // cl@4
  unsigned int v7; // eax@5
  void *v8; // edi@5
  char v9; // cl@6
  char *v10; // eax@7
  char *result; // eax@8
  char *v12; // ecx@9
  char v13; // dl@10
  int v14; // eax@11
  char v15; // cl@11
  char *v16; // ebx@11
  char *v17; // esi@11
  signed int v18; // edi@12
  char v19; // [sp+0h] [bp-104h]@1
  char v20; // [sp+1h] [bp-103h]@1
  char v21; // [sp+3h] [bp-101h]@3
  char SubStr[256]; // [sp+4h] [bp-100h]@2
  _BYTE v23[3]; // [sp+5h] [bp-FFh]@11

  dword_100117DC ^= 1u;
  v19 = 92;
  v20 = 0;
  v2 = 0;
  do
  {
    v3 = *(&v19 + v2);
    SubStr[v2++] = v3;
  }
  while ( v3 );
  v4 = strlen(a2) + 1;
  v5 = &v21;
  do
  {
    v6 = *((_BYTE *)v5 + 1);
    v5 = (char *)v5 + 1;
  }
  while ( v6 );
  memcpy(v5, a2, v4);
  v7 = strlen(&v19) + 1;
  v8 = &v21;
  do
  {
    v9 = *((_BYTE *)v8 + 1);
    v8 = (char *)v8 + 1;
  }
  while ( v9 );
  memcpy(v8, &v19, v7);
  v10 = strstr(Str, SubStr);
  if ( v10 )
  {
    v12 = SubStr;
    do
      v13 = *v12++;
    while ( v13 );
    v14 = (int)&v10[v12 - v23];
    v15 = *(_BYTE *)v14;
    v16 = (char *)&unk_10011BF0 + 256 * dword_100117DC;
    v17 = (char *)&unk_10011BF0 + 256 * dword_100117DC;
    if ( *(_BYTE *)v14 )
    {
      v18 = 0;
      do
      {
        if ( v15 == 92 )
          break;
        if ( v18 >= 200 )
          break;
        *v17 = v15;
        v15 = *(_BYTE *)(v14 + 1);
        ++v17;
        ++v18;
        ++v14;
      }
      while ( v15 );
    }
    result = v16;
    *v17 = 0;
  }
  else
  {
    result = (char *)&unk_1000E7EB;
  }
  return result;
}
// 100117DC: using guessed type int dword_100117DC;
// 100058A0: using guessed type char SubStr[256];

//----- (100059E0) --------------------------------------------------------
struct hostent *__usercall sub_100059E0<eax>(int a1<edi>, const char *name, u_short hostshort, int a4)
{
  struct hostent *v4; // ebx@1
  struct hostent *result; // eax@6
  char v6; // [sp+8h] [bp-10h]@1
  char v7; // [sp+9h] [bp-Fh]@1
  char v8; // [sp+Ah] [bp-Eh]@1
  char v9; // [sp+Bh] [bp-Dh]@1
  char v10; // [sp+Ch] [bp-Ch]@1
  char v11; // [sp+Dh] [bp-Bh]@1
  char v12; // [sp+Eh] [bp-Ah]@1
  char v13; // [sp+Fh] [bp-9h]@1
  char v14; // [sp+10h] [bp-8h]@1
  char v15; // [sp+11h] [bp-7h]@1
  char v16; // [sp+12h] [bp-6h]@1
  char v17; // [sp+13h] [bp-5h]@1
  char v18; // [sp+14h] [bp-4h]@1
  char v19; // [sp+15h] [bp-3h]@1
  char v20; // [sp+16h] [bp-2h]@1
  char v21; // [sp+17h] [bp-1h]@1

  v6 = 50;
  v7 = 53;
  v8 = 53;
  v10 = 50;
  v11 = 53;
  v12 = 53;
  v14 = 50;
  v15 = 53;
  v16 = 53;
  v18 = 50;
  v19 = 53;
  v20 = 53;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  v9 = 46;
  v13 = 46;
  v17 = 46;
  *(_DWORD *)(a1 + 8) = 0;
  v4 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  v21 = 0;
  *(_WORD *)a1 = 2;
  *(_WORD *)(a1 + 2) = htons(hostshort);
  if ( name )
    *(_DWORD *)(a1 + 4) = inet_addr(name);
  else
    *(_DWORD *)(a1 + 4) = 0;
  if ( *(_DWORD *)(a1 + 4) == -1 && strcmp(name, &v6) )
  {
    result = gethostbyname(name);
    v4 = result;
    if ( !result )
      return result;
    *(_DWORD *)(a1 + 4) = **(_DWORD **)result->h_addr_list;
  }
  if ( a4 )
    *(_DWORD *)a4 = v4;
  return (struct hostent *)1;
}

//----- (10005BB0) --------------------------------------------------------
signed int __cdecl sub_10005BB0()
{
  signed int result; // eax@4
  int v1; // [sp+0h] [bp-14h]@3
  struct sockaddr name; // [sp+4h] [bp-10h]@2

  dword_10011498 = socket(2, 2, 17);
  if ( dword_10011498 != -1
    && (sub_100059E0((int)&name, 0, 0, 0), bind(dword_10011498, &name, 16) != -1)
    && (v1 = 16, getsockname(dword_10011498, &name, &v1) != -1) )
  {
    word_10011E30 = *(_WORD *)&name.sa_data[0];
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10011E30: using guessed type __int16 word_10011E30;

//----- (10005C30) --------------------------------------------------------
void *__cdecl sub_10005C30(const char *Str, int a2)
{
  char *v2; // eax@1
  int v3; // edi@1
  char *v4; // eax@1
  int v5; // ecx@1
  void *result; // eax@1
  void *v7; // esi@1
  char *v8; // eax@6
  int v9; // [sp+10h] [bp-38h]@1
  int v10; // [sp+14h] [bp-34h]@1
  char v11; // [sp+18h] [bp-30h]@1
  int v12; // [sp+1Ch] [bp-2Ch]@1
  char v13; // [sp+20h] [bp-28h]@1
  char v14; // [sp+21h] [bp-27h]@1
  char v15; // [sp+22h] [bp-26h]@1
  char Dest; // [sp+24h] [bp-24h]@1
  char v17; // [sp+44h] [bp-4h]@1

  v12 = 1836216933;
  LOBYTE(v10) = 115;
  *(_WORD *)((char *)&v10 + 1) = 25963;
  BYTE3(v10) = 121;
  v11 = 0;
  LOWORD(v9) = 25699;
  BYTE2(v9) = 0;
  v13 = 115;
  v14 = 103;
  v15 = 0;
  v2 = sub_100058A0(Str, (const char *)&v10);
  v3 = atoi(v2);
  v4 = sub_100058A0(Str, (const char *)&v9);
  strncpy(&Dest, v4, 0x20u);
  v17 = 0;
  result = (void *)sub_100057C0(v5, &Dest, v3);
  v7 = result;
  if ( result && *((_DWORD *)result + 10) == v3 && *((_DWORD *)result + 14) != 3 )
  {
    if ( a2 )
    {
      *((_DWORD *)result + 14) = 1;
    }
    else
    {
      *((_DWORD *)result + 14) = 2;
      v8 = sub_100058A0(Str, (const char *)&v12);
      result = sub_10004770(v8);
      *((_DWORD *)v7 + 17) = result;
    }
  }
  return result;
}

//----- (10005D20) --------------------------------------------------------
int __cdecl sub_10005D20(const char *Str, const struct sockaddr *to)
{
  int v2; // edi@1
  char *v3; // eax@1
  int *v4; // ecx@3
  int v5; // eax@4
  int v6; // ecx@4
  int v7; // edx@5
  int i; // eax@10
  int v9; // esi@12
  int v10; // edx@12
  char *j; // ecx@12
  char v12; // al@13
  int v14; // [sp+8h] [bp-50h]@1
  char Format; // [sp+Ch] [bp-4Ch]@1
  char v16; // [sp+Dh] [bp-4Bh]@1
  char v17; // [sp+Eh] [bp-4Ah]@1
  char v18; // [sp+Fh] [bp-49h]@1
  char v19; // [sp+10h] [bp-48h]@1
  char v20; // [sp+11h] [bp-47h]@1
  char v21; // [sp+12h] [bp-46h]@1
  char v22; // [sp+13h] [bp-45h]@1
  char v23; // [sp+14h] [bp-44h]@1
  char v24; // [sp+15h] [bp-43h]@1
  char v25; // [sp+16h] [bp-42h]@1
  char buf[64]; // [sp+18h] [bp-40h]@12

  v16 = 117;
  v19 = 117;
  v24 = 100;
  Format = 92;
  v22 = 92;
  v17 = 99;
  v18 = 111;
  v20 = 110;
  v21 = 116;
  v23 = 37;
  v25 = 0;
  LOBYTE(v14) = 112;
  *(_WORD *)((char *)&v14 + 1) = 25705;
  BYTE3(v14) = 0;
  v2 = 0;
  v3 = sub_100058A0(Str, (const char *)&v14);
  if ( !*v3 && dword_10011E34 > 0 )
  {
    v4 = dword_10011FA0;
LABEL_10:
    for ( i = v4[2]; i; ++v2 )
      i = *(_DWORD *)(i + 4);
    goto LABEL_12;
  }
  v5 = atoi(v3);
  v6 = 0;
  if ( dword_10011E34 > 0 )
  {
    v7 = (int)dword_10011FA0;
    while ( *(_DWORD *)v7 != v5 )
    {
      ++v6;
      v7 += 16;
      if ( v6 >= dword_10011E34 )
        goto LABEL_12;
    }
    v4 = &dword_10011FA0[4 * v6];
    if ( v4 )
      goto LABEL_10;
  }
LABEL_12:
  v9 = sprintf(buf, &Format, v2);
  v10 = 0;
  for ( j = &byte_100117D0; v10 < v9; ++v10 )
  {
    buf[v10] ^= *j;
    v12 = (j++)[1];
    if ( !v12 )
      j = &byte_100117D0;
  }
  return sendto(dword_10011498, buf, v9, 0, to, 16);
}
// 100117D0: using guessed type char byte_100117D0;
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];
// 10005D20: using guessed type char buf[64];

//----- (10005E40) --------------------------------------------------------
int __usercall sub_10005E40<eax>(const char *a1<eax>, const struct sockaddr *to)
{
  const char *v2; // esi@1
  char *v3; // eax@1
  int v4; // edi@1
  char *v5; // eax@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // edi@5
  int v9; // esi@5
  char *i; // ecx@5
  char v11; // dl@6
  char v12; // al@6
  char *v14; // [sp-Ch] [bp-84h]@3
  char *v15; // [sp-8h] [bp-80h]@3
  int v16; // [sp-4h] [bp-7Ch]@3
  int v17; // [sp+Ch] [bp-6Ch]@1
  int v18; // [sp+10h] [bp-68h]@1
  char v19; // [sp+14h] [bp-64h]@1
  char v20; // [sp+18h] [bp-60h]@1
  char v21; // [sp+19h] [bp-5Fh]@1
  char v22; // [sp+1Ah] [bp-5Eh]@1
  char v23; // [sp+1Bh] [bp-5Dh]@1
  char v24; // [sp+1Ch] [bp-5Ch]@1
  char v25; // [sp+1Dh] [bp-5Bh]@1
  char v26; // [sp+1Eh] [bp-5Ah]@1
  char v27; // [sp+1Fh] [bp-59h]@1
  char v28; // [sp+20h] [bp-58h]@1
  char v29; // [sp+21h] [bp-57h]@1
  char v30; // [sp+22h] [bp-56h]@1
  char v31; // [sp+23h] [bp-55h]@1
  char v32; // [sp+24h] [bp-54h]@1
  char v33; // [sp+25h] [bp-53h]@1
  char Format; // [sp+28h] [bp-50h]@1
  char v35; // [sp+29h] [bp-4Fh]@1
  char v36; // [sp+2Ah] [bp-4Eh]@1
  char v37; // [sp+2Bh] [bp-4Dh]@1
  char v38; // [sp+2Ch] [bp-4Ch]@1
  char v39; // [sp+2Dh] [bp-4Bh]@1
  char v40; // [sp+2Eh] [bp-4Ah]@1
  char v41; // [sp+2Fh] [bp-49h]@1
  char v42; // [sp+30h] [bp-48h]@1
  char v43; // [sp+31h] [bp-47h]@1
  char v44; // [sp+32h] [bp-46h]@1
  char v45; // [sp+33h] [bp-45h]@1
  char v46; // [sp+34h] [bp-44h]@1
  char v47; // [sp+35h] [bp-43h]@1
  char v48; // [sp+36h] [bp-42h]@1
  char buf[64]; // [sp+38h] [bp-40h]@3

  v2 = a1;
  v20 = 92;
  v24 = 92;
  v25 = 92;
  v30 = 92;
  Format = 92;
  v39 = 92;
  v40 = 92;
  v45 = 92;
  v21 = 117;
  v22 = 111;
  v23 = 110;
  v26 = 115;
  v27 = 107;
  v28 = 101;
  v29 = 121;
  v31 = 37;
  v32 = 100;
  v33 = 0;
  v35 = 117;
  v36 = 111;
  v37 = 102;
  v38 = 102;
  v41 = 115;
  v42 = 107;
  v43 = 101;
  v44 = 121;
  v46 = 37;
  v47 = 100;
  v48 = 0;
  v18 = 2036689779;
  v19 = 0;
  LOWORD(v17) = 25699;
  BYTE2(v17) = 0;
  v3 = sub_100058A0(a1, (const char *)&v18);
  v4 = atoi(v3);
  v5 = sub_100058A0(v2, (const char *)&v17);
  v7 = sub_100057C0(v6, v5, -1);
  if ( v7 && *(_DWORD *)(v7 + 56) == 3 )
  {
    v16 = v4;
    v15 = &v20;
    v14 = buf;
  }
  else
  {
    v16 = v4;
    v15 = &Format;
    v14 = buf;
  }
  v8 = sprintf(v14, v15, v16);
  v9 = 0;
  for ( i = &byte_100117D0; v9 < v8; ++v9 )
  {
    v11 = *i ^ buf[v9];
    v12 = (i++)[1];
    buf[v9] = v11;
    if ( !v12 )
      i = &byte_100117D0;
  }
  return sendto(dword_10011498, buf, v8, 0, to, 16);
}
// 100117D0: using guessed type char byte_100117D0;
// 10005E40: using guessed type char buf[64];

//----- (10005FA0) --------------------------------------------------------
int __fastcall sub_10005FA0(int a1, int a2, int a3)
{
  int v3; // ST14_4@1
  int v4; // ST0C_4@1
  int v5; // esi@1
  int v6; // edx@1
  char *i; // ecx@1
  char v8; // bl@2
  char v9; // al@2
  char Format; // [sp+4h] [bp-21Ch]@1
  char v12; // [sp+5h] [bp-21Bh]@1
  char v13; // [sp+6h] [bp-21Ah]@1
  char v14; // [sp+7h] [bp-219h]@1
  char v15; // [sp+8h] [bp-218h]@1
  char v16; // [sp+9h] [bp-217h]@1
  char v17; // [sp+Ah] [bp-216h]@1
  char v18; // [sp+Bh] [bp-215h]@1
  char v19; // [sp+Ch] [bp-214h]@1
  char v20; // [sp+Dh] [bp-213h]@1
  char v21; // [sp+Eh] [bp-212h]@1
  char v22; // [sp+Fh] [bp-211h]@1
  char v23; // [sp+10h] [bp-210h]@1
  char v24; // [sp+11h] [bp-20Fh]@1
  char v25; // [sp+12h] [bp-20Eh]@1
  char v26; // [sp+13h] [bp-20Dh]@1
  char v27; // [sp+14h] [bp-20Ch]@1
  char v28; // [sp+15h] [bp-20Bh]@1
  char v29; // [sp+16h] [bp-20Ah]@1
  char v30; // [sp+17h] [bp-209h]@1
  char v31; // [sp+18h] [bp-208h]@1
  char v32; // [sp+19h] [bp-207h]@1
  char v33; // [sp+1Ah] [bp-206h]@1
  char v34; // [sp+1Bh] [bp-205h]@1
  char v35; // [sp+1Ch] [bp-204h]@1
  char v36; // [sp+1Dh] [bp-203h]@1
  char buf[512]; // [sp+20h] [bp-200h]@1

  Format = 92;
  v16 = 92;
  v17 = 92;
  v21 = 92;
  v24 = 92;
  v27 = 92;
  v30 = 92;
  v33 = 92;
  v3 = *(_DWORD *)(a2 + 44);
  v12 = 100;
  v20 = 100;
  v23 = 100;
  v26 = 100;
  v35 = 100;
  v4 = *(_DWORD *)a3;
  v13 = 105;
  v14 = 115;
  v15 = 99;
  v18 = 112;
  v19 = 105;
  v22 = 37;
  v25 = 99;
  v28 = 37;
  v29 = 115;
  v31 = 105;
  v32 = 112;
  v34 = 37;
  v36 = 0;
  v5 = sprintf(buf, &Format, v4, a2 + 4, v3);
  v6 = 0;
  for ( i = &byte_100117D0; v6 < v5; ++v6 )
  {
    v8 = *i ^ buf[v6];
    v9 = (i++)[1];
    buf[v6] = v8;
    if ( !v9 )
      i = &byte_100117D0;
  }
  return sendto(dword_10011498, buf, v5, 0, &stru_10011BE0, 16);
}
// 100117D0: using guessed type char byte_100117D0;
// 10005FA0: using guessed type char buf[512];

//----- (100060A0) --------------------------------------------------------
void *__usercall sub_100060A0<eax>(int a1<esi>, int a2, int a3, int a4)
{
  unsigned __int16 v4; // di@1
  DWORD v5; // eax@1
  int v6; // ecx@1
  int v7; // ST18_4@1
  int v8; // edi@1
  int v9; // ecx@1
  char *i; // eax@1
  char v11; // dl@2
  void *v12; // eax@5
  void *result; // eax@5
  char Format; // [sp+8h] [bp-22Ch]@1
  char v15; // [sp+9h] [bp-22Bh]@1
  char v16; // [sp+Ah] [bp-22Ah]@1
  char v17; // [sp+Bh] [bp-229h]@1
  char v18; // [sp+Ch] [bp-228h]@1
  char v19; // [sp+Dh] [bp-227h]@1
  char v20; // [sp+Eh] [bp-226h]@1
  char v21; // [sp+Fh] [bp-225h]@1
  char v22; // [sp+10h] [bp-224h]@1
  char v23; // [sp+11h] [bp-223h]@1
  char v24; // [sp+12h] [bp-222h]@1
  char v25; // [sp+13h] [bp-221h]@1
  char v26; // [sp+14h] [bp-220h]@1
  char v27; // [sp+15h] [bp-21Fh]@1
  char v28; // [sp+16h] [bp-21Eh]@1
  char v29; // [sp+17h] [bp-21Dh]@1
  char v30; // [sp+18h] [bp-21Ch]@1
  char v31; // [sp+19h] [bp-21Bh]@1
  char v32; // [sp+1Ah] [bp-21Ah]@1
  char v33; // [sp+1Bh] [bp-219h]@1
  char v34; // [sp+1Ch] [bp-218h]@1
  char v35; // [sp+1Dh] [bp-217h]@1
  char v36; // [sp+1Eh] [bp-216h]@1
  char v37; // [sp+1Fh] [bp-215h]@1
  char v38; // [sp+20h] [bp-214h]@1
  char v39; // [sp+21h] [bp-213h]@1
  char v40; // [sp+22h] [bp-212h]@1
  char v41; // [sp+23h] [bp-211h]@1
  char v42; // [sp+24h] [bp-210h]@1
  char v43; // [sp+25h] [bp-20Fh]@1
  char v44; // [sp+26h] [bp-20Eh]@1
  char v45; // [sp+27h] [bp-20Dh]@1
  char v46; // [sp+28h] [bp-20Ch]@1
  char v47; // [sp+29h] [bp-20Bh]@1
  char v48; // [sp+2Ah] [bp-20Ah]@1
  char v49; // [sp+2Bh] [bp-209h]@1
  char v50; // [sp+2Ch] [bp-208h]@1
  char v51; // [sp+2Dh] [bp-207h]@1
  char v52; // [sp+2Eh] [bp-206h]@1
  char v53; // [sp+2Fh] [bp-205h]@1
  char v54; // [sp+30h] [bp-204h]@1
  char v55; // [sp+31h] [bp-203h]@1
  char Src[512]; // [sp+34h] [bp-200h]@1

  v18 = 104;
  v23 = 100;
  v26 = 100;
  v29 = 104;
  v46 = 100;
  v54 = 100;
  Format = 92;
  v15 = 97;
  v16 = 117;
  v17 = 116;
  v19 = 92;
  v20 = 92;
  v21 = 112;
  v22 = 105;
  v24 = 92;
  v25 = 37;
  v27 = 92;
  v28 = 99;
  v30 = 92;
  v31 = 37;
  v32 = 115;
  v33 = 92;
  v34 = 114;
  v35 = 101;
  v36 = 115;
  v37 = 112;
  v38 = 92;
  v39 = 37;
  v40 = 115;
  v41 = 92;
  v42 = 105;
  v43 = 112;
  v44 = 92;
  v45 = 37;
  v47 = 92;
  v48 = 115;
  v49 = 107;
  v50 = 101;
  v51 = 121;
  v52 = 92;
  v53 = 37;
  v55 = 0;
  *(_DWORD *)(a1 + 56) = 0;
  v4 = GetTickCount();
  *(_DWORD *)(a1 + 40) = ((unsigned __int16)rand() ^ v4) & 0x3FFF;
  v5 = GetTickCount();
  v6 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 48) = v5;
  v7 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 52) = 1;
  v8 = sprintf(Src, &Format, *(_DWORD *)a2, a3, a4, v6, v7);
  v9 = 0;
  for ( i = &byte_100117D0; v9 < v8; ++v9 )
  {
    Src[v9] ^= *i;
    v11 = (i++)[1];
    if ( !v11 )
      i = &byte_100117D0;
  }
  sendto(dword_10011498, Src, v8, 0, &stru_10011BE0, 16);
  v12 = malloc(v8);
  *(_DWORD *)(a1 + 72) = v12;
  result = memmove(v12, Src, v8);
  *(_DWORD *)(a1 + 76) = v8;
  return result;
}
// 100117D0: using guessed type char byte_100117D0;
// 100060A0: using guessed type char Src[512];

//----- (100062F0) --------------------------------------------------------
void *__cdecl sub_100062F0(int a1, int a2, int a3, int a4, const char *Source, int a6, int a7)
{
  void *result; // eax@1
  int v8; // esi@2
  void *v9; // edi@6
  void *v10; // ebx@8
  int v11; // edi@10
  void *v12; // eax@15
  int v13; // esi@15
  char *v14; // eax@15
  char v15; // cl@16
  int v16; // ecx@17
  int v17; // [sp+Ch] [bp-44h]@6
  char v18; // [sp+10h] [bp-40h]@1
  char v19; // [sp+11h] [bp-3Fh]@1
  char v20; // [sp+12h] [bp-3Eh]@1
  char v21; // [sp+13h] [bp-3Dh]@1
  char v22; // [sp+14h] [bp-3Ch]@1
  char v23; // [sp+15h] [bp-3Bh]@1
  char v24; // [sp+16h] [bp-3Ah]@1
  char v25; // [sp+17h] [bp-39h]@1
  char v26; // [sp+18h] [bp-38h]@1
  char v27; // [sp+19h] [bp-37h]@1
  char v28; // [sp+1Ah] [bp-36h]@1
  char v29; // [sp+1Ch] [bp-34h]@1
  char v30; // [sp+1Dh] [bp-33h]@1
  char v31; // [sp+1Eh] [bp-32h]@1
  char v32; // [sp+1Fh] [bp-31h]@1
  char v33; // [sp+20h] [bp-30h]@1
  char v34; // [sp+21h] [bp-2Fh]@1
  char v35; // [sp+22h] [bp-2Eh]@1
  char v36; // [sp+23h] [bp-2Dh]@1
  char v37; // [sp+24h] [bp-2Ch]@1
  char v38; // [sp+25h] [bp-2Bh]@1
  char v39; // [sp+26h] [bp-2Ah]@1
  char v40; // [sp+27h] [bp-29h]@1
  char v41; // [sp+28h] [bp-28h]@1
  char v42; // [sp+29h] [bp-27h]@1
  char Dest; // [sp+2Ch] [bp-24h]@7
  char v44; // [sp+4Ch] [bp-4h]@7

  v27 = 121;
  v34 = 121;
  v26 = 101;
  v33 = 101;
  v41 = 101;
  result = 0;
  v18 = 66;
  v19 = 97;
  v20 = 100;
  v21 = 32;
  v22 = 67;
  v23 = 68;
  v24 = 32;
  v25 = 75;
  v28 = 0;
  v29 = 67;
  v30 = 68;
  v31 = 32;
  v32 = 75;
  v35 = 32;
  v36 = 105;
  v37 = 110;
  v38 = 32;
  v39 = 117;
  v40 = 115;
  v42 = 0;
  if ( dword_10011E34 > 0 )
  {
    v8 = (int)dword_10011FA0;
    while ( *(_DWORD *)v8 != a1 )
    {
      result = (char *)result + 1;
      v8 += 16;
      if ( (signed int)result >= dword_10011E34 )
        return result;
    }
    result = &dword_10011FA0[4 * (signed int)result];
    v9 = result;
    v17 = (int)result;
    if ( result )
    {
      strncpy(&Dest, Source, 0x20u);
      v44 = 0;
      if ( strlen(Source) >= 0x48 )
        v10 = 0;
      else
        v10 = sub_10004770(&v18);
      v11 = *((_DWORD *)v9 + 2);
      if ( v11 )
      {
        while ( strcmp(&Dest, (const char *)(*(_DWORD *)v11 + 4)) )
        {
          v11 = *(_DWORD *)(v11 + 4);
          if ( !v11 )
            goto LABEL_15;
        }
        v10 = sub_10004770(&v29);
      }
LABEL_15:
      v12 = malloc(0x50u);
      v13 = (int)v12;
      *(_DWORD *)v12 = a2;
      *((_DWORD *)v12 + 15) = a7;
      *((_DWORD *)v12 + 11) = a3;
      v14 = &Dest;
      *(_DWORD *)(v13 + 64) = a6;
      *(_DWORD *)(v13 + 68) = 0;
      *(_DWORD *)(v13 + 72) = 0;
      do
      {
        v15 = *v14;
        v14[v13 + 4 - (_DWORD)&Dest] = *v14;
        ++v14;
      }
      while ( v15 );
      result = malloc(0xCu);
      v16 = v17 + 4;
      *(_DWORD *)result = v13;
      if ( *(_DWORD *)(v17 + 8) )
      {
        do
          v16 = *(_DWORD *)(v16 + 4);
        while ( *(_DWORD *)(v16 + 4) );
      }
      *(_DWORD *)(v16 + 4) = result;
      *((_DWORD *)result + 2) = v16;
      *((_DWORD *)result + 1) = 0;
      if ( v10 )
      {
        *(_DWORD *)(v13 + 68) = v10;
        *(_DWORD *)(v13 + 56) = 2;
      }
      else
      {
        result = sub_100060A0(v13, v17, a4, (int)Source);
      }
    }
  }
  return result;
}
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];

//----- (10006510) --------------------------------------------------------
void __cdecl sub_10006510(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@2
  int v4; // eax@6
  int v5; // esi@7
  int v6; // eax@11

  v2 = 0;
  if ( dword_10011E34 > 0 )
  {
    v3 = (int)dword_10011FA0;
    while ( *(_DWORD *)v3 != a1 )
    {
      ++v2;
      v3 += 16;
      if ( v2 >= dword_10011E34 )
        return;
    }
    v4 = (int)&dword_10011FA0[4 * v2];
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 8);
      if ( v5 )
      {
        while ( **(_DWORD **)v5 != a2 )
        {
          v5 = *(_DWORD *)(v5 + 4);
          if ( !v5 )
            return;
        }
        sub_10005FA0(a2, *(_DWORD *)v5, v4);
        *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4) = *(_DWORD *)(v5 + 4);
        v6 = *(_DWORD *)(v5 + 4);
        if ( v6 )
          *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 8);
        if ( *(_DWORD *)(*(_DWORD *)v5 + 72) )
          free(*(void **)(*(_DWORD *)v5 + 72));
        free(*(void **)v5);
        free((void *)v5);
      }
    }
  }
}
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];

//----- (100065B0) --------------------------------------------------------
void __cdecl sub_100065B0(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  int v3; // eax@6
  bool v4; // zf@6
  int *v5; // eax@6
  int v6; // edi@6
  int i; // esi@7
  int v8; // eax@8

  v1 = 0;
  if ( dword_10011E34 > 0 )
  {
    v2 = (int)dword_10011FA0;
    while ( *(_DWORD *)v2 != a1 )
    {
      ++v1;
      v2 += 16;
      if ( v1 >= dword_10011E34 )
        return;
    }
    v3 = 4 * v1;
    v4 = &dword_10011FA0[v3] == 0;
    v5 = &dword_10011FA0[v3];
    v6 = (int)v5;
    if ( !v4 )
    {
      for ( i = v5[2]; i; i = *(_DWORD *)(v6 + 8) )
      {
        sub_10005FA0(v2, *(_DWORD *)i, v6);
        *(_DWORD *)(*(_DWORD *)(i + 8) + 4) = *(_DWORD *)(i + 4);
        v8 = *(_DWORD *)(i + 4);
        if ( v8 )
          *(_DWORD *)(v8 + 8) = *(_DWORD *)(i + 8);
        if ( *(_DWORD *)(*(_DWORD *)i + 72) )
          free(*(void **)(*(_DWORD *)i + 72));
        free(*(void **)i);
        free((void *)i);
      }
    }
  }
}
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];

//----- (10006640) --------------------------------------------------------
char __cdecl sub_10006640(signed int Str, int a2, const struct sockaddr *to)
{
  int v3; // ecx@1
  char *i; // eax@1
  char v5; // bl@2
  bool v6; // zf@5
  char *v7; // eax@6
  int v8; // esi@7
  char v10; // [sp+Ch] [bp-3Ch]@1
  char v11; // [sp+Dh] [bp-3Bh]@1
  char v12; // [sp+Eh] [bp-3Ah]@1
  char v13; // [sp+Fh] [bp-39h]@1
  char v14; // [sp+10h] [bp-38h]@1
  char v15; // [sp+11h] [bp-37h]@1
  char v16; // [sp+12h] [bp-36h]@1
  char v17; // [sp+13h] [bp-35h]@1
  char v18; // [sp+14h] [bp-34h]@1
  char v19; // [sp+18h] [bp-30h]@1
  char v20; // [sp+19h] [bp-2Fh]@1
  char v21; // [sp+1Ah] [bp-2Eh]@1
  char v22; // [sp+1Bh] [bp-2Dh]@1
  char v23; // [sp+1Ch] [bp-2Ch]@1
  char v24; // [sp+20h] [bp-28h]@1
  char v25; // [sp+21h] [bp-27h]@1
  char v26; // [sp+22h] [bp-26h]@1
  char v27; // [sp+23h] [bp-25h]@1
  char v28; // [sp+24h] [bp-24h]@1
  char v29; // [sp+25h] [bp-23h]@1
  char v30; // [sp+26h] [bp-22h]@1
  char v31; // [sp+27h] [bp-21h]@8
  char Dest; // [sp+28h] [bp-20h]@5

  v10 = 117;
  v14 = 117;
  v24 = 117;
  v27 = 117;
  v3 = 0;
  v11 = 111;
  v16 = 111;
  v21 = 111;
  v26 = 111;
  v12 = 107;
  v13 = 0;
  v15 = 110;
  v17 = 107;
  v18 = 0;
  v19 = 105;
  v20 = 115;
  v22 = 110;
  v23 = 0;
  v25 = 99;
  v28 = 110;
  v29 = 116;
  v30 = 0;
  for ( i = &byte_100117D0; v3 < a2; ++v3 )
  {
    v5 = *i++ ^ *(_BYTE *)(v3 + Str);
    *(_BYTE *)(v3 + Str) = v5;
    if ( !*i )
      i = &byte_100117D0;
  }
  v6 = *(_BYTE *)Str == 92;
  Dest = 0;
  if ( v6 )
  {
    v7 = strchr((const char *)(Str + 1), 92);
    if ( v7 )
    {
      v8 = (int)&v7[-Str];
      if ( (signed int)&v7[-Str] <= 32 )
      {
        strncpy(&Dest, (const char *)(Str + 1), v8 - 1);
        *(&v31 + v8) = 0;
      }
    }
    LOBYTE(i) = Dest;
    if ( Dest )
    {
      if ( strcmp(&Dest, &v10) )
      {
        if ( strcmp(&Dest, &v14) )
        {
          if ( strcmp(&Dest, &v19) )
          {
            i = (char *)strcmp(&Dest, &v24);
            if ( !i )
              LOBYTE(i) = sub_10005D20((const char *)Str, to);
          }
          else
          {
            LOBYTE(i) = sub_10005E40((const char *)Str, to);
          }
        }
        else
        {
          LOBYTE(i) = (unsigned int)sub_10005C30((const char *)Str, 0);
        }
      }
      else
      {
        LOBYTE(i) = (unsigned int)sub_10005C30((const char *)Str, 1);
      }
    }
  }
  return (char)i;
}
// 100117D0: using guessed type char byte_100117D0;

//----- (10006870) --------------------------------------------------------
signed int __cdecl sub_10006870(SOCKET *a1, int a2)
{
  signed int result; // eax@2
  SOCKET *v3; // esi@3
  SOCKET v4; // eax@5

  if ( dword_10011FE0 == 1 )
  {
    v3 = a1;
    if ( !a1 )
      v3 = (SOCKET *)&unk_100114A0;
    v4 = *v3;
    v3[55] = (SOCKET)sub_10006640;
    *(_DWORD *)&stru_10011BE0.sa_family = 0;
    *(_DWORD *)&stru_10011BE0.sa_data[2] = 0;
    *(_DWORD *)&stru_10011BE0.sa_data[6] = 0;
    word_10011E30 = -1;
    dword_10011498 = v4;
    *(_DWORD *)&stru_10011BE0.sa_data[10] = 0;
    stru_10011BE0.sa_family = 2;
    *(_WORD *)&stru_10011BE0.sa_data[0] = htons(0x74D6u);
    *(_DWORD *)&stru_10011BE0.sa_data[2] = v3[52];
    result = sub_10005740(a2);
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10011E30: using guessed type __int16 word_10011E30;
// 10011FE0: using guessed type int dword_10011FE0;

//----- (10006900) --------------------------------------------------------
int __cdecl sub_10006900()
{
  int result; // eax@1
  int v1; // esi@1
  int *v2; // edi@2

  result = dword_10011E34;
  v1 = 0;
  if ( dword_10011E34 > 0 )
  {
    v2 = dword_10011FA0;
    do
    {
      sub_100065B0(*v2);
      result = dword_10011E34;
      ++v1;
      v2 += 4;
    }
    while ( v1 < dword_10011E34 );
  }
  if ( word_10011E30 != -1 )
  {
    closesocket(dword_10011498);
    result = j_WSACleanup();
  }
  dword_10011498 = -1;
  dword_10011E34 = 0;
  return result;
}
// 10011E30: using guessed type __int16 word_10011E30;
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];

//----- (10006960) --------------------------------------------------------
char __cdecl sub_10006960()
{
  int i; // eax@1
  int v1; // ebp@1
  int v2; // eax@4
  int v3; // edi@8
  int v4; // esi@9
  int v5; // eax@9
  int v6; // eax@10
  void **v7; // esi@12
  bool v8; // zf@12
  int v9; // eax@12
  int v10; // ecx@14
  _UNKNOWN *v11; // ecx@16
  DWORD v12; // eax@23
  int v13; // edx@23
  int v14; // ecx@23
  const char *v15; // eax@23
  char *v16; // eax@24
  char v18; // [sp+8h] [bp-144h]@1
  char v19; // [sp+9h] [bp-143h]@1
  char v20; // [sp+Ah] [bp-142h]@1
  char v21; // [sp+Bh] [bp-141h]@1
  char v22; // [sp+Ch] [bp-140h]@1
  char v23; // [sp+Dh] [bp-13Fh]@1
  char v24; // [sp+Eh] [bp-13Eh]@1
  char v25; // [sp+Fh] [bp-13Dh]@1
  char v26; // [sp+10h] [bp-13Ch]@1
  char v27; // [sp+11h] [bp-13Bh]@1
  char v28; // [sp+14h] [bp-138h]@1
  char v29; // [sp+15h] [bp-137h]@1
  char v30; // [sp+16h] [bp-136h]@1
  char v31; // [sp+17h] [bp-135h]@1
  char v32; // [sp+18h] [bp-134h]@1
  char v33; // [sp+19h] [bp-133h]@1
  char v34; // [sp+1Ah] [bp-132h]@1
  char v35; // [sp+1Bh] [bp-131h]@1
  char v36; // [sp+1Ch] [bp-130h]@1
  char v37; // [sp+1Dh] [bp-12Fh]@1
  char v38; // [sp+1Eh] [bp-12Eh]@1
  char v39; // [sp+1Fh] [bp-12Dh]@1
  char v40; // [sp+20h] [bp-12Ch]@1
  char v41; // [sp+21h] [bp-12Bh]@1
  char v42; // [sp+22h] [bp-12Ah]@1
  char v43; // [sp+23h] [bp-129h]@1
  char v44; // [sp+24h] [bp-128h]@1
  char v45; // [sp+25h] [bp-127h]@1
  char v46; // [sp+26h] [bp-126h]@1
  int v47; // [sp+28h] [bp-124h]@7
  struct timeval timeout; // [sp+2Ch] [bp-120h]@1
  int fromlen; // [sp+34h] [bp-118h]@1
  struct sockaddr from; // [sp+38h] [bp-114h]@4
  fd_set readfds; // [sp+48h] [bp-104h]@2

  LOBYTE(i) = 105;
  v1 = 0;
  v19 = 97;
  v23 = 97;
  v29 = 97;
  v33 = 97;
  fromlen = 16;
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  v18 = 86;
  v20 = 108;
  v21 = 105;
  v22 = 100;
  v24 = 116;
  v25 = 101;
  v26 = 100;
  v27 = 0;
  v28 = 86;
  v30 = 108;
  v31 = 105;
  v32 = 100;
  v34 = 116;
  v35 = 105;
  v36 = 111;
  v37 = 110;
  v38 = 32;
  v39 = 84;
  v40 = 105;
  v41 = 109;
  v42 = 101;
  v43 = 111;
  v44 = 117;
  v45 = 116;
  v46 = 0;
  if ( word_10011E30 != -1 )
  {
    readfds.fd_array[0] = dword_10011498;
    readfds.fd_count = 1;
    for ( i = select(64, &readfds, 0, 0, &timeout); i != -1; i = select(64, &readfds, 0, 0, &timeout) )
    {
      if ( !i )
        break;
      v2 = recvfrom(dword_10011498, &byte_100117E0, 1023, 0, &from, &fromlen);
      if ( v2 != -1 )
      {
        *(&byte_100117E0 + v2) = 0;
        sub_10006640((signed int)&byte_100117E0, v2, &from);
      }
    }
  }
  v47 = 0;
  if ( dword_10011E34 > 0 )
  {
    while ( 1 )
    {
      v3 = dword_10011FA8[v1];
      if ( v3 )
        break;
LABEL_28:
      LOBYTE(i) = v47 + 1;
      v1 += 4;
      ++v47;
      if ( v47 >= dword_10011E34 )
        return i;
    }
    while ( 1 )
    {
      v4 = *(_DWORD *)v3;
      v5 = *(_DWORD *)(*(_DWORD *)v3 + 56);
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( !v6 )
          goto LABEL_24;
        if ( v6 == 1 )
        {
          v7 = (void **)v3;
          v8 = v3 == 0;
          v3 = *(_DWORD *)(v3 + 8);
          v9 = (int)v7;
          if ( !v8 || (v9 = dword_10011FA8[v1]) != 0 )
          {
            *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = *(_DWORD *)(v9 + 4);
            v10 = *(_DWORD *)(v9 + 4);
            if ( v10 )
              *(_DWORD *)(v10 + 8) = *(_DWORD *)(v9 + 8);
          }
          v11 = (_UNKNOWN *)*((_DWORD *)*v7 + 17);
          if ( !v11 )
            v11 = &unk_1000E7EB;
          (*(void (__cdecl **)(int, _DWORD, _DWORD, _UNKNOWN *, _DWORD))((void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))*v7
                                                                       + 16))(
            dword_10011FA0[v1],
            *(_DWORD *)*v7,
            0,
            v11,
            *((_DWORD *)*v7 + 15));
          free(*((void **)*v7 + 18));
          if ( *((_DWORD *)*v7 + 17) )
            free(*((void **)*v7 + 17));
          free(*v7);
          free(v7);
        }
      }
      else
      {
        v4 = *(_DWORD *)v3;
        if ( GetTickCount() >= *(_DWORD *)(*(_DWORD *)v3 + 48) + 2000 )
        {
          if ( *(_DWORD *)(v4 + 52) > 2 )
          {
LABEL_24:
            v16 = &v18;
            if ( *(_DWORD *)(v4 + 56) != 1 )
              v16 = &v28;
            (*(void (__cdecl **)(int, _DWORD, signed int, char *, _DWORD))(v4 + 64))(
              dword_10011FA0[v1],
              *(_DWORD *)v4,
              1,
              v16,
              *(_DWORD *)(v4 + 60));
            *(_DWORD *)(*(_DWORD *)v3 + 56) = 3;
            free(*(void **)(*(_DWORD *)v3 + 72));
            *(_DWORD *)(*(_DWORD *)v3 + 72) = 0;
            goto LABEL_27;
          }
          v12 = GetTickCount();
          v13 = *(_DWORD *)(v4 + 76);
          v14 = *(_DWORD *)(v4 + 52) + 1;
          *(_DWORD *)(v4 + 48) = v12;
          v15 = *(const char **)(v4 + 72);
          *(_DWORD *)(v4 + 52) = v14;
          sendto(dword_10011498, v15, v13, 0, &stru_10011BE0, 16);
        }
      }
LABEL_27:
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        goto LABEL_28;
    }
  }
  return i;
}
// 10011E30: using guessed type __int16 word_10011E30;
// 10011E34: using guessed type int dword_10011E34;
// 10011FA0: using guessed type int dword_10011FA0[];
// 10011FA8: using guessed type int dword_10011FA8[];

//----- (10006C20) --------------------------------------------------------
void *__cdecl sub_10006C20(int a1, int a2)
{
  void *result; // eax@1

  result = (void *)a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 160) = a2;
  }
  else
  {
    result = Memory;
    *((_DWORD *)Memory + 40) = a2;
  }
  return result;
}

//----- (10006C50) --------------------------------------------------------
void *__cdecl sub_10006C50(int a1, int a2)
{
  void *result; // eax@1

  result = (void *)a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 164) = a2;
  }
  else
  {
    result = Memory;
    *((_DWORD *)Memory + 41) = a2;
  }
  return result;
}

//----- (10006CB0) --------------------------------------------------------
int __cdecl sub_10006CB0(int a1, signed int a2)
{
  int result; // eax@1
  signed int v3; // ecx@1

  result = a1;
  v3 = *(_DWORD *)(a1 + 256);
  if ( v3 < 254 && a2 >= 1 )
  {
    if ( a2 <= 254 )
    {
      *(_BYTE *)(v3 + a1) = a2;
      ++*(_DWORD *)(a1 + 256);
    }
  }
  return result;
}

//----- (10006CE0) --------------------------------------------------------
int __cdecl sub_10006CE0(int a1, const char *a2)
{
  unsigned int v2; // edx@1
  int result; // eax@1
  int v4; // ebx@1
  int v5; // ecx@4

  v2 = strlen(a2) + 1;
  result = a1;
  v4 = *(_DWORD *)(a1 + 2048);
  if ( (signed int)v2 > 2048 - v4 )
    v2 = 2048 - v4;
  if ( v2 )
  {
    memcpy((void *)(a1 + v4), a2, v2);
    v5 = v2 + *(_DWORD *)(a1 + 2048);
    *(_DWORD *)(a1 + 2048) = v5;
    *(_BYTE *)(v5 + a1 - 1) = 0;
  }
  return result;
}

//----- (10006E80) --------------------------------------------------------
char __usercall sub_10006E80<al>(int a1<eax>, int a2<edx>, int a3)
{
  int v3; // ebp@1
  char v4; // bl@1
  int v5; // edi@1
  int v6; // esi@1
  signed int v7; // eax@2
  signed int v8; // ecx@7
  unsigned __int8 v9; // al@8
  char v11; // [sp+10h] [bp-4h]@7
  char v12; // [sp+11h] [bp-3h]@7
  char v13; // [sp+12h] [bp-2h]@7
  char v14; // [sp+13h] [bp-1h]@7

  v3 = a3;
  v4 = 0;
  v5 = 0;
  v6 = a1;
  while ( v5 < v3 )
  {
    v7 = 0;
    do
    {
      if ( v5 >= v3 )
        *((_BYTE *)&a3 + v7) = v4;
      else
        *((_BYTE *)&a3 + v7) = *(_BYTE *)a2++;
      ++v7;
      ++v5;
    }
    while ( v7 <= 2 );
    v11 = (unsigned __int8)a3 >> 2;
    v12 = (BYTE1(a3) >> 4) + 16 * (a3 & 3);
    v13 = (BYTE2(a3) >> 6) + 4 * (BYTE1(a3) & 0xF);
    v4 = 0;
    v14 = BYTE2(a3) & 0x3F;
    v8 = 0;
    do
    {
      v9 = *(&v11 + v8);
      if ( v9 >= 0x1Au )
      {
        if ( v9 >= 0x34u )
        {
          if ( v9 >= 0x3Eu )
          {
            if ( v9 == 62 )
              LOBYTE(a1) = 43;
            else
              LOBYTE(a1) = (((_BYTE)a1 != 63) - 1) & 0x2F;
          }
          else
          {
            LOBYTE(a1) = a1 - 4;
          }
        }
        else
        {
          LOBYTE(a1) = a1 + 71;
        }
      }
      else
      {
        LOBYTE(a1) = a1 + 65;
      }
      *(_BYTE *)v6++ = a1;
      ++v8;
    }
    while ( v8 <= 3 );
  }
  *(_BYTE *)v6 = v4;
  return a1;
}

//----- (10006F40) --------------------------------------------------------
signed int __usercall sub_10006F40<eax>(signed int a1<eax>, int a2, int a3, signed int a4)
{
  signed int v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@3
  int v8; // eax@3
  char *v9; // ecx@3
  signed int v10; // esi@3
  int v11; // ebx@4
  char v12; // ST13_1@4
  signed int result; // eax@5
  int v14; // ebp@5
  int v15; // esi@6
  int v16; // edi@6
  char v17; // dl@7
  char v18; // cl@7
  char v19[256]; // [sp+14h] [bp-100h]@1

  v4 = a1;
  v5 = 0;
  v6 = (int)v19;
  do
    *(_BYTE *)v6++ = v5++;
  while ( (signed __int16)v5 < 256 );
  LOBYTE(v7) = 0;
  v8 = 0;
  v9 = v19;
  v10 = 256;
  do
  {
    v11 = ((unsigned __int8)*v9 + v8 + *(_BYTE *)((unsigned __int8)v7 + a2)) & 0x800000FF;
    v7 = ((unsigned __int8)v7 + 1) % v4;
    v8 = (unsigned __int8)v11;
    v12 = *v9;
    *v9++ = v19[(unsigned __int8)v11];
    --v10;
    v19[(unsigned __int8)v11] = v12;
  }
  while ( v10 );
  result = a4;
  v14 = 0;
  if ( a4 > 0 )
  {
    LOBYTE(v15) = 0;
    LOBYTE(v16) = 0;
    result = 0;
    do
    {
      v17 = *(_BYTE *)(result + a3);
      v15 = (unsigned __int8)(*(_BYTE *)(result + a3) + v15 + 1);
      v16 = (unsigned __int8)(v16 + v19[v15]);
      v18 = v19[v15];
      v19[v15] = v19[v16];
      v19[v16] = v18;
      ++v14;
      *(_BYTE *)(result + a3) = v17 ^ v19[(unsigned __int8)(v19[v16] + v19[v15])];
      result = (signed __int16)v14;
    }
    while ( (signed __int16)v14 < a4 );
  }
  return result;
}
// 10006F40: using guessed type char var_100[256];

//----- (10007090) --------------------------------------------------------
int __usercall sub_10007090<eax>(int result<eax>, signed int a2<ebx>, int a3<edi>, int a4)
{
  char *v4; // edx@4
  char v5; // cl@5
  int v6; // eax@6
  char v7; // dl@7
  int v8; // ecx@8
  int v9; // eax@8
  char v10; // dl@9
  char v11[68]; // [sp+0h] [bp-44h]@4

  if ( a2 >= 1 && a2 <= 65 && !*(_BYTE *)(result + a2 - 1) )
  {
    v4 = &v11[-result];
    do
    {
      v5 = *(_BYTE *)result;
      v4[result] = *(_BYTE *)result;
      ++result;
    }
    while ( v5 );
    v6 = a4 + 68;
    do
      v7 = *(_BYTE *)v6++;
    while ( v7 );
    sub_10006F40(v6 - (a4 + 69), a4 + 68, (int)v11, a2 - 1);
    sub_10006E80(a3 + *(_DWORD *)(a3 + 2048), (int)v11, a2 - 1);
    v8 = *(_DWORD *)(a3 + 2048);
    v9 = v8 + a3;
    do
      v10 = *(_BYTE *)v9++;
    while ( v10 );
    result = v8 + v9 - (v8 + a3 + 1) + 1;
    *(_DWORD *)(a3 + 2048) = result;
  }
  return result;
}
// 10007090: using guessed type char var_44[68];

//----- (10007120) --------------------------------------------------------
int __usercall sub_10007120<eax>(const char *a1<edx>, int a2<esi>)
{
  int v2; // edi@1
  int result; // eax@1
  int v4; // ST0C_4@5
  u_long hostlong; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  sscanf(a1, "%08X%04X", &hostlong, &v6);
  v2 = v6;
  result = htonl(hostlong);
  hostlong = result;
  if ( result && (_WORD)v2 && (*(_DWORD *)(a2 + 268) != result || *(_WORD *)(a2 + 272) != (_WORD)v2) )
  {
    v4 = *(_DWORD *)(a2 + 276);
    *(_DWORD *)(a2 + 268) = result;
    *(_WORD *)(a2 + 272) = v2;
    result = (*(int (__cdecl **)(int, int, int))(a2 + 168))(result, v2, v4);
  }
  return result;
}

//----- (10007190) --------------------------------------------------------
void __usercall sub_10007190(int a1<ebx>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@2
  int k; // edi@8
  const char *v7; // eax@9
  int v8; // esi@12
  int v9; // eax@16
  int v10; // eax@17
  int v11; // edi@17
  int v12; // ecx@20
  int v13; // esi@21
  int v14; // edx@29
  unsigned int v15; // eax@29
  int v16; // eax@31
  int i; // [sp+8h] [bp-114h]@20
  int v18; // [sp+Ch] [bp-110h]@4
  int j; // [sp+10h] [bp-10Ch]@21
  int v20; // [sp+14h] [bp-108h]@22
  char v21[256]; // [sp+18h] [bp-104h]@8
  int v22; // [sp+118h] [bp-4h]@1

  v22 = 0;
  if ( !a4 )
    return;
  v5 = a3;
  if ( a3 == 1 || a3 == 2 )
  {
    if ( (unsigned int)(2048 - *(_DWORD *)(a2 + 2048)) < 2 )
      return;
    v18 = (*(int (__cdecl **)(int, _DWORD))(a1 + 152))(a3, *(_DWORD *)(a1 + 276));
    *(_WORD *)(*(_DWORD *)(a2 + 2048) + a2) = htons(v18);
    *(_DWORD *)(a2 + 2048) += 2;
  }
  else
  {
    v18 = 1;
  }
  if ( a4 != 255 )
  {
    v11 = a5;
LABEL_20:
    v12 = 0;
    for ( i = 0; v12 < v18; i = v12 )
    {
      v13 = 0;
      for ( j = 0; v13 < a4; j = v13 )
      {
        v20 = *(_DWORD *)(a2 + 2048);
        if ( a3 )
        {
          if ( a3 == 1 )
          {
            (*(void (__cdecl **)(_DWORD, int, int, _DWORD))(a1 + 140))(
              *(_BYTE *)(v13 + v11),
              v12,
              a2,
              *(_DWORD *)(a1 + 276));
          }
          else
          {
            if ( a3 == 2 )
              (*(void (__cdecl **)(_DWORD, int, int, _DWORD))(a1 + 144))(
                *(_BYTE *)(v13 + v11),
                v12,
                a2,
                *(_DWORD *)(a1 + 276));
          }
        }
        else
        {
          (*(void (__cdecl **)(_DWORD, int, _DWORD))(a1 + 136))(*(_BYTE *)(v13 + v11), a2, *(_DWORD *)(a1 + 276));
        }
        if ( v20 == *(_DWORD *)(a2 + 2048) )
        {
          v14 = *(_DWORD *)(a2 + 2048);
          v15 = 1;
          if ( 2048 - v14 >= 1 || (v15 = 2048 - v14, 2048 != v14) )
          {
            memcpy((void *)(a2 + *(_DWORD *)(a2 + 2048)), &unk_1000E7EB, v15);
            v11 = a5;
            v13 = j;
            v16 = v15 + *(_DWORD *)(a2 + 2048);
            *(_DWORD *)(a2 + 2048) = v16;
            *(_BYTE *)(v16 + a2 - 1) = 0;
          }
        }
        v12 = i;
        ++v13;
      }
      ++v12;
    }
    return;
  }
  (*(void (__cdecl **)(int, _DWORD, _DWORD))(a1 + 148))(a3, v21, *(_DWORD *)(a1 + 276));
  for ( k = 0; k < v22; ++k )
  {
    v7 = (const char *)*(&off_100110A0 + (unsigned __int8)v21[k]);
    if ( !v7 )
      v7 = "unknown";
    sub_10006CE0(a2, v7);
    if ( !v5 )
    {
      v8 = *(_DWORD *)(a2 + 2048);
      (*(void (__cdecl **)(_DWORD, int, _DWORD))(a1 + 136))((unsigned __int8)v21[k], a2, *(_DWORD *)(a1 + 276));
      if ( v8 == *(_DWORD *)(a2 + 2048) )
        sub_10006CE0(a2, (const char *)&unk_1000E7EB);
      v5 = a3;
    }
  }
  v9 = *(_DWORD *)(a2 + 2048);
  if ( 2048 - v9 >= 1 )
  {
    *(_BYTE *)(v9 + a2) = 0;
    v10 = v22;
    v11 = (int)v21;
    ++*(_DWORD *)(a2 + 2048);
    a4 = v10;
    a5 = (int)v21;
    if ( v5 )
      goto LABEL_20;
  }
}
// 100110A0: using guessed type void *off_100110A0;
// 10007190: using guessed type char var_104[256];

//----- (10007440) --------------------------------------------------------
void __usercall sub_10007440(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<esi>, int a5, int a6, int a7, int a8)
{
  int v8; // ebx@1

  v8 = a2;
  sub_10007190(a2, a4, 0, a3, a1);
  sub_10007190(v8, a4, 1, a5, a6);
  sub_10007190(v8, a4, 2, a7, a8);
}

//----- (10007480) --------------------------------------------------------
void __fastcall sub_10007480(unsigned __int8 *a1, signed int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // ebp@1
  unsigned __int8 v6; // al@2
  int v7; // ecx@2
  int v8; // edx@2
  unsigned __int8 v9; // al@6
  int v10; // ecx@6
  int v11; // edx@6
  unsigned __int8 v12; // bl@10
  int v13; // edx@10
  unsigned __int8 v14; // [sp+Bh] [bp-5h]@2
  int v15; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v15 = 0;
  if ( a2 >= 3 )
  {
    v6 = *a1;
    v7 = (int)(a1 + 1);
    v8 = a2 - 1;
    v14 = v6;
    if ( v6 && v6 != -1 )
    {
      v5 = v7;
      v7 += v6;
      v8 -= v6;
    }
    if ( v8 >= 2 )
    {
      v9 = *(_BYTE *)v7;
      v10 = v7 + 1;
      v11 = v8 - 1;
      if ( v9 && v9 != -1 )
      {
        v4 = v10;
        v10 += v9;
        v11 -= v9;
      }
      if ( v11 >= 1 )
      {
        v12 = *(_BYTE *)v10;
        v13 = v11 - 1;
        if ( *(_BYTE *)v10 && v12 != -1 )
        {
          v15 = v10 + 1;
          v13 -= v12;
        }
        if ( v13 >= 0 )
          sub_10007440(v5, a3, v14, a4, v9, v4, v12, v15);
      }
    }
  }
}

//----- (10007520) --------------------------------------------------------
int __cdecl sub_10007520(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // edi@3
  int result; // eax@5
  const char *v7; // eax@8
  int v8; // esi@11
  int i; // ebx@14
  char *v10; // eax@15
  char v11; // cl@16
  int v12; // esi@17
  unsigned int v13; // edx@17
  int v14; // eax@20
  int v15; // esi@21
  int v16; // esi@26
  unsigned int v17; // eax@26
  int v18; // ecx@28
  int v19; // [sp+10h] [bp-190h]@5
  int v20; // [sp+14h] [bp-18Ch]@3
  int v21; // [sp+18h] [bp-188h]@8
  char v22[256]; // [sp+1Ch] [bp-184h]@5
  int v23; // [sp+11Ch] [bp-84h]@1
  char Dest; // [sp+120h] [bp-80h]@15
  _BYTE v25[3]; // [sp+121h] [bp-7Fh]@17

  v3 = a3;
  v4 = 0;
  v23 = 0;
  if ( a3 == 1 || a3 == 2 )
  {
    v5 = a1;
    v20 = (*(int (__cdecl **)(int, _DWORD))(a1 + 152))(a3, *(_DWORD *)(a1 + 276));
  }
  else
  {
    v5 = a1;
    v20 = 1;
  }
  (*(void (__cdecl **)(int, _DWORD, _DWORD))(v5 + 148))(a3, v22, *(_DWORD *)(v5 + 276));
  result = v23;
  v19 = 0;
  if ( v23 > 0 )
  {
    while ( 1 )
    {
      v7 = (const char *)*(&off_100110A0 + (unsigned __int8)v22[v4]);
      v21 = (int)*(&off_100110A0 + (unsigned __int8)v22[v4]);
      if ( !v7 )
      {
        v21 = (int)"unknown";
        v7 = "unknown";
      }
      if ( v3 )
      {
        for ( i = 0; i < v20; ++i )
        {
          sprintf(&Dest, "%s%d", v21, i);
          v10 = &Dest;
          do
            v11 = *v10++;
          while ( v11 );
          v12 = *(_DWORD *)(a2 + 2048);
          v13 = v10 - v25 + 1;
          if ( (signed int)v13 > 2048 - v12 )
            v13 = 2048 - v12;
          if ( v13 )
          {
            memcpy((void *)(a2 + *(_DWORD *)(a2 + 2048)), &Dest, v13);
            v5 = a1;
            v14 = v13 + *(_DWORD *)(a2 + 2048);
            *(_DWORD *)(a2 + 2048) = v14;
            *(_BYTE *)(v14 + a2 - 1) = 0;
          }
          *(_BYTE *)(*(_DWORD *)(a2 + 2048) + a2 - 1) = 92;
          v15 = *(_DWORD *)(a2 + 2048);
          if ( a3 == 1 )
          {
            (*(void (__cdecl **)(_DWORD, int, int, _DWORD))(v5 + 140))(
              (unsigned __int8)v22[v19],
              i,
              a2,
              *(_DWORD *)(v5 + 276));
          }
          else
          {
            if ( a3 == 2 )
              (*(void (__cdecl **)(_DWORD, int, int, _DWORD))(v5 + 144))(
                (unsigned __int8)v22[v19],
                i,
                a2,
                *(_DWORD *)(v5 + 276));
          }
          if ( v15 == *(_DWORD *)(a2 + 2048) )
          {
            v16 = *(_DWORD *)(a2 + 2048);
            v17 = 1;
            if ( 2048 - v16 >= 1 || (v17 = 2048 - v16, 2048 != v16) )
            {
              memcpy((void *)(a2 + *(_DWORD *)(a2 + 2048)), &unk_1000E7EB, v17);
              v5 = a1;
              v18 = v17 + *(_DWORD *)(a2 + 2048);
              *(_DWORD *)(a2 + 2048) = v18;
              *(_BYTE *)(v18 + a2 - 1) = 0;
            }
          }
          *(_BYTE *)(*(_DWORD *)(a2 + 2048) + a2 - 1) = 92;
        }
        v4 = v19;
      }
      else
      {
        sub_10006CE0(a2, v7);
        *(_BYTE *)(*(_DWORD *)(a2 + 2048) + a2 - 1) = 92;
        v8 = *(_DWORD *)(a2 + 2048);
        (*(void (__cdecl **)(_DWORD, int, _DWORD))(v5 + 136))((unsigned __int8)v22[v4], a2, *(_DWORD *)(v5 + 276));
        if ( v8 == *(_DWORD *)(a2 + 2048) )
          sub_10006CE0(a2, (const char *)&unk_1000E7EB);
        *(_BYTE *)(*(_DWORD *)(a2 + 2048) + a2 - 1) = 92;
      }
      result = v23;
      ++v4;
      v19 = v4;
      if ( v4 >= v23 )
        break;
      v3 = a3;
    }
  }
  return result;
}
// 100110A0: using guessed type void *off_100110A0;
// 10007520: using guessed type char var_184[256];

//----- (100077C0) --------------------------------------------------------
int __usercall sub_100077C0<eax>(int a1<edi>, int a2<esi>)
{
  int result; // eax@1

  *(_DWORD *)(a2 + 2048) = 1;
  *(_BYTE *)a2 = 92;
  sub_10007520(a1, a2, 0);
  sub_10007520(a1, a2, 1);
  sub_10007520(a1, a2, 2);
  sub_10006CE0(a2, "final\\\\queryid\\1.1");
  result = *(_DWORD *)(a2 + 2048) - 1;
  *(_DWORD *)(a2 + 2048) = result;
  return result;
}

//----- (10007810) --------------------------------------------------------
u_long __usercall sub_10007810<eax>(signed int a1<edx>, int a2<edi>, int a3)
{
  signed int v3; // ecx@2
  u_long result; // eax@5
  int v5; // ST08_4@6
  u_long v6; // eax@6
  char v7; // [sp+Ch] [bp-8h]@1
  char v8; // [sp+Dh] [bp-7h]@1
  char v9; // [sp+Eh] [bp-6h]@1
  char v10; // [sp+Fh] [bp-5h]@1
  char v11; // [sp+10h] [bp-4h]@1
  char v12; // [sp+11h] [bp-3h]@1

  v7 = -3;
  v8 = -4;
  v9 = 30;
  v10 = 102;
  v11 = 106;
  v12 = -78;
  if ( a1 >= 10 )
  {
    v3 = 0;
    while ( *(&v7 + v3 + a3 - (_DWORD)&v7) == *(&v7 + v3) )
    {
      ++v3;
      if ( v3 >= 6 )
      {
        result = *(_DWORD *)(a3 + 6);
        if ( *(_DWORD *)(a2 + 160) )
        {
          v5 = *(_DWORD *)(a2 + 276);
          v6 = ntohl(result);
          result = (*(int (__cdecl **)(u_long, int))(a2 + 160))(v6, v5);
        }
        return result;
      }
    }
  }
  result = *(_DWORD *)(a2 + 164);
  if ( result )
    result = ((int (__cdecl *)(int, signed int, _DWORD))result)(a3, a1, *(_DWORD *)(a2 + 276));
  return result;
}

//----- (100078B0) --------------------------------------------------------
signed int __usercall sub_100078B0<eax>(int a1<edi>, int a2<esi>)
{
  signed int v2; // eax@1
  int v3; // ecx@1
  int v4; // edx@4
  signed int result; // eax@4

  v2 = 0;
  v3 = a2 + 224;
  while ( *(_DWORD *)v3 != a1 )
  {
    ++v2;
    v3 += 4;
    if ( v2 >= 10 )
    {
      v4 = (*(_DWORD *)(a2 + 264) + 1) % 10;
      result = 0;
      *(_DWORD *)(a2 + 264) = v4;
      *(_DWORD *)(a2 + 4 * v4 + 224) = a1;
      return result;
    }
  }
  return 1;
}

//----- (100078F0) --------------------------------------------------------
int __cdecl sub_100078F0(void *a1, int a2, signed int a3, const struct sockaddr *to)
{
  int v4; // ebx@1
  int result; // eax@3
  char v6; // cl@3
  int (__cdecl *v7)(_DWORD, _DWORD, _DWORD); // ebx@4
  int v8; // edx@13
  int v9; // esi@13
  unsigned __int8 *v10; // edi@13
  signed int v11; // edi@23
  int v12; // ST14_4@27
  signed int v13; // edi@28
  int v14; // edi@32
  int v15; // [sp+Ch] [bp-80Ch]@13
  char buf; // [sp+10h] [bp-808h]@7
  int v17; // [sp+11h] [bp-807h]@13
  int v18; // [sp+15h] [bp-803h]@21
  int len; // [sp+810h] [bp-8h]@1
  int v20; // [sp+828h] [bp+10h]@13

  v4 = (int)a1;
  len = 0;
  if ( !a1 )
  {
    a1 = Memory;
    v4 = (int)Memory;
  }
  result = a2;
  v6 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 == 59 )
  {
    v7 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(v4 + 220);
    if ( v7 )
      result = v7(a2, a3, to);
  }
  else
  {
    if ( v6 == 92 )
    {
      sub_100077C0(v4, (int)&buf);
      result = sendto(*(_DWORD *)v4, &buf, len, 0, to, 16);
    }
    else
    {
      if ( a3 >= 7 && v6 == -2 && *(_BYTE *)(a2 + 1) == -3 )
      {
        if ( *(_DWORD *)(v4 + 184) > 0 )
          *(_DWORD *)(v4 + 184) = 0;
        v8 = *(_DWORD *)(a2 + 3);
        buf = *(_BYTE *)(a2 + 2);
        v9 = a3 - 7;
        v17 = v8;
        v10 = (unsigned __int8 *)(a2 + 7);
        v15 = a2 + 7;
        v20 = a3 - 7;
        len = 5;
        switch ( buf )
        {
          case 0:
            sub_10007480(v10, v9, v4, (int)&buf);
            goto LABEL_34;
          case 1:
            if ( v9 >= 13 && *(_DWORD *)(v4 + 168) )
              sub_10007120((const char *)&v10[v9 - 13], v4);
            sub_10007090(v15, v9, (int)&buf, v4);
            v4 = (int)a1;
            goto LABEL_34;
          case 2:
            if ( v9 > 32 )
            {
              v20 = 32;
              v9 = 32;
            }
            buf = 5;
            memcpy(&v18, v10, v9);
            len += v20;
            goto LABEL_34;
          case 4:
            if ( *(_DWORD *)(v4 + 184) == -1 )
              return result;
            v11 = 0;
            while ( *(_BYTE *)(v11 + a2 + 3) == *(_BYTE *)(v4 + v11 + 132) )
            {
              ++v11;
              if ( v11 >= 4 )
              {
                if ( v9 >= 2 )
                {
                  v12 = *(_DWORD *)(v4 + 276);
                  *(_DWORD *)(v4 + 184) = -1;
                  result = (*(int (__cdecl **)(_DWORD, int, int))(v4 + 156))(*(_BYTE *)(a2 + 7), a2 + 8, v12);
                }
                return result;
              }
            }
            return result;
          case 6:
            v13 = 0;
            break;
          default:
            return result;
        }
        while ( *(_BYTE *)(v13 + a2 + 3) == *(_BYTE *)(v4 + v13 + 132) )
        {
          ++v13;
          if ( v13 >= 4 )
          {
            if ( v9 >= 4 )
            {
              v14 = *(_DWORD *)v15;
              buf = 7;
              v18 = v14;
              len = 9;
              if ( !sub_100078B0(v14, v4) )
                sub_10007810(v9 - 4, v4, a2 + 11);
LABEL_34:
              result = sendto(*(_DWORD *)v4, &buf, len, 0, to, 16);
            }
            return result;
          }
        }
      }
    }
  }
  return result;
}

//----- (10007BC0) --------------------------------------------------------
DWORD __usercall sub_10007BC0<eax>(int a1<esi>)
{
  SOCKET v1; // ST00_4@1
  DWORD result; // eax@1
  char buf; // [sp+0h] [bp-804h]@1
  int v4; // [sp+1h] [bp-803h]@1
  int v5; // [sp+800h] [bp-4h]@1

  v4 = *(_DWORD *)(a1 + 132);
  v1 = *(_DWORD *)a1;
  buf = 8;
  v5 = 5;
  sendto(v1, &buf, 5, 0, (const struct sockaddr *)(a1 + 204), 16);
  result = GetTickCount();
  *(_DWORD *)(a1 + 176) = result;
  return result;
}

//----- (10007C10) --------------------------------------------------------
signed int __cdecl sub_10007C10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  void *v14; // ebp@2
  void *v15; // eax@3
  unsigned int v16; // eax@4
  int v17; // eax@4
  char v18; // cl@5
  int v19; // eax@6
  char v20; // cl@7
  signed int v21; // esi@8
  struct hostent *v22; // eax@11
  signed int v23; // ecx@12
  char *v24; // edx@13
  char *v25; // ebx@18
  int v26; // edi@24
  char *v27; // esi@24
  signed int v28; // ecx@24
  bool v29; // zf@24
  struct hostent *v30; // eax@28
  char name; // [sp+10h] [bp-40h]@18

  if ( a1 )
  {
    v15 = malloc(0x118u);
    *(_DWORD *)a1 = v15;
    v14 = v15;
  }
  else
  {
    v14 = &unk_100114A0;
  }
  v16 = GetTickCount();
  srand(v16);
  v17 = a4;
  do
  {
    v18 = *(_BYTE *)v17;
    *((_BYTE *)v14 + v17 - a4 + 4) = *(_BYTE *)v17;
    ++v17;
  }
  while ( v18 );
  v19 = a5;
  do
  {
    v20 = *(_BYTE *)v19;
    *((_BYTE *)v14 + v19 - a5 + 68) = *(_BYTE *)v19;
    ++v19;
  }
  while ( v20 );
  *((_DWORD *)v14 + 48) = a3;
  *(_DWORD *)v14 = a2;
  *((_DWORD *)v14 + 69) = a14;
  *((_DWORD *)v14 + 34) = a8;
  *((_DWORD *)v14 + 35) = a9;
  *((_DWORD *)v14 + 36) = a10;
  *((_DWORD *)v14 + 37) = a11;
  *((_DWORD *)v14 + 38) = a12;
  *((_DWORD *)v14 + 43) = 0;
  *((_DWORD *)v14 + 44) = 0;
  *((_DWORD *)v14 + 46) = 1;
  *((_DWORD *)v14 + 39) = a13;
  *((_DWORD *)v14 + 40) = 0;
  *((_DWORD *)v14 + 41) = 0;
  *((_DWORD *)v14 + 55) = 0;
  *((_DWORD *)v14 + 47) = a6;
  *((_DWORD *)v14 + 49) = 0;
  *((_DWORD *)v14 + 50) = a7;
  *((_DWORD *)v14 + 67) = 0;
  *((_WORD *)v14 + 136) = 0;
  *((_DWORD *)v14 + 42) = 0;
  *((_DWORD *)v14 + 45) = 0;
  v21 = 0;
  do
  {
    ++v21;
    *((_BYTE *)v14 + v21 + 131) = rand() % 255;
  }
  while ( v21 < 4 );
  v29 = dword_10011F50 == 0;
  *((_DWORD *)v14 + 56) = -1;
  *((_DWORD *)v14 + 57) = -1;
  *((_DWORD *)v14 + 58) = -1;
  *((_DWORD *)v14 + 59) = -1;
  *((_DWORD *)v14 + 60) = -1;
  *((_DWORD *)v14 + 61) = -1;
  *((_DWORD *)v14 + 62) = -1;
  *((_DWORD *)v14 + 63) = -1;
  *((_DWORD *)v14 + 64) = -1;
  *((_DWORD *)v14 + 65) = -1;
  *((_DWORD *)v14 + 66) = 0;
  if ( v29 )
  {
    v22 = sub_10004B40();
    if ( v22 )
    {
      v23 = 0;
      dword_10011F50 = 0;
      do
      {
        v24 = v22->h_addr_list[v23];
        if ( !v24 )
          break;
        dword_10011E38[v23++] = *(_DWORD *)v24;
      }
      while ( v23 < 5 );
      dword_10011F50 = v23;
    }
  }
  if ( !a6 )
    return 0;
  if ( byte_10011F60 )
  {
    v25 = &byte_10011F60;
  }
  else
  {
    sprintf(&name, "%s.master.gamespy.com", a4);
    v25 = &name;
  }
  *((_WORD *)v14 + 102) = 2;
  *((_WORD *)v14 + 103) = htons(0x6CFCu);
  if ( v25 )
    *((_DWORD *)v14 + 52) = inet_addr(v25);
  else
    *((_DWORD *)v14 + 52) = 0;
  if ( *((_DWORD *)v14 + 52) != -1 )
    goto LABEL_30;
  v26 = (int)"255.255.255.255";
  v27 = v25;
  v28 = 16;
  v29 = 1;
  do
  {
    if ( !v28 )
      break;
    v29 = *v27++ == *(_BYTE *)v26++;
    --v28;
  }
  while ( v29 );
  if ( v29 )
  {
LABEL_30:
    inet_ntoa(*((struct in_addr *)v14 + 52));
    return 0;
  }
  v30 = gethostbyname(v25);
  if ( v30 )
  {
    *((_DWORD *)v14 + 52) = **(_DWORD **)v30->h_addr_list;
    goto LABEL_30;
  }
  return 3;
}
// 10011E38: using guessed type int dword_10011E38[];
// 10011F50: using guessed type int dword_10011F50;
// 10011F60: using guessed type char byte_10011F60;

//----- (10007F40) --------------------------------------------------------
signed int __cdecl sub_10007F40(int a1, const char *name, int *a3)
{
  int v3; // ebx@1
  SOCKET v4; // esi@1
  int v6; // edi@7
  const char *v7; // esi@7
  signed int v8; // ecx@7
  bool v9; // zf@7
  struct hostent *v10; // eax@11
  u_long v11; // eax@14
  SOCKET v12; // [sp+8h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-18h]@3
  int namelen; // [sp+10h] [bp-14h]@20
  __int16 v15; // [sp+14h] [bp-10h]@4
  u_short netshort[2]; // [sp+16h] [bp-Eh]@4

  v3 = *a3;
  sub_10004740();
  v4 = socket(2, 2, 17);
  v12 = v4;
  if ( v4 == -1 )
    return 1;
  v13 = v3 + 100;
  if ( __OFSUB__(v3, v3 + 100) ^ 1 )
  {
    while ( 1 )
    {
      v15 = 2;
      netshort[0] = htons(v3);
      if ( name )
      {
        *(_DWORD *)&netshort[1] = inet_addr(name);
        if ( *(_DWORD *)&netshort[1] == -1 )
        {
          v6 = (int)"255.255.255.255";
          v7 = name;
          v8 = 16;
          v9 = 1;
          do
          {
            if ( !v8 )
              break;
            v9 = *v7++ == *(_BYTE *)v6++;
            --v8;
          }
          while ( v9 );
          if ( !v9 )
          {
            v10 = gethostbyname(name);
            if ( v10 )
              *(_DWORD *)&netshort[1] = **(_DWORD **)v10->h_addr_list;
          }
          v4 = v12;
        }
      }
      else
      {
        *(_DWORD *)&netshort[1] = 0;
      }
      v11 = htonl(0x7F000001u);
      if ( *(_DWORD *)&netshort[1] == v11 )
        *(_DWORD *)&netshort[1] = 0;
      if ( !bind(v4, (const struct sockaddr *)&v15, 16) )
        break;
      ++v3;
      if ( v3 >= v13 )
        return 2;
    }
  }
  if ( !v3 )
  {
    namelen = 16;
    if ( getsockname(v4, (struct sockaddr *)&v15, &namelen) )
      return 2;
    v3 = ntohs(netshort[0]);
  }
  *(_DWORD *)a1 = v4;
  *a3 = v3;
  return 0;
}

//----- (10008070) --------------------------------------------------------
signed int __thiscall sub_10008070(int this, int a2, const char *name, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15)
{
  signed int v15; // esi@1
  signed int result; // eax@2
  void **v17; // esi@3
  int v18; // [sp+0h] [bp-4h]@1

  v18 = this;
  v15 = sub_10007F40((int)&v18, name, &a4);
  if ( v15 )
  {
    j_WSACleanup();
    result = v15;
  }
  else
  {
    v17 = (void **)a2;
    result = sub_10007C10(a2, v18, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    if ( !a2 )
      v17 = &Memory;
    *((_DWORD *)*v17 + 49) = 1;
  }
  return result;
}

//----- (100081D0) --------------------------------------------------------
int __usercall sub_100081D0<eax>(int a1<esi>)
{
  int result; // eax@1
  int v2; // eax@3
  int v3; // [sp+0h] [bp-14h]@1
  struct sockaddr from; // [sp+4h] [bp-10h]@3

  result = *(_DWORD *)(a1 + 196);
  v3 = 16;
  if ( result )
  {
    for ( result = sub_10004A40(*(_DWORD *)a1); result; result = sub_10004A40(*(_DWORD *)a1) )
    {
      v2 = recvfrom(*(_DWORD *)a1, &byte_10011E50, 255, 0, &from, &v3);
      if ( v2 != -1 )
      {
        *(&byte_10011E50 + v2) = 0;
        sub_100078F0((void *)a1, (int)&byte_10011E50, v2, &from);
      }
    }
  }
  return result;
}

//----- (10008250) --------------------------------------------------------
int __cdecl sub_10008250(int a1, int a2)
{
  char Dest; // [sp+0h] [bp-14h]@1

  sprintf(&Dest, "%d", a2);
  return sub_10006CE0(a1, &Dest);
}

//----- (10008280) --------------------------------------------------------
DWORD __cdecl sub_10008280(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // ebp@1
  struct in_addr *v5; // ebx@2
  char *v6; // eax@3
  char v7; // cl@4
  unsigned int v8; // eax@5
  char *v9; // eax@9
  unsigned int v10; // edx@9
  unsigned int v11; // eax@14
  char *v12; // eax@17
  char v13; // cl@18
  unsigned int v14; // edx@19
  int v15; // eax@19
  int v16; // eax@22
  unsigned int v17; // edx@23
  int v18; // eax@25
  const char *v19; // esi@26
  unsigned int v20; // edx@28
  int v21; // eax@31
  unsigned int v22; // edx@33
  void (*v23)(char *, const char *, ...); // ebp@36
  char *v24; // eax@36
  char v25; // cl@37
  unsigned int v26; // edx@38
  int v27; // eax@41
  unsigned int v28; // edx@43
  int v29; // eax@45
  int v30; // ecx@46
  char v31; // dl@47
  unsigned int v32; // edx@48
  int v33; // eax@51
  unsigned int v34; // edx@53
  char *v35; // eax@56
  char v36; // cl@57
  int v37; // edx@58
  unsigned int v38; // eax@58
  unsigned int v39; // eax@62
  char *v40; // eax@65
  char v41; // cl@66
  unsigned int v42; // edx@67
  int v43; // eax@70
  DWORD result; // eax@75
  char v45; // [sp+10h] [bp-82Ch]@17
  _BYTE v46[3]; // [sp+11h] [bp-82Bh]@19
  char Dest; // [sp+24h] [bp-818h]@3
  _BYTE v48[3]; // [sp+25h] [bp-817h]@5
  char v49; // [sp+37h] [bp-805h]@8
  char buf; // [sp+38h] [bp-804h]@1
  int v51; // [sp+39h] [bp-803h]@1
  int len; // [sp+838h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 132);
  v3 = 5;
  v4 = 0;
  buf = 3;
  v51 = v2;
  len = 5;
  if ( dword_10011F50 > 0 )
  {
    v5 = (struct in_addr *)dword_10011E38;
    do
    {
      sprintf(&Dest, "localip%d", v4);
      v6 = &Dest;
      do
        v7 = *v6++;
      while ( v7 );
      v8 = v6 - v48 + 1;
      if ( (signed int)v8 > 2048 - len )
        v8 = 2048 - len;
      if ( v8 )
      {
        memcpy(&buf + len, &Dest, v8);
        len += v8;
        *(&v49 + len) = 0;
      }
      v9 = inet_ntoa(*v5);
      v3 = len;
      v10 = strlen(v9) + 1;
      if ( (signed int)v10 > 2048 - len )
        v10 = 2048 - len;
      if ( v10 )
      {
        memcpy(&buf + len, v9, v10);
        len += v10;
        *(&v49 + len) = 0;
        v3 = len;
      }
      ++v4;
      ++v5;
    }
    while ( v4 < dword_10011F50 );
  }
  v11 = 10;
  if ( 2048 - v3 >= 10 || (v11 = 2048 - v3, 2048 != v3) )
  {
    memcpy(&buf + v3, "localport", v11);
    len += v11;
    *(&v49 + len) = 0;
  }
  sprintf(&v45, "%d", *(_DWORD *)(a1 + 192));
  v12 = &v45;
  do
    v13 = *v12++;
  while ( v13 );
  v14 = v12 - v46 + 1;
  v15 = len;
  if ( (signed int)v14 > 2048 - len )
    v14 = 2048 - len;
  if ( v14 )
  {
    memcpy(&buf + len, &v45, v14);
    v16 = v14 + len;
    len = v16;
    *(&v49 + v16) = 0;
    v15 = len;
  }
  v17 = 7;
  if ( 2048 - v15 >= 7 || (v17 = 2048 - v15, 2048 != v15) )
  {
    memcpy(&buf + v15, "natneg", v17);
    v18 = v17 + len;
    len = v18;
    *(&v49 + v18) = 0;
    v15 = len;
  }
  v19 = "1";
  if ( !*(_DWORD *)(a1 + 200) )
    v19 = "0";
  v20 = strlen(v19) + 1;
  if ( (signed int)v20 > 2048 - v15 )
    v20 = 2048 - v15;
  if ( v20 )
  {
    memcpy(&buf + v15, v19, v20);
    v21 = v20 + len;
    len = v21;
    *(&v49 + v21) = 0;
    v15 = len;
  }
  if ( a2 )
  {
    v22 = 13;
    if ( 2048 - v15 >= 13 || (v22 = 2048 - v15, 2048 != v15) )
    {
      memcpy(&buf + v15, "statechanged", v22);
      len += v22;
      *(&v49 + len) = 0;
    }
    v23 = sprintf;
    sprintf(&v45, "%d", a2);
    v24 = &v45;
    do
      v25 = *v24++;
    while ( v25 );
    v26 = v24 - v46 + 1;
    v15 = len;
    if ( (signed int)v26 > 2048 - len )
      v26 = 2048 - len;
    if ( v26 )
    {
      memcpy(&buf + len, &v45, v26);
      v27 = v26 + len;
      len = v27;
      *(&v49 + v27) = 0;
      v15 = len;
    }
  }
  else
  {
    v23 = sprintf;
  }
  v28 = 9;
  if ( 2048 - v15 >= 9 || (v28 = 2048 - v15, 2048 != v15) )
  {
    memcpy(&buf + v15, "gamename", v28);
    v29 = v28 + len;
    len = v29;
    *(&v49 + v29) = 0;
    v15 = len;
  }
  v30 = a1 + 4;
  do
    v31 = *(_BYTE *)v30++;
  while ( v31 );
  v32 = v30 - (a1 + 5) + 1;
  if ( (signed int)v32 > 2048 - v15 )
    v32 = 2048 - v15;
  if ( v32 )
  {
    memcpy(&buf + v15, (const void *)(a1 + 4), v32);
    v33 = v32 + len;
    len = v33;
    *(&v49 + v33) = 0;
    v15 = len;
  }
  if ( *(_DWORD *)(a1 + 168) )
  {
    v34 = 9;
    if ( 2048 - v15 >= 9 || (v34 = 2048 - v15, 2048 != v15) )
    {
      memcpy(&buf + v15, "publicip", v34);
      len += v34;
      *(&v49 + len) = 0;
    }
    v23(&v45, "%d", *(_DWORD *)(a1 + 268));
    v35 = &v45;
    do
      v36 = *v35++;
    while ( v36 );
    v37 = len;
    v38 = v35 - v46 + 1;
    if ( (signed int)v38 > 2048 - len )
      v38 = 2048 - len;
    if ( v38 )
    {
      memcpy(&buf + len, &v45, v38);
      len += v38;
      *(&v49 + len) = 0;
      v37 = len;
    }
    v39 = 11;
    if ( 2048 - v37 >= 11 || (v39 = 2048 - v37, 2048 != v37) )
    {
      memcpy(&buf + v37, "publicport", v39);
      len += v39;
      *(&v49 + len) = 0;
    }
    v23(&v45, "%d", *(_WORD *)(a1 + 272));
    v40 = &v45;
    do
      v41 = *v40++;
    while ( v41 );
    v42 = v40 - v46 + 1;
    v15 = len;
    if ( (signed int)v42 > 2048 - len )
      v42 = 2048 - len;
    if ( v42 )
    {
      memcpy(&buf + len, &v45, v42);
      v43 = v42 + len;
      len = v43;
      *(&v49 + v43) = 0;
      v15 = len;
    }
  }
  if ( a2 == 2 )
  {
    if ( 2048 - v15 >= 1 )
    {
      *(&buf + v15) = 0;
      v15 = len++ + 1;
    }
  }
  else
  {
    sub_10007190(a1, (int)&buf, 0, 255, 0);
    sub_10007190(a1, (int)&buf, 1, 255, 0);
    sub_10007190(a1, (int)&buf, 2, 255, 0);
    v15 = len;
  }
  sendto(*(_DWORD *)a1, &buf, v15, 0, (const struct sockaddr *)(a1 + 204), 16);
  result = GetTickCount();
  *(_DWORD *)(a1 + 172) = result;
  *(_DWORD *)(a1 + 176) = result;
  if ( a2 )
    *(_DWORD *)(a1 + 180) = 0;
  return result;
}
// 10011E38: using guessed type int dword_10011E38[];
// 10011F50: using guessed type int dword_10011F50;

//----- (100088E0) --------------------------------------------------------
DWORD __usercall sub_100088E0<eax>(int a1<eax>)
{
  int v1; // esi@1
  DWORD result; // eax@1
  DWORD v3; // edi@1
  signed int v4; // eax@2
  int v5; // ST08_4@5
  int v6; // [sp-4h] [bp-Ch]@9

  v1 = a1;
  result = GetTickCount();
  v3 = result;
  if ( *(_DWORD *)v1 != -1 )
  {
    v4 = *(_DWORD *)(v1 + 184);
    if ( v4 > 0 && v3 - *(_DWORD *)(v1 + 172) > 0x2710 )
    {
      if ( v4 >= 4 )
      {
        v5 = *(_DWORD *)(v1 + 276);
        *(_DWORD *)(v1 + 184) = 0;
        return (*(int (__cdecl **)(signed int, _DWORD, int))(v1 + 156))(
                 5,
                 "No challenge value was received from the master server.",
                 v5);
      }
      sub_10008280(v1, 3);
      result = *(_DWORD *)(v1 + 184) + 1;
      *(_DWORD *)(v1 + 184) = result;
      goto LABEL_15;
    }
    if ( *(_DWORD *)(v1 + 180) && v3 - *(_DWORD *)(v1 + 172) > 0x2710 )
    {
      v6 = 1;
    }
    else
    {
      result = *(_DWORD *)(v1 + 172);
      if ( v3 - result <= 0xEA60 && result && v3 >= result )
        goto LABEL_15;
      v6 = 0;
    }
    result = sub_10008280(v1, v6);
LABEL_15:
    if ( v3 - *(_DWORD *)(v1 + 176) > 0x4E20 )
      result = sub_10007BC0(v1);
  }
  return result;
}

//----- (100089B0) --------------------------------------------------------
DWORD __cdecl sub_100089B0(int a1)
{
  int v1; // esi@1
  DWORD result; // eax@3

  v1 = a1;
  if ( !a1 )
    v1 = (int)Memory;
  result = *(_DWORD *)(v1 + 188);
  if ( result )
  {
    result = GetTickCount() - *(_DWORD *)(v1 + 172);
    if ( result >= 0x2710 )
    {
      result = sub_10008280(v1, 1);
      *(_DWORD *)(v1 + 180) = 0;
    }
    else
    {
      *(_DWORD *)(v1 + 180) = 1;
    }
  }
  return result;
}

//----- (10008A00) --------------------------------------------------------
void __cdecl sub_10008A00(int a1)
{
  int v1; // esi@1
  int v2; // eax@8

  v1 = a1;
  if ( !a1 )
    v1 = (int)Memory;
  if ( *(_DWORD *)(v1 + 188) )
    sub_10008280(v1, 2);
  if ( *(_DWORD *)v1 != -1 && *(_DWORD *)(v1 + 196) )
    closesocket(*(_DWORD *)v1);
  v2 = *(_DWORD *)(v1 + 196);
  *(_DWORD *)v1 = -1;
  *(_DWORD *)(v1 + 172) = 0;
  if ( v2 )
    j_WSACleanup();
  if ( (_UNKNOWN *)v1 != &unk_100114A0 )
    free((void *)v1);
}

//----- (10008A70) --------------------------------------------------------
int __cdecl sub_10008A70(int a1)
{
  int v1; // esi@1

  v1 = a1;
  if ( !a1 )
    v1 = (int)Memory;
  if ( *(_DWORD *)(v1 + 188) )
    sub_100088E0(v1);
  return sub_100081D0(v1);
}

//----- (10008AA0) --------------------------------------------------------
int __cdecl sub_10008AA0(const char *a1, const char *a2, int a3)
{
  int result; // eax@1
  time_t v4; // eax@3
  int v5; // esi@3
  int v6; // esi@3
  char *v7; // eax@3
  char v8; // cl@4
  int *v9; // eax@5
  char v10; // cl@6
  char Dest; // [sp+10h] [bp-20Ch]@3
  char v12[512]; // [sp+1Ch] [bp-200h]@3

  result = strlen(a2) + 2 * strlen(a1) + 8;
  if ( (unsigned int)result < 0x200 )
  {
    v4 = time(0);
    srand(v4 ^ 0x33333333);
    v5 = rand() << 16;
    v6 = rand() | v5;
    sprintf(&Dest, "%.8x", v6);
    sprintf(v12, "%s%d%s", a1, v6 % 0xFFFFu, a2);
    sub_1000D070(a1, strlen(a1), (char *)a3);
    v7 = &Dest;
    do
    {
      v8 = *v7;
      v7[a3 + 32 - (_DWORD)&Dest] = *v7;
      ++v7;
    }
    while ( v8 );
    v9 = (int *)v12;
    do
    {
      v10 = *(_BYTE *)v9;
      v9 = (int *)((char *)v9 + 1);
    }
    while ( v10 );
    result = sub_1000D070(v12, (char *)v9 - &v12[1], (char *)(a3 + 40));
  }
  else
  {
    memcpy((void *)a3, "CD Key or challenge too long", 0x1Du);
  }
  return result;
}

//----- (10008C20) --------------------------------------------------------
signed int __usercall sub_10008C20<eax>(int a1<eax>, int a2<edx>)
{
  int v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@1
  signed int result; // eax@4

  v2 = a1;
  v3 = *(_DWORD *)a2;
  v4 = 0;
  if ( *(_DWORD *)a2 )
  {
    while ( v3 != v2 )
    {
      v4 = v3;
      v3 = *(_DWORD *)(v3 + 32);
      if ( !v3 )
        goto LABEL_4;
    }
    if ( v4 )
      *(_DWORD *)(v4 + 32) = *(_DWORD *)(v3 + 32);
    if ( *(_DWORD *)a2 == v3 )
      *(_DWORD *)a2 = *(_DWORD *)(v3 + 32);
    if ( *(_DWORD *)(a2 + 4) == v3 )
      *(_DWORD *)(a2 + 4) = v4;
    --*(_DWORD *)(a2 + 8);
    result = 1;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (10008C80) --------------------------------------------------------
int __usercall sub_10008C80<eax>(int a1<ebx>, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  DWORD v4; // eax@5
  bool v5; // zf@6
  unsigned int v6; // ecx@7
  int v7; // eax@9
  int v8; // ecx@9
  int v9; // eax@14
  __int16 v10; // dx@16
  struct sockaddr to; // [sp+8h] [bp-110h]@14
  char buf[7]; // [sp+18h] [bp-100h]@6
  char v14; // [sp+1Fh] [bp-F9h]@7
  int v15; // [sp+20h] [bp-F8h]@8
  char v16; // [sp+24h] [bp-F4h]@12

  v2 = *(_DWORD *)(a1 + 12);
  v3 = a2;
  if ( v2 )
    *(_DWORD *)(v2 + 32) = a2;
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a2 + 32) = 0;
  if ( !*(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 8) = a2;
  ++*(_DWORD *)(a1 + 16);
  v4 = GetTickCount();
  *(_DWORD *)(a2 + 28) = v4;
  if ( *(_DWORD *)a1 == 1 )
  {
    *(_DWORD *)&buf[3] = v4;
    v5 = (*(_BYTE *)(a2 + 20) & 4) == 0;
    buf[0] = -2;
    buf[1] = -3;
    buf[2] = 0;
    if ( v5 )
    {
      v14 = -1;
      LOWORD(v15) = -1;
      v8 = 10;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 60);
      v14 = *(_BYTE *)(a1 + 60);
      if ( (signed int)v6 > 0 )
      {
        memcpy(&v15, (const void *)(a1 + 40), v6);
        v3 = a2;
      }
      v7 = *(_DWORD *)(a1 + 60);
      *((_BYTE *)&v15 + v7) = 0;
      *((_BYTE *)&v15 + v7 + 1) = 0;
      v8 = v7 + 10;
    }
  }
  else
  {
    if ( *(_BYTE *)(a2 + 20) & 4 )
    {
      *(_DWORD *)buf = dword_1000EBC8;
      *(_DWORD *)&buf[4] = dword_1000EBCC;
      v15 = dword_1000EBD0;
      v16 = byte_1000EBD4;
      v8 = 13;
    }
    else
    {
      *(_DWORD *)buf = dword_1000EBBC;
      *(_DWORD *)&buf[4] = dword_1000EBC0;
      v8 = 8;
    }
  }
  v9 = *(_DWORD *)v3;
  v5 = *(_DWORD *)v3 == *(_DWORD *)(a1 + 36);
  to.sa_family = 2;
  if ( v5 && *(_BYTE *)(v3 + 21) & 2 )
  {
    v10 = *(_WORD *)(v3 + 12);
    *(_DWORD *)&to.sa_data[2] = *(_DWORD *)(v3 + 8);
    *(_WORD *)&to.sa_data[0] = v10;
  }
  else
  {
    *(_DWORD *)&to.sa_data[2] = v9;
    *(_WORD *)&to.sa_data[0] = *(_WORD *)(v3 + 4);
  }
  return sendto(*(_DWORD *)(a1 + 32), buf, v8, 0, &to, 16);
}
// 1000EBBC: using guessed type int dword_1000EBBC;
// 1000EBC0: using guessed type int dword_1000EBC0;
// 1000EBC8: using guessed type int dword_1000EBC8;
// 1000EBCC: using guessed type int dword_1000EBCC;
// 1000EBD0: using guessed type int dword_1000EBD0;
// 1000EBD4: using guessed type char byte_1000EBD4;

//----- (10008DD0) --------------------------------------------------------
void __cdecl sub_10008DD0(int a1, int a2, int a3, int a4, int a5)
{
  if ( dword_10011FE0 == 1 )
  {
    sub_10004740();
    *(_DWORD *)a1 = a3;
    *(_DWORD *)(a1 + 4) = a2;
    *(_DWORD *)(a1 + 60) = 0;
    *(_DWORD *)(a1 + 64) = a4;
    *(_DWORD *)(a1 + 68) = a5;
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 32) = socket(2, 2, 17);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
}
// 10011FE0: using guessed type int dword_10011FE0;

//----- (10008E30) --------------------------------------------------------
int __cdecl sub_10008E30(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (10008E40) --------------------------------------------------------
int __cdecl sub_10008E40(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (10008E60) --------------------------------------------------------
int __cdecl sub_10008E60(int a1)
{
  int result; // eax@1

  closesocket(*(_DWORD *)(a1 + 32));
  *(_DWORD *)(a1 + 32) = -1;
  result = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (10008E90) --------------------------------------------------------
int __cdecl sub_10008E90(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  char v5; // cl@1
  char v6; // cl@2
  int v7; // ecx@9
  int v8; // ecx@11

  result = a2;
  v5 = *(_BYTE *)(a2 + 20) & 0xE3;
  *(_BYTE *)(a2 + 20) = v5;
  if ( a4 )
  {
    if ( a4 != 1 )
      goto LABEL_6;
    v6 = v5 | 8;
  }
  else
  {
    v6 = v5 | 4;
  }
  *(_BYTE *)(a2 + 20) = v6;
LABEL_6:
  if ( *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 4) )
    return sub_10008C80(a1, a2);
  if ( a3 )
  {
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 20);
    v7 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 20) = a2;
    if ( !v7 )
    {
      *(_DWORD *)(a1 + 24) = a2;
      ++*(_DWORD *)(a1 + 28);
      return result;
    }
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 24);
    if ( v8 )
      *(_DWORD *)(v8 + 32) = a2;
    *(_DWORD *)(a1 + 24) = a2;
    *(_DWORD *)(a2 + 32) = 0;
    if ( !*(_DWORD *)(a1 + 20) )
      *(_DWORD *)(a1 + 20) = a2;
  }
  ++*(_DWORD *)(a1 + 28);
  return result;
}

//----- (10008F10) --------------------------------------------------------
int __cdecl sub_10008F10(int a1, const char *cp, u_short hostshort, int a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  int v7; // eax@1
  int v8; // esi@1

  v5 = inet_addr(cp);
  v6 = htons(hostshort);
  v7 = (int)sub_10004400(0, v5, v6);
  v8 = v7;
  *(_BYTE *)(v7 + 21) = 1;
  sub_10008E90(a1, v7, a4, a5);
  return v8;
}

//----- (10008F60) --------------------------------------------------------
int __usercall sub_10008F60<eax>(int result<eax>, int a2<ebx>, int a3, int a4)
{
  int v4; // esi@2
  signed int v5; // edi@4
  char v6; // al@6
  int v7; // eax@8
  int v8; // ecx@8
  int i; // [sp+8h] [bp-4h]@3
  signed int v10; // [sp+14h] [bp+8h]@2

  if ( !*(_BYTE *)result )
  {
    v4 = result + 5;
    v10 = a4 - 5;
    if ( *(_BYTE *)(a2 + 20) & 4 )
    {
      for ( i = 0; i < *(_DWORD *)(a3 + 60); ++i )
      {
        v5 = sub_10009F70(v4, v10);
        if ( v5 < 0 )
          break;
        sub_10003B00(a2, (const char *)*(&off_100110A0 + *(_BYTE *)(i + a3 + 40)), (const char *)v4);
        v10 -= v5;
        v4 += v5;
      }
      v6 = *(_BYTE *)(a2 + 20) | 1;
    }
    else
    {
      sub_10004160(a2, v4, v10);
      v6 = *(_BYTE *)(a2 + 20) | 3;
    }
    *(_BYTE *)(a2 + 20) = v6;
    *(_BYTE *)(a2 + 20) = v6 & 0xF3;
    *(_DWORD *)(a2 + 28) = GetTickCount() - *(_DWORD *)(a2 + 28);
    v7 = *(_DWORD *)(a3 + 8);
    v8 = 0;
    if ( v7 )
    {
      while ( v7 != a2 )
      {
        v8 = v7;
        v7 = *(_DWORD *)(v7 + 32);
        if ( !v7 )
          return (*(int (__cdecl **)(int, _DWORD, int, _DWORD))(a3 + 64))(a3, 0, a2, *(_DWORD *)(a3 + 68));
      }
      if ( v8 )
        *(_DWORD *)(v8 + 32) = *(_DWORD *)(v7 + 32);
      if ( *(_DWORD *)(a3 + 8) == v7 )
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v7 + 32);
      if ( *(_DWORD *)(a3 + 12) == v7 )
        *(_DWORD *)(a3 + 12) = v8;
      --*(_DWORD *)(a3 + 16);
    }
    result = (*(int (__cdecl **)(int, _DWORD, int, _DWORD))(a3 + 64))(a3, 0, a2, *(_DWORD *)(a3 + 68));
  }
  return result;
}
// 100110A0: using guessed type void *off_100110A0;

//----- (10009080) --------------------------------------------------------
int __usercall sub_10009080<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  char v5; // al@2
  char v6; // al@3

  v3 = strstr((const char *)a1, "\\final\\") != 0;
  result = sub_10004080(a2, a1);
  if ( v3 )
  {
    v5 = *(_BYTE *)(a2 + 20);
    if ( v5 & 4 )
      v6 = v5 | 1;
    else
      v6 = v5 | 2;
    *(_BYTE *)(a2 + 20) = v6;
    *(_BYTE *)(a2 + 20) = v6 & 0xF3;
    *(_DWORD *)(a2 + 28) = GetTickCount() - *(_DWORD *)(a2 + 28);
    sub_10008C20(a2, a3 + 8);
    result = (*(int (__cdecl **)(int, _DWORD, int, _DWORD))(a3 + 64))(a3, 0, a2, *(_DWORD *)(a3 + 68));
  }
  return result;
}

//----- (100090F0) --------------------------------------------------------
int __usercall sub_100090F0<eax>(int a1<esi>)
{
  SOCKET v1; // ST1C_4@1
  int result; // eax@1
  int v3; // edi@3
  int fromlen; // [sp+0h] [bp-814h]@1
  struct sockaddr from; // [sp+4h] [bp-810h]@2
  char buf[2048]; // [sp+14h] [bp-800h]@2

  v1 = *(_DWORD *)(a1 + 32);
  fromlen = 16;
  for ( result = sub_10004A40(v1); result; result = sub_10004A40(*(_DWORD *)(a1 + 32)) )
  {
    result = recvfrom(*(_DWORD *)(a1 + 32), buf, 2047, 0, &from, &fromlen);
    if ( result == -1 )
      break;
    v3 = *(_DWORD *)(a1 + 8);
    buf[result] = 0;
    if ( v3 )
    {
      while ( (*(_DWORD *)v3 != *(_DWORD *)&from.sa_data[2] || *(_WORD *)(v3 + 4) != *(_WORD *)&from.sa_data[0])
           && (*(_DWORD *)v3 != *(_DWORD *)(a1 + 36)
            || !(*(_BYTE *)(v3 + 21) & 2)
            || *(_DWORD *)(v3 + 8) != *(_DWORD *)&from.sa_data[2]
            || *(_WORD *)(v3 + 12) != *(_WORD *)&from.sa_data[0]) )
      {
        v3 = *(_DWORD *)(v3 + 32);
        if ( !v3 )
          goto LABEL_15;
      }
      if ( *(_DWORD *)a1 == 1 )
        sub_10008F60((int)buf, v3, a1, result);
      else
        sub_10009080((int)buf, v3, a1);
    }
LABEL_15:
    ;
  }
  return result;
}
// 100090F0: using guessed type char buf[2048];

//----- (100091C0) --------------------------------------------------------
int __usercall sub_100091C0<eax>(int a1<esi>)
{
  DWORD v1; // ebp@1
  int result; // eax@1
  int v3; // eax@3
  int v4; // eax@4

  v1 = GetTickCount();
  for ( result = *(_DWORD *)(a1 + 8); result; result = *(_DWORD *)(a1 + 8) )
  {
    result = *(_DWORD *)(result + 28) + 2500;
    if ( v1 <= result )
      break;
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + 21) |= 0x10u;
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + 21) &= 0xF3u;
    (*(void (__cdecl **)(int, signed int, _DWORD, _DWORD))(a1 + 64))(a1, 1, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 68));
    v3 = *(_DWORD *)(a1 + 8);
    if ( v3 )
    {
      v4 = *(_DWORD *)(v3 + 32);
      *(_DWORD *)(a1 + 8) = v4;
      if ( !v4 )
        *(_DWORD *)(a1 + 12) = 0;
      --*(_DWORD *)(a1 + 16);
    }
  }
  return result;
}

//----- (10009220) --------------------------------------------------------
int __usercall sub_10009220<eax>(int a1<eax>)
{
  int v1; // ebx@1
  int result; // eax@1
  int v3; // ecx@3
  int v4; // eax@4

  v1 = a1;
  result = *(_DWORD *)(a1 + 16);
  if ( result < *(_DWORD *)(v1 + 4) )
  {
    do
    {
      result = *(_DWORD *)(v1 + 28);
      if ( result <= 0 )
        break;
      v3 = *(_DWORD *)(v1 + 20);
      if ( v3 )
      {
        v4 = *(_DWORD *)(v3 + 32);
        *(_DWORD *)(v1 + 20) = v4;
        if ( !v4 )
          *(_DWORD *)(v1 + 24) = 0;
        --*(_DWORD *)(v1 + 28);
      }
      sub_10008C80(v1, v3);
      result = *(_DWORD *)(v1 + 4);
    }
    while ( *(_DWORD *)(v1 + 16) < result );
  }
  return result;
}

//----- (10009270) --------------------------------------------------------
int __cdecl sub_10009270(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    sub_100090F0(a1);
    sub_100091C0(a1);
    if ( *(_DWORD *)(a1 + 28) > 0 )
      sub_10009220(a1);
    result = *(_DWORD *)(a1 + 16);
    if ( !result )
      result = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 64))(a1, 2, 0, *(_DWORD *)(a1 + 68));
  }
  return result;
}

//----- (100092B0) --------------------------------------------------------
int __cdecl sub_100092B0(int a1, char a2)
{
  int result; // eax@1
  signed int v3; // ecx@1

  result = a1;
  v3 = *(_DWORD *)(a1 + 60);
  if ( v3 < 20 )
  {
    *(_BYTE *)(v3 + a1 + 40) = a2;
    ++*(_DWORD *)(a1 + 60);
  }
  return result;
}

//----- (100092D0) --------------------------------------------------------
signed int __cdecl sub_100092D0(int a1, int a2)
{
  signed int result; // eax@1

  result = sub_10008C20(a2, a1 + 8);
  if ( !result )
    result = sub_10008C20(a2, a1 + 20);
  return result;
}

//----- (10009330) --------------------------------------------------------
void *__cdecl sub_10009330(int a1, signed int a2, int a3)
{
  void *v3; // esi@1
  signed int v4; // eax@1
  void *result; // eax@4

  v3 = malloc(0x18u);
  v4 = a2;
  if ( !a2 )
    v4 = 8;
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 1) = v4;
  *((_DWORD *)v3 + 2) = a1;
  *((_DWORD *)v3 + 3) = v4;
  *((_DWORD *)v3 + 4) = a3;
  if ( v4 )
  {
    *((_DWORD *)v3 + 5) = malloc(v4 * a1);
    result = v3;
  }
  else
  {
    *((_DWORD *)v3 + 5) = 0;
    result = v3;
  }
  return result;
}

//----- (100093A0) --------------------------------------------------------
int __cdecl sub_100093A0(int a1)
{
  return *(_DWORD *)a1;
}

//----- (100093B0) --------------------------------------------------------
int __cdecl sub_100093B0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 20) + a2 * *(_DWORD *)(a1 + 8);
}

//----- (10009400) --------------------------------------------------------
void __cdecl sub_10009400(int a1, int (__cdecl *PtFuncCompare)(const void *, const void *))
{
  qsort(*(void **)(a1 + 20), *(_DWORD *)a1, *(_DWORD *)(a1 + 8), PtFuncCompare);
}

//----- (10009420) --------------------------------------------------------
int __cdecl sub_10009420(int a1, void (__cdecl *a2)(_DWORD, _DWORD), int a3)
{
  int result; // eax@1
  int i; // esi@1

  result = *(_DWORD *)a1;
  for ( i = 0; i < *(_DWORD *)a1; ++i )
  {
    a2(*(_DWORD *)(a1 + 20) + i * *(_DWORD *)(a1 + 8), a3);
    result = *(_DWORD *)a1;
  }
  return result;
}

//----- (10009460) --------------------------------------------------------
int __cdecl sub_10009460(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = *(_DWORD *)a1 - 1; i >= 0; --i )
    result = a2(*(_DWORD *)(a1 + 20) + i * *(_DWORD *)(a1 + 8), a3);
  return result;
}

//----- (10009490) --------------------------------------------------------
int __cdecl sub_10009490(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3)
{
  int v3; // ebx@1
  int v4; // esi@2
  int result; // eax@4

  v3 = 0;
  if ( *(_DWORD *)a1 <= 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 20) + v3 * *(_DWORD *)(a1 + 8);
      if ( !a2(*(_DWORD *)(a1 + 20) + v3 * *(_DWORD *)(a1 + 8), a3) )
        break;
      ++v3;
      if ( v3 >= *(_DWORD *)a1 )
        goto LABEL_4;
    }
    result = v4;
  }
  return result;
}

//----- (100094E0) --------------------------------------------------------
int __cdecl sub_100094E0(int a1, int (__cdecl *a2)(_DWORD, _DWORD), int a3)
{
  int v3; // ebx@1
  int v4; // esi@2
  int result; // eax@4

  v3 = *(_DWORD *)a1 - 1;
  if ( *(_DWORD *)a1 - 1 < 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 20) + v3 * *(_DWORD *)(a1 + 8);
      if ( !a2(*(_DWORD *)(a1 + 20) + v3 * *(_DWORD *)(a1 + 8), a3) )
        break;
      --v3;
      if ( v3 < 0 )
        goto LABEL_4;
    }
    result = v4;
  }
  return result;
}

//----- (10009520) --------------------------------------------------------
int __usercall sub_10009520<eax>(int a1<ebx>, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // esi@1
  int v6; // edi@2
  int result; // eax@5

  v5 = 0;
  if ( a1 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v6 = a3;
    while ( a5(a2, v6) )
    {
      ++v5;
      v6 += a4;
      if ( v5 >= a1 )
        goto LABEL_5;
    }
    result = a3 + a4 * v5;
  }
  return result;
}

//----- (10009560) --------------------------------------------------------
int __usercall sub_10009560<eax>(int a1<eax>, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD), int a6)
{
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@2
  int v9; // eax@2

  v6 = 0;
  v7 = a1 - 1;
  *(_DWORD *)a6 = 0;
  while ( v6 <= v7 )
  {
    v8 = (v7 + v6) >> 1;
    v9 = a5(a3 + a4 * ((v7 + v6) >> 1), a2);
    if ( v9 )
    {
      if ( v9 < 0 )
      {
        v6 = v8 + 1;
        continue;
      }
    }
    else
    {
      *(_DWORD *)a6 = 1;
    }
    v7 = v8 - 1;
  }
  return a3 + a4 * v6;
}

//----- (10009610) --------------------------------------------------------
void __cdecl sub_10009610(void *Memory)
{
  int i; // edi@1
  void (__cdecl *v2)(_DWORD); // eax@2

  for ( i = 0; i < *(_DWORD *)Memory; ++i )
  {
    v2 = (void (__cdecl *)(_DWORD))*((_DWORD *)Memory + 4);
    if ( v2 )
      v2(*((_DWORD *)Memory + 5) + i * *((_DWORD *)Memory + 2));
  }
  free(*((void **)Memory + 5));
  free(Memory);
}

//----- (100096C0) --------------------------------------------------------
void *__cdecl sub_100096C0(int a1, const void *a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@2
  size_t v5; // edx@2
  int v6; // esi@3
  void *result; // eax@3
  bool v8; // sf@3
  unsigned __int8 v9; // of@3

  v3 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)a1 == v3 )
  {
    v4 = *(_DWORD *)(a1 + 12) + v3;
    v5 = v4 * *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 20) = realloc(*(void **)(a1 + 20), v5);
  }
  v6 = *(_DWORD *)a1 + 1;
  result = (void *)v6;
  v9 = __OFSUB__(a3, *(_DWORD *)a1);
  v8 = a3 - *(_DWORD *)a1 < 0;
  *(_DWORD *)a1 = v6;
  if ( v8 ^ v9 )
    result = memmove(
               (void *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8) * (a3 + 1)),
               (const void *)(*(_DWORD *)(a1 + 20) + a3 * *(_DWORD *)(a1 + 8)),
               *(_DWORD *)(a1 + 8) * (v6 - a3 - 1));
  memcpy((void *)(*(_DWORD *)(a1 + 20) + a3 * *(_DWORD *)(a1 + 8)), a2, *(_DWORD *)(a1 + 8));
  return result;
}

//----- (10009790) --------------------------------------------------------
int __cdecl sub_10009790(int a1, int a2)
{
  void (__cdecl *v2)(_DWORD); // eax@1
  int result; // eax@5

  v2 = *(void (__cdecl **)(_DWORD))(a1 + 16);
  if ( v2 )
    v2(*(_DWORD *)(a1 + 20) + a2 * *(_DWORD *)(a1 + 8));
  if ( a2 < *(_DWORD *)a1 - 1 )
    memmove(
      (void *)(*(_DWORD *)(a1 + 20) + a2 * *(_DWORD *)(a1 + 8)),
      (const void *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8) * (a2 + 1)),
      *(_DWORD *)(a1 + 8) * (*(_DWORD *)a1 - a2 - 1));
  result = *(_DWORD *)a1 - 1;
  *(_DWORD *)a1 = result;
  return result;
}

//----- (100097F0) --------------------------------------------------------
int __cdecl sub_100097F0(int a1, const void *a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 16);
  if ( result )
    result = ((int (__cdecl *)(int))result)(*(_DWORD *)(a1 + 20) + a3 * *(_DWORD *)(a1 + 8));
  memcpy((void *)(*(_DWORD *)(a1 + 20) + a3 * *(_DWORD *)(a1 + 8)), a2, *(_DWORD *)(a1 + 8));
  return result;
}

//----- (10009840) --------------------------------------------------------
int __cdecl sub_10009840(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD), int a4, int a5)
{
  int v5; // eax@2
  int v6; // ecx@3
  int v7; // eax@4
  int result; // eax@8
  int v9; // [sp+0h] [bp-4h]@1

  v9 = 1;
  if ( a1
    && (v5 = *(_DWORD *)a1) != 0
    && ((v6 = *(_DWORD *)(a1 + 8), !a5) ? (v7 = sub_10009520(v5 - a4, a2, *(_DWORD *)(a1 + 20) + a4 * v6, v6, a3)) : (v7 = sub_10009560(v5 - a4, a2, *(_DWORD *)(a1 + 20) + a4 * v6, v6, a3, (int)&v9)),
        v7 && v9) )
    result = (v7 - *(_DWORD *)(a1 + 20)) / *(_DWORD *)(a1 + 8);
  else
    result = -1;
  return result;
}

//----- (100098D0) --------------------------------------------------------
void __cdecl sub_100098D0(int a1)
{
  int v1; // edi@1
  int v2; // ebx@2
  void (__cdecl *v3)(_DWORD); // eax@3

  v1 = *(_DWORD *)a1 - 1;
  if ( *(_DWORD *)a1 - 1 >= 0 )
  {
    v2 = *(_DWORD *)a1;
    do
    {
      v3 = *(void (__cdecl **)(_DWORD))(a1 + 16);
      if ( v3 )
        v3(*(_DWORD *)(a1 + 20) + v1 * *(_DWORD *)(a1 + 8));
      if ( v1 < *(_DWORD *)a1 - 1 )
        memmove(
          (void *)(*(_DWORD *)(a1 + 20) + v1 * *(_DWORD *)(a1 + 8)),
          (const void *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8) * v2),
          *(_DWORD *)(a1 + 8) * (*(_DWORD *)a1 - v1 - 1));
      --v1;
      --v2;
      --*(_DWORD *)a1;
    }
    while ( v1 >= 0 );
  }
}

//----- (10009940) --------------------------------------------------------
void *__cdecl sub_10009940(int a1, const void *a2)
{
  void *result; // eax@1

  result = (void *)a1;
  if ( a1 )
    result = sub_100096C0(a1, a2, *(_DWORD *)a1);
  return result;
}

//----- (10009960) --------------------------------------------------------
int __cdecl PtFuncCompare(int *a1, int *a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int result; // eax@1

  v2 = *a1;
  v3 = sub_10004580(*a2, *(_DWORD *)(dword_10011F54 + 1168), 0);
  result = sub_10004580(v2, *(_DWORD *)(dword_10011F54 + 1168), 0) - v3;
  if ( !*(_DWORD *)(dword_10011F54 + 1172) )
    result = -result;
  return result;
}
// 10011F54: using guessed type int dword_10011F54;

//----- (100099C0) --------------------------------------------------------
signed int __cdecl sub_100099C0(int *a1, int *a2)
{
  int v2; // esi@1
  double v3; // ST14_8@1
  double v4; // st7@1
  signed int result; // eax@4
  float v6; // [sp+18h] [bp+4h]@3

  v2 = *a2;
  v3 = sub_10003C20(*a1, *(_DWORD *)(dword_10011F54 + 1168), 0.0);
  v4 = v3 - sub_10003C20(v2, *(_DWORD *)(dword_10011F54 + 1168), 0.0);
  if ( !*(_DWORD *)(dword_10011F54 + 1172) )
    v4 = -v4;
  v6 = v4;
  if ( v6 <= 0.0 )
  {
    if ( v6 >= 0.0 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10011F54: using guessed type int dword_10011F54;

//----- (10009BE0) --------------------------------------------------------
int __cdecl sub_10009BE0(int a1, int a2)
{
  sub_10009940(*(_DWORD *)(a1 + 4), &a2);
  return (*(int (__cdecl **)(int, _DWORD, int, _DWORD))(a1 + 1152))(a1, 0, a2, *(_DWORD *)(a1 + 1164));
}

//----- (10009C10) --------------------------------------------------------
signed int __cdecl sub_10009C10(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  signed int result; // eax@4

  v2 = sub_100093A0(*(_DWORD *)(a1 + 4));
  v3 = 0;
  if ( v2 <= 0 )
  {
LABEL_4:
    result = -1;
  }
  else
  {
    while ( a2 != *(_DWORD *)sub_100093B0(*(_DWORD *)(a1 + 4), v3) )
    {
      ++v3;
      if ( v3 >= v2 )
        goto LABEL_4;
    }
    result = v3;
  }
  return result;
}

//----- (10009C60) --------------------------------------------------------
signed int __cdecl sub_10009C60(int a1, int a2, __int16 a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@2
  signed int result; // eax@5
  int v7; // [sp+14h] [bp+4h]@1

  v3 = a1;
  v4 = 0;
  v7 = sub_100093A0(*(_DWORD *)(a1 + 4));
  if ( v7 <= 0 )
  {
LABEL_5:
    result = -1;
  }
  else
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)sub_100093B0(*(_DWORD *)(v3 + 4), v4);
      if ( sub_10003ED0(v5) == a2 )
      {
        if ( sub_10003F00(v5) == a3 )
          break;
      }
      ++v4;
      if ( v4 >= v7 )
        goto LABEL_5;
    }
    result = v4;
  }
  return result;
}

//----- (10009D00) --------------------------------------------------------
int __cdecl sub_10009D00(int a1, int a2)
{
  int v2; // eax@1
  int v3; // edi@1
  int result; // eax@2

  v2 = sub_100093B0(*(_DWORD *)(a1 + 4), a2);
  v3 = *(_DWORD *)v2;
  (*(void (__cdecl **)(int, signed int, _DWORD, _DWORD))(a1 + 1152))(a1, 2, *(_DWORD *)v2, *(_DWORD *)(a1 + 1164));
  sub_10009790(*(_DWORD *)(a1 + 4), a2);
  if ( *(_DWORD *)(a1 + 1480) )
  {
    result = sub_10003F90(v3, *(_DWORD *)(a1 + 1480));
    *(_DWORD *)(a1 + 1480) = v3;
  }
  else
  {
    result = sub_10003F90(v3, 0);
    *(_DWORD *)(a1 + 1480) = v3;
  }
  return result;
}

//----- (10009D80) --------------------------------------------------------
int __cdecl sub_10009D80(int a1, int a2)
{
  return *(_DWORD *)sub_100093B0(*(_DWORD *)(a1 + 4), a2);
}

//----- (10009DA0) --------------------------------------------------------
int __cdecl sub_10009DA0(int a1)
{
  int v1; // edi@1
  int result; // eax@1
  int v3; // esi@3

  v1 = a1;
  result = *(_DWORD *)(a1 + 1480);
  if ( result )
  {
    a1 = *(_DWORD *)(a1 + 1480);
    do
    {
      v3 = sub_10003FA0(result);
      sub_10003AD0((int)&a1);
      result = v3;
      a1 = v3;
    }
    while ( v3 );
    *(_DWORD *)(v1 + 1480) = 0;
  }
  return result;
}

//----- (10009DE0) --------------------------------------------------------
int __cdecl sub_10009DE0(int a1)
{
  int v1; // esi@1
  int v2; // ebp@1
  int i; // edi@1
  int v4; // ebx@2
  int result; // eax@6
  int v6; // edi@8
  int v7; // [sp-8h] [bp-14h]@3

  v1 = a1;
  v2 = sub_100093A0(*(_DWORD *)(a1 + 4));
  for ( i = 0; i < v2; *(_DWORD *)(v1 + 1480) = v4 )
  {
    v4 = *(_DWORD *)sub_100093B0(*(_DWORD *)(v1 + 4), i);
    if ( *(_DWORD *)(v1 + 1480) )
      v7 = *(_DWORD *)(v1 + 1480);
    else
      v7 = 0;
    sub_10003F90(v4, v7);
    ++i;
  }
  sub_100098D0(*(_DWORD *)(v1 + 4));
  result = *(_DWORD *)(v1 + 1480);
  if ( result )
  {
    a1 = *(_DWORD *)(v1 + 1480);
    do
    {
      v6 = sub_10003FA0(result);
      sub_10003AD0((int)&a1);
      result = v6;
      a1 = v6;
    }
    while ( v6 );
    *(_DWORD *)(v1 + 1480) = 0;
  }
  return result;
}

//----- (10009EA0) --------------------------------------------------------
void *__cdecl sub_10009EA0(int a1, const char *a2)
{
  int v2; // eax@1
  int v3; // eax@1
  void *result; // eax@2
  int v5; // eax@3
  void *v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@3

  v6 = (void *)a2;
  v2 = (int)sub_10004550();
  v3 = sub_1000BDF0(v2, (int)&v6);
  if ( v3 )
  {
    ++*(_DWORD *)(v3 + 4);
    result = *(void **)v3;
  }
  else
  {
    v6 = sub_10004770(a2);
    v7 = 1;
    v5 = (int)sub_10004550();
    sub_1000BD30(v5, (int)&v6);
    result = v6;
  }
  return result;
}

//----- (10009F20) --------------------------------------------------------
int __cdecl sub_10009F20(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@1
  bool v4; // zf@2
  int v5; // eax@3
  int v6; // [sp+4h] [bp-8h]@1

  v6 = a2;
  v2 = (int)sub_10004550();
  result = sub_1000BDF0(v2, (int)&v6);
  if ( result )
  {
    v4 = (*(_DWORD *)(result + 4))-- == 1;
    if ( v4 )
    {
      v5 = (int)sub_10004550();
      result = sub_1000BD90(v5, (int)&v6);
    }
  }
  return result;
}

//----- (10009F70) --------------------------------------------------------
signed int __cdecl sub_10009F70(int a1, signed int a2)
{
  signed int result; // eax@1
  char v3; // bl@2

  result = 0;
  if ( a2 <= 0 )
  {
LABEL_4:
    result = -1;
  }
  else
  {
    while ( 1 )
    {
      v3 = *(_BYTE *)(result++ + a1);
      if ( !v3 )
        break;
      if ( result >= a2 )
        goto LABEL_4;
    }
  }
  return result;
}

//----- (10009FA0) --------------------------------------------------------
int __usercall sub_10009FA0<eax>(int a1<eax>, unsigned int a2)
{
  int v2; // edi@1
  char v3; // al@1
  unsigned int v4; // esi@1

  v2 = a1;
  v3 = *(_BYTE *)a1;
  v4 = 0;
  if ( v3 )
  {
    do
    {
      ++v2;
      v4 = tolower(v3) - 1664117991 * v4;
      v3 = *(_BYTE *)v2;
    }
    while ( *(_BYTE *)v2 );
  }
  return v4 % a2;
}

//----- (10009FE0) --------------------------------------------------------
signed int __usercall sub_10009FE0<eax>(int a1<edi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  char *v3; // edx@2
  char v4; // cl@3
  struct hostent *v5; // eax@7
  signed int result; // eax@8
  SOCKET v7; // eax@11
  __int16 v8; // [sp+4h] [bp-90h]@6
  u_short v9; // [sp+6h] [bp-8Eh]@6
  unsigned __int32 v10; // [sp+8h] [bp-8Ch]@6
  char name[128]; // [sp+14h] [bp-80h]@2

  v1 = sub_10009FA0(a1 + 12, 0x14u);
  v2 = dword_10011F58;
  if ( dword_10011F58 )
  {
    v3 = &name[-dword_10011F58];
    do
    {
      v4 = *(_BYTE *)v2;
      v3[v2] = *(_BYTE *)v2;
      ++v2;
    }
    while ( v4 );
  }
  else
  {
    sprintf(name, "%s.ms%d.gamespy.com", a1 + 12, v1);
  }
  v8 = 2;
  v9 = htons(0x70EEu);
  v10 = inet_addr(name);
  if ( v10 == -1 )
  {
    v5 = gethostbyname(name);
    if ( !v5 )
      return 2;
    v10 = **(_DWORD **)v5->h_addr_list;
  }
  if ( *(_DWORD *)(a1 + 1192) != -1 || (v7 = socket(2, 1, 6), *(_DWORD *)(a1 + 1192) = v7, v7 != -1) )
  {
    if ( connect(*(_DWORD *)(a1 + 1192), (const struct sockaddr *)&v8, 16) )
    {
      closesocket(*(_DWORD *)(a1 + 1192));
      *(_DWORD *)(a1 + 1192) = -1;
      result = 3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10011F58: using guessed type int dword_10011F58;
// 10009FE0: using guessed type char name[128];

//----- (1000A0F0) --------------------------------------------------------
unsigned int __usercall sub_1000A0F0<eax>(const void *a1<eax>, void **a2<edx>, int a3<ebx>)
{
  const void *v3; // esi@1
  const void *v4; // eax@3
  char v5; // cl@4
  unsigned int result; // eax@5

  v3 = a1;
  if ( !a1 )
    v3 = &unk_1000E7EB;
  v4 = v3;
  do
  {
    v5 = *(_BYTE *)v4;
    v4 = (char *)v4 + 1;
  }
  while ( v5 );
  result = v4 - ((char *)v3 + 1) + 1;
  memcpy(*a2, v3, result);
  *(_DWORD *)a3 += result;
  *a2 = (char *)*a2 + result;
  return result;
}

//----- (1000A190) --------------------------------------------------------
int __cdecl sub_1000A190(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // eax@3
  int result; // eax@3
  signed __int64 v7; // qtt@3
  char v8; // dl@3

  v1 = a1;
  v2 = 0;
  v3 = a1 + 109;
  *(_BYTE *)(a1 + 108) = rand() % 93 + 33;
  v4 = -108 - a1;
  while ( 1 )
  {
    v2 ^= *(_BYTE *)(v1 + 108) < 79 ^ *(_BYTE *)(v3 - 1) < *(_BYTE *)(v1 + 108) ^ (*(_BYTE *)(v1 + 108) ^ (unsigned __int8)(*(_BYTE *)(v3 - 1) ^ (v3 + (_BYTE)v4))) & 1;
    v5 = rand();
    v7 = v5;
    result = v5 / 93;
    v8 = (unsigned __int64)(v7 % 93) + 33;
    *(_BYTE *)v3 = v8;
    if ( !v2 )
    {
      if ( !(v8 & 1) )
        goto LABEL_8;
LABEL_7:
      *(_BYTE *)v3 = v8 + 1;
      goto LABEL_8;
    }
    if ( !(v8 & 1) )
      goto LABEL_7;
LABEL_8:
    ++v3;
    if ( v3 + v4 >= 8 )
      return result;
    v1 = a1;
  }
}

//----- (1000A220) --------------------------------------------------------
int __usercall sub_1000A220<eax>(int a1<esi>)
{
  int result; // eax@1
  int v2; // ebx@1
  int v3; // edi@2
  int v4; // eax@3
  int v5; // eax@3
  bool v6; // zf@4
  int v7; // eax@5
  int v8; // [sp+8h] [bp-8h]@3

  result = *(_DWORD *)(a1 + 1144);
  v2 = 0;
  if ( result <= 0 )
  {
    *(_DWORD *)(a1 + 1144) = 0;
  }
  else
  {
    v3 = a1 + 124;
    do
    {
      v8 = *(_DWORD *)v3;
      v4 = (int)sub_10004550();
      v5 = sub_1000BDF0(v4, (int)&v8);
      if ( v5 )
      {
        v6 = (*(_DWORD *)(v5 + 4))-- == 1;
        if ( v6 )
        {
          v7 = (int)sub_10004550();
          sub_1000BD90(v7, (int)&v8);
        }
      }
      result = *(_DWORD *)(a1 + 1144);
      ++v2;
      v3 += 4;
    }
    while ( v2 < result );
    *(_DWORD *)(a1 + 1144) = 0;
  }
  return result;
}

//----- (1000A2B0) --------------------------------------------------------
void __usercall sub_1000A2B0(int a1<esi>)
{
  int i; // edi@2
  int v2; // eax@3
  int v3; // eax@3
  bool v4; // zf@4
  int v5; // eax@5
  int v6; // [sp+8h] [bp-8h]@3

  if ( *(_DWORD *)(a1 + 8) )
  {
    for ( i = 0; i < sub_100093A0(*(_DWORD *)(a1 + 8)); ++i )
    {
      v6 = *(_DWORD *)sub_100093B0(*(_DWORD *)(a1 + 8), i);
      v2 = (int)sub_10004550();
      v3 = sub_1000BDF0(v2, (int)&v6);
      if ( v3 )
      {
        v4 = (*(_DWORD *)(v3 + 4))-- == 1;
        if ( v4 )
        {
          v5 = (int)sub_10004550();
          sub_1000BD90(v5, (int)&v6);
        }
      }
    }
    sub_10009610(*(void **)(a1 + 8));
    *(_DWORD *)(a1 + 8) = 0;
  }
}

//----- (1000A350) --------------------------------------------------------
int __cdecl sub_1000A350(int a1)
{
  SOCKET v1; // eax@3

  if ( *(_DWORD *)(a1 + 116) )
    free(*(void **)(a1 + 116));
  v1 = *(_DWORD *)(a1 + 1192);
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  if ( v1 != -1 )
    closesocket(v1);
  *(_DWORD *)(a1 + 1192) = -1;
  *(_DWORD *)a1 = 1;
  sub_1000A2B0(a1);
  *(_DWORD *)(a1 + 1148) = -1;
  return sub_1000A220(a1);
}

//----- (1000A3B0) --------------------------------------------------------
void __cdecl sub_1000A3B0(int a1)
{
  sub_1000A350(a1);
  sub_10009DE0(a1);
  sub_10003AA0();
  if ( *(_DWORD *)(a1 + 4) )
    sub_10009610(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
}

//----- (1000A3F0) --------------------------------------------------------
char __usercall sub_1000A3F0<al>(int a1<eax>, int a2<ebx>, signed int a3)
{
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // eax@1
  int v6; // edx@1
  char v7; // cl@2
  signed int v8; // edi@3
  signed int i; // ecx@3
  int v10; // eax@4

  v3 = a1;
  v4 = a1 + 76;
  v5 = a1 + 76;
  v6 = v5 + 1;
  do
    v7 = *(_BYTE *)v5++;
  while ( v7 );
  v8 = v5 - v6;
  for ( i = 0; i < a3; ++i )
  {
    v10 = i * *(_BYTE *)(i % v8 + v4) % 8;
    *(_BYTE *)(v10 + v3 + 108) ^= *(_BYTE *)(i + a2) ^ *(_BYTE *)((i & 7) + v3 + 108);
  }
  return sub_1000D1A0(v3 + 1204, v3 + 108, 8u);
}

//----- (1000A4A0) --------------------------------------------------------
int __fastcall sub_1000A4A0(int a1, int a2)
{
  bool v2; // zf@1
  int v3; // eax@3
  int result; // eax@6
  int v5; // eax@7
  int v6; // edx@8
  int v7; // ecx@8
  int v8; // eax@8
  int v9; // eax@12

  v2 = a1 == 0;
  if ( a1 > 0 )
  {
    do
    {
      if ( !*(_BYTE *)a2 )
        break;
      v3 = 0;
      if ( a1 <= 0 )
        goto LABEL_6;
      while ( *(_BYTE *)(v3 + a2) )
      {
        ++v3;
        if ( v3 >= a1 )
          goto LABEL_6;
      }
      v5 = v3 + 1;
      if ( v5 < 0 || (v6 = v5 + a2, v7 = a1 - v5, v8 = 0, v7 <= 0) )
        goto LABEL_6;
      while ( *(_BYTE *)(v8 + v6) )
      {
        ++v8;
        if ( v8 >= v7 )
          return 0;
      }
      v9 = v8 + 1;
      if ( v9 < 0 )
        goto LABEL_6;
      a1 = v7 - v9;
      a2 = v9 + v6;
    }
    while ( a1 > 0 );
    v2 = a1 == 0;
  }
  if ( v2 )
LABEL_6:
    result = 0;
  else
    result = *(_BYTE *)a2 == 0;
  return result;
}

//----- (1000A500) --------------------------------------------------------
signed int __usercall sub_1000A500<eax>(signed int a1<eax>, int a2<ecx>, int a3)
{
  signed int v3; // esi@1
  int v4; // edi@1
  int v5; // ebp@1
  int i; // ebx@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // eax@8
  signed int v10; // eax@9
  char v11; // cl@10

  v3 = a1;
  v4 = a2;
  v5 = sub_100093A0(*(_DWORD *)(a3 + 8));
  for ( i = 0; i < v5; ++i )
  {
    v7 = *(_DWORD *)(sub_100093B0(*(_DWORD *)(a3 + 8), i) + 4);
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 != 1 )
          return 0;
        v4 += 2;
        v3 -= 2;
      }
      else
      {
        ++v4;
        --v3;
      }
    }
    else
    {
      if ( v3 < 1 )
        return 0;
      v9 = *(_BYTE *)v4++;
      --v3;
      if ( v9 == 255 )
      {
        v10 = 0;
        if ( v3 <= 0 )
          return 0;
        while ( 1 )
        {
          v11 = *(_BYTE *)(v10++ + v4);
          if ( !v11 )
            break;
          if ( v10 >= v3 )
            return 0;
        }
        if ( v10 == -1 )
          return 0;
        v4 += v10;
        v3 -= v10;
      }
    }
    if ( v3 < 0 )
      return 0;
  }
  return 1;
}

//----- (1000A5A0) --------------------------------------------------------
__int16 __usercall sub_1000A5A0<ax>(int a1<eax>, signed int a2<edx>, int a3<ebx>, int a4<esi>, int a5)
{
  char v5; // cl@2

  if ( a2 >= 5 )
  {
    v5 = *(_BYTE *)a1++;
    *(_DWORD *)a3 = *(_DWORD *)a1;
    if ( v5 & 0x10 )
    {
      if ( a2 - 5 >= 2 )
      {
        LOWORD(a1) = *(_WORD *)(a1 + 4);
        *(_WORD *)a4 = a1;
      }
    }
    else
    {
      *(_WORD *)a4 = *(_WORD *)(a5 + 1184);
    }
  }
  return a1;
}

//----- (1000A5E0) --------------------------------------------------------
int __usercall sub_1000A5E0<eax>(int a1<eax>, char *a2<ecx>, int a3<ebx>, int a4, int a5)
{
  char *v5; // esi@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // ecx@4
  __int16 v10; // ax@7
  int v11; // ST08_4@10
  int v12; // eax@13
  const char **v13; // ebp@13
  int v14; // eax@13
  int v15; // eax@14
  u_short v16; // ax@16
  int v17; // eax@19
  int v18; // eax@20
  char v19; // cl@21
  int v20; // eax@22
  char v21; // al@25
  int v22; // eax@29
  const char *v23; // edx@29
  char v24; // cl@30
  int v25; // eax@31
  const char *v26; // esi@31
  int v27; // edi@31
  const char *v28; // eax@31
  char v29; // dl@32
  int v30; // eax@33
  char v31; // al@34
  char v33; // [sp+Ch] [bp-10h]@1
  int i; // [sp+10h] [bp-Ch]@12
  int v35; // [sp+14h] [bp-8h]@12
  int v36; // [sp+18h] [bp-4h]@1

  v5 = a2;
  v6 = a1;
  v33 = *a2;
  v36 = a1;
  sub_10004480(a3, *a2);
  v7 = (int)(v5 + 5);
  v8 = v6 - 5;
  if ( v33 & 0x10 )
  {
    v7 += 2;
    v8 -= 2;
  }
  if ( v33 & 2 )
  {
    v9 = *(_DWORD *)v7;
    v7 += 4;
    v8 -= 4;
  }
  else
  {
    v9 = 0;
  }
  if ( v33 & 0x20 )
  {
    v10 = *(_WORD *)v7;
    v7 += 2;
    v8 -= 2;
  }
  else
  {
    v10 = *(_WORD *)(a4 + 1184);
  }
  sub_100044B0(a3, v9, v10);
  if ( v33 & 8 )
  {
    v11 = *(_DWORD *)v7;
    v7 += 4;
    v8 -= 4;
    sub_100044D0(a3, v11);
  }
  if ( v33 & 0x40 )
  {
    v35 = sub_100093A0(*(_DWORD *)(a4 + 8));
    for ( i = 0; i < v35; ++i )
    {
      v12 = sub_100093B0(*(_DWORD *)(a4 + 8), i);
      v13 = (const char **)v12;
      v14 = *(_DWORD *)(v12 + 4);
      if ( v14 )
      {
        v15 = v14 - 1;
        if ( v15 )
        {
          if ( v15 == 1 )
          {
            v16 = ntohs(*(_WORD *)v7);
            sub_10003B40(a3, *v13, v16);
            v7 += 2;
            v8 -= 2;
          }
        }
        else
        {
          sub_10003B40(a3, *v13, *(_BYTE *)v7++);
          --v8;
        }
      }
      else
      {
        if ( a5 && (v17 = *(_BYTE *)v7, ++v7, --v8, v17 != 255) )
        {
          sub_10003B00(a3, *v13, *(const char **)(a4 + 4 * v17 + 124));
        }
        else
        {
          sub_10003B00(a3, *v13, (const char *)v7);
          v18 = v7;
          do
            v19 = *(_BYTE *)v18++;
          while ( v19 );
          v20 = v18 - (v7 + 1) + 1;
          v7 += v20;
          v8 -= v20;
        }
      }
    }
    v21 = sub_100044F0(a3);
    sub_100044E0(a3, v21 | 1);
  }
  if ( v33 < 0 )
  {
    for ( ; *(_BYTE *)v7; v8 = v27 - v30 )
    {
      if ( v8 <= 0 )
        break;
      v22 = v7;
      v23 = (const char *)v7;
      do
        v24 = *(_BYTE *)v22++;
      while ( v24 );
      v25 = v22 - (v7 + 1) + 1;
      v26 = (const char *)(v25 + v7);
      v27 = v8 - v25;
      sub_10003B00(a3, v23, v26);
      v28 = v26;
      do
        v29 = *v28++;
      while ( v29 );
      v30 = v28 - (v26 + 1) + 1;
      v7 = (int)&v26[v30];
    }
    --v8;
    v31 = sub_100044F0(a3);
    sub_100044E0(a3, v31 | 2);
  }
  return v36 - v8;
}

//----- (1000A800) --------------------------------------------------------
signed int __usercall sub_1000A800<eax>(int a1<eax>, int a2, signed int a3)
{
  signed int v3; // ebp@1
  int v4; // edi@1
  signed int result; // eax@2
  char v6; // bl@3
  char v7; // al@3
  signed int v8; // esi@3
  int v9; // eax@19
  int v10; // ebx@19
  int v11; // eax@19
  int v12; // edi@21
  int v13; // [sp+8h] [bp-4h]@19

  v3 = a3;
  v4 = a1;
  if ( a3 >= 1 )
  {
    v6 = *(_BYTE *)a1;
    v7 = *(_BYTE *)a1;
    v8 = 5;
    if ( v7 & 2 )
      v8 = 9;
    if ( v7 & 8 )
      v8 += 4;
    if ( v7 & 0x10 )
      v8 += 2;
    if ( v7 & 0x20 )
      v8 += 2;
    if ( a3 >= v8 && (!(v6 & 0x40) || sub_1000A500(a3 - v8, v8 + v4, a2)) && (v6 >= 0 || sub_1000A4A0(v3 - v8, v8 + v4)) )
    {
      if ( *(_DWORD *)(v4 + 1) == unk_1000EC14 )
      {
        result = -1;
      }
      else
      {
        sub_1000A5A0(v4, v3, (int)&v13, (int)&a3, a2);
        v9 = (int)sub_10004400(a2, v13, a3);
        v10 = v9;
        LOBYTE(v11) = sub_10004510(v9);
        if ( v11 )
        {
          result = -2;
        }
        else
        {
          v12 = sub_1000A5E0(v3, (char *)v4, v10, a2, 1);
          sub_10009BE0(a2, v10);
          result = v12;
        }
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000A920) --------------------------------------------------------
signed int __usercall sub_1000A920<eax>(int a1<esi>)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@3
  int v4; // ecx@4
  int v5; // ST10_4@7
  __int16 v6; // ax@7
  int v7; // ST10_4@9
  signed int v8; // eax@15
  void *v9; // eax@15
  int v10; // eax@19
  int v11; // ebx@24
  void *v12; // eax@25
  int v13; // ecx@25
  int v14; // edx@30
  int v15; // eax@32
  int v16; // ebx@36
  int v17; // eax@37
  signed int v18; // eax@41
  int v20; // ST10_4@47
  void *v21; // eax@48
  void *v22; // [sp+Ch] [bp-8h]@4
  int v23; // [sp+10h] [bp-4h]@25

  v1 = *(_DWORD *)(a1 + 120);
  v2 = *(_DWORD *)(a1 + 116);
  switch ( *(_DWORD *)(a1 + 1472) )
  {
    case 0:
      if ( v1 < 1
        || (v3 = (*(_BYTE *)v2 ^ 0xEC) + 2, v1 < v3)
        || (v4 = *(_BYTE *)(v3 + v2 - 1) ^ 0xEA, v22 = (void *)(v4 + v3), v1 < v4 + v3) )
        goto LABEL_48;
      sub_1000A3F0(a1, v3 + v2, v4);
      v1 -= (signed int)v22;
      v2 += (int)v22;
      *(_DWORD *)(a1 + 1472) = 1;
      sub_1000D480(a1 + 1204, v2, v1);
      goto LABEL_6;
    case 1:
LABEL_6:
      if ( v1 < 6
        || (v5 = *(_DWORD *)(a1 + 1164),
            *(_DWORD *)(a1 + 1176) = *(_DWORD *)v2,
            (*(void (__cdecl **)(int, signed int, int, int))(a1 + 1152))(a1, 6, dword_10011648, v5),
            v6 = *(_WORD *)(v2 + 4),
            *(_WORD *)(a1 + 1184) = v6,
            v6 == -1)
        && (sub_10009F70(v2 + 6, v1 - 6) == -1
         || (v7 = *(_DWORD *)(a1 + 1164),
             *(_DWORD *)(a1 + 1188) = v2 + 6,
             (*(void (__cdecl **)(int, signed int, int, int))(a1 + 1152))(a1, 5, dword_10011648, v7),
             !*(_DWORD *)(a1 + 116))) )
        goto LABEL_48;
      v2 += 6;
      v1 -= 6;
      if ( *(_BYTE *)(a1 + 1468) & 2 || *(_WORD *)(a1 + 1184) == -1 )
      {
        *(_DWORD *)(a1 + 1472) = 5;
        *(_DWORD *)a1 = 2;
        goto LABEL_48;
      }
      *(_DWORD *)(a1 + 1472) = 2;
      *(_DWORD *)(a1 + 1148) = -1;
LABEL_13:
      if ( *(_DWORD *)(a1 + 1148) == -1 )
      {
        if ( v1 < 1 )
          goto LABEL_48;
        v8 = *(_BYTE *)v2;
        *(_DWORD *)(a1 + 1148) = v8;
        v9 = sub_10009330(8, v8, 0);
        *(_DWORD *)(a1 + 8) = v9;
        if ( !v9 )
          return 5;
        ++v2;
        --v1;
      }
      if ( *(_DWORD *)(a1 + 1148) <= sub_100093A0(*(_DWORD *)(a1 + 8)) )
        goto LABEL_26;
      break;
    case 2:
      goto LABEL_13;
    case 3:
      goto LABEL_28;
    case 4:
      goto LABEL_40;
    default:
      goto LABEL_48;
  }
  do
  {
    if ( v1 < 2 )
      break;
    v10 = 0;
    if ( v1 - 1 <= 0 )
      break;
    while ( *(_BYTE *)(v2 + 1 + v10) )
    {
      ++v10;
      if ( v10 >= v1 - 1 )
        goto LABEL_26;
    }
    v11 = v10 + 1;
    if ( v10 == -2 )
      break;
    v23 = *(_BYTE *)v2;
    v12 = sub_10009EA0(a1, (const char *)(v2 + 1));
    v13 = *(_DWORD *)(a1 + 8);
    v22 = v12;
    sub_10009940(v13, &v22);
    v2 += v11 + 1;
    v1 += -1 - v11;
  }
  while ( *(_DWORD *)(a1 + 1148) > sub_100093A0(*(_DWORD *)(a1 + 8)) );
LABEL_26:
  if ( *(_DWORD *)(a1 + 1148) <= sub_100093A0(*(_DWORD *)(a1 + 8)) )
  {
    *(_DWORD *)(a1 + 1472) = 3;
    *(_DWORD *)(a1 + 1148) = -1;
LABEL_28:
    if ( *(_DWORD *)(a1 + 1148) == -1 )
    {
      if ( v1 < 1 )
        goto LABEL_48;
      v14 = *(_BYTE *)v2++;
      *(_DWORD *)(a1 + 1148) = v14;
      *(_DWORD *)(a1 + 1144) = 0;
      --v1;
    }
    if ( *(_DWORD *)(a1 + 1148) > *(_DWORD *)(a1 + 1144) )
    {
      do
      {
        v15 = 0;
        if ( v1 <= 0 )
          break;
        while ( *(_BYTE *)(v15 + v2) )
        {
          ++v15;
          if ( v15 >= v1 )
            goto LABEL_38;
        }
        v16 = v15 + 1;
        if ( v15 == -2 )
          break;
        *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 1144) + 124) = sub_10009EA0(a1, (const char *)v2);
        v17 = *(_DWORD *)(a1 + 1144) + 1;
        *(_DWORD *)(a1 + 1144) = v17;
        v2 += v16;
        v1 -= v16;
      }
      while ( *(_DWORD *)(a1 + 1148) > v17 );
    }
LABEL_38:
    if ( *(_DWORD *)(a1 + 1148) <= *(_DWORD *)(a1 + 1144) )
    {
      *(_DWORD *)(a1 + 1472) = 4;
LABEL_40:
      if ( v1 >= 5 )
      {
        while ( 1 )
        {
          v18 = sub_1000A800(v2, a1, v1);
          if ( v18 == -2 )
            return 5;
          if ( v18 == -1 )
            break;
          v2 += v18;
          v1 -= v18;
          if ( !*(_DWORD *)(a1 + 116) || !v18 )
            goto LABEL_48;
        }
        v20 = *(_DWORD *)(a1 + 1164);
        *(_DWORD *)(a1 + 1472) = 5;
        *(_DWORD *)a1 = 2;
        v1 -= 5;
        v2 += 5;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD, int))(a1 + 1152))(a1, 3, dword_10011648, v20);
      }
    }
  }
LABEL_48:
  v21 = *(void **)(a1 + 116);
  if ( v21 )
  {
    if ( v1 )
      memmove(v21, (const void *)v2, v1);
    *(_DWORD *)(a1 + 120) = v1;
  }
  return 0;
}
// 10011648: using guessed type int dword_10011648;

//----- (1000ACA0) --------------------------------------------------------
signed int __usercall sub_1000ACA0<eax>(signed int *a1<eax>, int a2<ecx>, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ebp@1
  void *v7; // eax@3
  signed int result; // eax@4
  int v9; // eax@7
  int v10; // edi@11
  void *v11; // eax@12
  int v12; // ST00_4@12
  bool v13; // sf@12
  unsigned __int8 v14; // of@12
  signed int v15; // [sp+10h] [bp-Ch]@1
  void *v16; // [sp+14h] [bp-8h]@12
  int v17; // [sp+18h] [bp-4h]@12
  int v18; // [sp+20h] [bp+4h]@5

  v3 = *(_BYTE *)a1;
  v4 = a2;
  v5 = (int)((char *)a1 + 1);
  v6 = a3 - 1;
  v15 = *(_BYTE *)a1;
  if ( *(_DWORD *)(a2 + 8) )
    sub_1000A2B0(a2);
  v7 = sub_10009330(8, v3, 0);
  *(_DWORD *)(v4 + 8) = v7;
  if ( v7 )
  {
    v18 = 0;
    if ( v3 <= 0 )
    {
LABEL_13:
      result = 0;
    }
    else
    {
      while ( v6 >= 2 )
      {
        v9 = 0;
        if ( v6 - 1 <= 0 )
          break;
        while ( *(_BYTE *)(v5 + 1 + v9) )
        {
          ++v9;
          if ( v9 >= v6 - 1 )
            goto LABEL_10;
        }
        v10 = v9 + 1;
        if ( v9 == -2 )
          break;
        v17 = *(_BYTE *)v5;
        v11 = sub_10009EA0(v4, (const char *)(v5 + 1));
        v12 = *(_DWORD *)(v4 + 8);
        v16 = v11;
        sub_10009940(v12, &v16);
        v6 += -1 - v10;
        v14 = __OFSUB__(v18 + 1, v15);
        v13 = v18 + 1 - v15 < 0;
        v5 += v10 + 1;
        ++v18;
        if ( !(v13 ^ v14) )
          goto LABEL_13;
      }
LABEL_10:
      result = 4;
    }
  }
  else
  {
    result = 5;
  }
  return result;
}

//----- (1000AD70) --------------------------------------------------------
signed int __usercall sub_1000AD70<eax>(signed int a1<eax>, int a2<ecx>, int a3)
{
  signed int result; // eax@2
  int v4; // esi@3
  int v5; // edi@3
  int v6; // eax@4
  char v7; // cl@5
  int v8; // edi@9
  int v9; // esi@9
  int v10; // ebx@10
  int v11; // edi@10
  int v12; // esi@10
  int v13; // ecx@10
  int v14; // ebp@14
  char v15; // [sp+Bh] [bp-11h]@3
  int v16; // [sp+Ch] [bp-10h]@3
  int v17; // [sp+14h] [bp-8h]@4
  int v18; // [sp+18h] [bp-4h]@3

  if ( a1 >= 2 )
  {
    v15 = *(_BYTE *)a2;
    v4 = a2 + 2;
    v5 = a1 - 2;
    v16 = 0;
    v18 = *(_BYTE *)(a2 + 1);
    if ( v18 <= 0 )
    {
LABEL_16:
      if ( v15 )
        (*(void (__cdecl **)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a3 + 1160))(
          a3,
          0,
          0,
          0,
          0,
          0,
          *(_DWORD *)(a3 + 1164));
      result = 0;
    }
    else
    {
      while ( 1 )
      {
        v6 = 0;
        v17 = v4;
        if ( v5 <= 0 )
          break;
        while ( 1 )
        {
          v7 = *(_BYTE *)(v6++ + v4);
          if ( !v7 )
            break;
          if ( v6 >= v5 )
            goto LABEL_7;
        }
        if ( v6 == -1 )
          break;
        v8 = v5 - v6;
        v9 = v6 + v4;
        if ( v8 < 11 )
          break;
        v10 = *(_DWORD *)v9;
        ntohl(*(_DWORD *)(v9 + 6));
        v11 = v8 - 10;
        v12 = v9 + 10;
        v13 = 0;
        if ( v11 <= 0 )
          break;
        while ( *(_BYTE *)(v13 + v12) )
        {
          ++v13;
          if ( v13 >= v11 )
            return 4;
        }
        v14 = v13 + 1;
        if ( v13 == -2 )
          break;
        (*(void (__cdecl **)(int, int, int))(a3 + 1160))(a3, v17, v10);
        v4 = v14 + v12;
        v5 = v11 - v14;
        ++v16;
        if ( v16 >= v18 )
          goto LABEL_16;
      }
LABEL_7:
      result = 4;
    }
  }
  else
  {
    result = 4;
  }
  return result;
}

//----- (1000AEA0) --------------------------------------------------------
signed int __usercall sub_1000AEA0<eax>(signed int a1<eax>, int a2<ecx>, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  signed int result; // eax@2
  int v6; // eax@3
  u_long v7; // eax@5
  signed int v8; // ebx@5
  int v9; // esi@5
  int v10; // edi@5
  signed int v11; // edx@5
  int v12; // ecx@8
  int v13; // ecx@12
  void (__cdecl *v14)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // ecx@14
  int v15; // [sp+Ch] [bp-44h]@5
  int v16[16]; // [sp+10h] [bp-40h]@13

  v3 = a1;
  v4 = a2;
  if ( a1 >= 11 )
  {
    v6 = sub_10009C60(a3, *(_DWORD *)a2, *(_WORD *)(a2 + 4));
    if ( v6 == -1 )
    {
      result = 0;
    }
    else
    {
      v15 = *(_DWORD *)sub_100093B0(*(_DWORD *)(a3 + 4), v6);
      v7 = ntohl(*(_DWORD *)(v4 + 6));
      v8 = *(_BYTE *)(v4 + 10);
      v9 = v4 + 11;
      v10 = v3 - 11;
      v11 = 0;
      if ( v8 > 0 )
      {
        while ( v11 < 16 && v10 >= 1 )
        {
          v12 = 0;
          if ( v10 <= 0 )
            return 4;
          while ( *(_BYTE *)(v12 + v9) )
          {
            ++v12;
            if ( v12 >= v10 )
              return 4;
          }
          v13 = v12 + 1;
          if ( v13 == -1 )
            return 4;
          v16[v11] = v9;
          v9 += v13;
          v10 -= v13;
          ++v11;
          if ( v11 >= v8 )
            break;
        }
      }
      v14 = *(void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a3 + 1156);
      if ( v14 )
        v14(a3, v15, v7, v11, v16, *(_DWORD *)(a3 + 1164));
      result = 0;
    }
  }
  else
  {
    result = 4;
  }
  return result;
}
// 1000AEA0: using guessed type int var_40[16];

//----- (1000AFB0) --------------------------------------------------------
signed int __usercall sub_1000AFB0<eax>(int a1<esi>, int a2, int a3)
{
  signed int result; // eax@2
  int v4; // ebx@3
  __int16 v5; // di@5
  int v6; // ebp@8
  int v7; // eax@9
  int v8; // ebx@9
  int v9; // eax@9

  if ( a3 < 5 )
    return 4;
  v4 = *(_DWORD *)(a2 + 1);
  if ( *(_BYTE *)a2 & 0x10 )
  {
    if ( a3 - 5 < 2 )
      v5 = a3;
    else
      v5 = *(_WORD *)(a2 + 5);
  }
  else
  {
    v5 = *(_WORD *)(a1 + 1184);
  }
  v6 = sub_10009C60(a1, v4, v5);
  if ( v6 == -1 )
  {
    v7 = (int)sub_10004400(a1, v4, v5);
    v8 = v7;
    LOBYTE(v9) = sub_10004510(v7);
    if ( v9 )
      return 5;
  }
  else
  {
    v8 = *(_DWORD *)sub_100093B0(*(_DWORD *)(a1 + 4), v6);
  }
  if ( sub_1000A5E0(a3, (char *)a2, v8, a1, 0) >= 0 )
  {
    if ( v6 == -1 )
      sub_10009BE0(a1, v8);
    (*(void (__cdecl **)(int, signed int, int, _DWORD))(a1 + 1152))(a1, 1, v8, *(_DWORD *)(a1 + 1164));
    result = 0;
  }
  else
  {
    result = 4;
  }
  return result;
}

//----- (1000B080) --------------------------------------------------------
signed int __usercall sub_1000B080<eax>(int a1<esi>)
{
  SOCKET v1; // ST1C_4@1
  int v2; // eax@4
  int v3; // edi@4
  int v4; // eax@4
  int v5; // ST10_4@5
  int v6; // ST1C_4@8
  int v8; // [sp+4h] [bp-5F4h]@5
  int fromlen; // [sp+8h] [bp-5F0h]@1
  struct sockaddr from; // [sp+Ch] [bp-5ECh]@2
  char buf; // [sp+1Ch] [bp-5DCh]@2

  v1 = *(_DWORD *)(a1 + 1192);
  fromlen = 16;
  if ( sub_10004A40(v1) )
  {
    do
    {
      if ( recvfrom(*(_DWORD *)(a1 + 1192), &buf, 1499, 0, &from, &fromlen) != -1
        && sub_10009C60(a1, *(int *)&from.sa_data[2], *(__int16 *)&from.sa_data[0]) == -1 )
      {
        v2 = (int)sub_10004400(a1, *(int *)&from.sa_data[2], *(__int16 *)&from.sa_data[0]);
        v3 = v2;
        LOBYTE(v4) = sub_10004510(v2);
        if ( v4 )
          return 5;
        sub_10004480(v3, 17);
        v5 = *(_DWORD *)(a1 + 4);
        v8 = v3;
        sub_10009940(v5, &v8);
        (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(a1 + 1152))(a1, 0, v8, *(_DWORD *)(a1 + 1164));
      }
    }
    while ( sub_10004A40(*(_DWORD *)(a1 + 1192)) );
  }
  if ( GetTickCount() - *(_DWORD *)(a1 + 1196) > 0x7D0 )
  {
    closesocket(*(_DWORD *)(a1 + 1192));
    v6 = *(_DWORD *)(a1 + 1164);
    *(_DWORD *)(a1 + 1192) = -1;
    *(_DWORD *)a1 = 1;
    (*(void (__cdecl **)(int, signed int, int, int))(a1 + 1152))(a1, 3, dword_10011648, v6);
  }
  return 0;
}
// 10011648: using guessed type int dword_10011648;

//----- (1000B1C0) --------------------------------------------------------
void __cdecl sub_1000B1C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // eax@2
  char v8; // cl@3
  int v9; // eax@4
  char v10; // cl@5
  int v11; // eax@6
  char v12; // cl@7
  unsigned int v13; // eax@8

  if ( dword_10011FE0 == 1 )
  {
    *(_DWORD *)a1 = 1;
    *(_DWORD *)(a1 + 4) = sub_10009330(4, 100, 0);
    *(_DWORD *)(a1 + 1480) = 0;
    sub_10004550();
    v7 = a2;
    do
    {
      v8 = *(_BYTE *)v7;
      *(_BYTE *)(a1 + 12 - a2 + v7) = *(_BYTE *)v7;
      ++v7;
    }
    while ( v8 );
    v9 = a3;
    do
    {
      v10 = *(_BYTE *)v9;
      *(_BYTE *)(a1 + 44 - a3 + v9) = *(_BYTE *)v9;
      ++v9;
    }
    while ( v10 );
    v11 = a4;
    do
    {
      v12 = *(_BYTE *)v11;
      *(_BYTE *)(a1 + 76 - a4 + v11) = *(_BYTE *)v11;
      ++v11;
    }
    while ( v12 );
    *(_DWORD *)(a1 + 1152) = a6;
    *(_DWORD *)(a1 + 1164) = a7;
    *(_DWORD *)(a1 + 1156) = 0;
    *(_DWORD *)(a1 + 1168) = &unk_1000E7EB;
    *(_DWORD *)(a1 + 1176) = 0;
    *(_DWORD *)(a1 + 1192) = -1;
    *(_DWORD *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 1148) = -1;
    *(_DWORD *)(a1 + 1144) = 0;
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1200) = a5;
    *(_DWORD *)(a1 + 1188) = &unk_1000E7EB;
    *(_DWORD *)(a1 + 1476) = 0;
    v13 = GetTickCount();
    srand(v13);
    sub_10004740();
  }
}
// 10011FE0: using guessed type int dword_10011FE0;

//----- (1000B2B0) --------------------------------------------------------
int __usercall sub_1000B2B0<eax>(int a1<esi>)
{
  unsigned int v1; // edx@1
  int v2; // ST0C_4@4

  v1 = *(_DWORD *)(a1 + 120);
  if ( (signed int)v1 > 0 && v1 > strlen(Str2) && !strncmp(*(const char **)(a1 + 116), Str2, strlen(Str2)) )
  {
    v2 = *(_DWORD *)(a1 + 1164);
    *(_DWORD *)(a1 + 1188) = strlen(Str2) + *(_DWORD *)(a1 + 116);
    (*(void (__cdecl **)(int, signed int, int, int))(a1 + 1152))(a1, 5, dword_10011648, v2);
  }
  (*(void (__cdecl **)(int, signed int, int, _DWORD))(a1 + 1152))(a1, 4, dword_10011648, *(_DWORD *)(a1 + 1164));
  return sub_1000A350(a1);
}
// 10011648: using guessed type int dword_10011648;

//----- (1000B350) --------------------------------------------------------
signed int __cdecl sub_1000B350(int a1, const char *a2, const char *a3, u_long hostlong, int a5)
{
  const char *v5; // ebp@3
  signed int result; // eax@7
  void **v7; // edx@9
  int v8; // ecx@9
  void **v9; // edx@9
  u_long v10; // eax@9
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // esi@9
  int v14; // ecx@9
  u_short v15; // ax@13
  SOCKET v16; // ecx@13
  bool v17; // zf@15
  void *v18; // eax@16
  int v19; // [sp+0h] [bp-308h]@9
  int v20; // [sp+4h] [bp-304h]@9
  char buf[2]; // [sp+8h] [bp-300h]@13
  char v22; // [sp+Ah] [bp-2FEh]@9
  char v23; // [sp+Bh] [bp-2FDh]@9
  char v24; // [sp+Ch] [bp-2FCh]@9
  int v25; // [sp+Dh] [bp-2FBh]@9
  char v26; // [sp+11h] [bp-2F7h]@9

  if ( !a2 )
    a2 = (const char *)&unk_1000E7EB;
  v5 = a3;
  if ( !a3 )
    v5 = (const char *)&unk_1000E7EB;
  if ( strlen(a2) > 0x100 || strlen(v5) > 0x100 )
    return 6;
  result = sub_10009FE0(a1);
  if ( !result )
  {
    *(_DWORD *)(a1 + 1468) = hostlong;
    sub_1000A190(a1);
    v25 = *(_DWORD *)(a1 + 1200);
    v22 = 0;
    v23 = 1;
    v24 = 3;
    v19 = 9;
    v20 = (int)&v26;
    sub_1000A0F0((const void *)(a1 + 12), (void **)&v20, (int)&v19);
    sub_1000A0F0((const void *)(a1 + 44), v7, (int)&v19);
    v8 = v20;
    *(_DWORD *)v20 = *(_DWORD *)(a1 + 108);
    *(_DWORD *)(v8 + 4) = *(_DWORD *)(a1 + 112);
    v19 += 8;
    v20 = v8 + 8;
    sub_1000A0F0(v5, (void **)&v20, (int)&v19);
    sub_1000A0F0(a2, v9, (int)&v19);
    v10 = htonl(hostlong);
    v11 = v20;
    v12 = v19;
    *(_DWORD *)v20 = v10;
    v13 = v12 + 4;
    v14 = v11 + 4;
    if ( *(_BYTE *)(a1 + 1468) & 8 )
    {
      *(_DWORD *)v14 = *(_DWORD *)(a1 + 1180);
      v13 += 4;
      v14 += 4;
    }
    if ( *(_BYTE *)(a1 + 1468) < 0 )
    {
      *(_DWORD *)v14 = a5;
      v13 += 4;
    }
    v15 = htons(v13);
    v16 = *(_DWORD *)(a1 + 1192);
    *(_WORD *)buf = v15;
    if ( send(v16, buf, v13, 0) <= 0 )
    {
      sub_1000A350(a1);
      return 3;
    }
    v17 = *(_DWORD *)(a1 + 116) == 0;
    *(_DWORD *)a1 = 3;
    *(_DWORD *)(a1 + 1472) = 0;
    if ( v17 )
    {
      v18 = malloc(0x1000u);
      *(_DWORD *)(a1 + 116) = v18;
      if ( !v18 )
        return 5;
      *(_DWORD *)(a1 + 120) = 0;
    }
    result = 0;
  }
  return result;
}

//----- (1000B540) --------------------------------------------------------
signed int __cdecl sub_1000B540(char optval, u_short hostshort, unsigned __int16 a3, int a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  SOCKET v6; // eax@3
  const char *v7; // eax@5
  SOCKET v8; // ST14_4@6
  signed int result; // eax@7
  unsigned __int16 v10; // bx@8
  int v11; // edi@10
  int v12; // ebp@11
  SOCKET v13; // [sp-20h] [bp-50h]@13
  const char *v14; // [sp-1Ch] [bp-4Ch]@13
  int v15; // [sp-18h] [bp-48h]@13
  char v16; // [sp+8h] [bp-28h]@1
  char v17; // [sp+9h] [bp-27h]@1
  __int16 v18; // [sp+Ah] [bp-26h]@1
  char v19; // [sp+Ch] [bp-24h]@1
  char v20; // [sp+Dh] [bp-23h]@1
  char v21; // [sp+Eh] [bp-22h]@1
  char v22; // [sp+Fh] [bp-21h]@1
  struct sockaddr to; // [sp+10h] [bp-20h]@5
  struct sockaddr name; // [sp+20h] [bp-10h]@6

  v4 = optval;
  v5 = *(_DWORD *)optval == 1;
  v16 = -2;
  v17 = -3;
  v18 = 2;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if ( !v5 )
    sub_1000A350(optval);
  v6 = socket(2, 2, 17);
  *(_DWORD *)(v4 + 1192) = v6;
  if ( v6 == -1
    || (*(_DWORD *)&optval = 1, setsockopt(v6, 65535, 32, &optval, 4))
    || (v7 = *(const char **)(v4 + 1476), to.sa_family = 2, *(_DWORD *)&to.sa_data[2] = -1, v7)
    && (name.sa_family = 2,
        *(_DWORD *)&name.sa_data[2] = inet_addr(v7),
        v8 = *(_DWORD *)(v4 + 1192),
        *(_WORD *)&name.sa_data[0] = 0,
        bind(v8, &name, 16)) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( a3 - hostshort > 500 )
      v10 = hostshort + 500;
    v11 = hostshort;
    if ( hostshort <= v10 )
    {
      v12 = a4;
      do
      {
        *(_WORD *)&to.sa_data[0] = htons(v11);
        if ( v12 == 1 )
        {
          v15 = 8;
          v14 = &v16;
          v13 = *(_DWORD *)(v4 + 1192);
        }
        else
        {
          v15 = 10;
          v14 = "\\echo\\test";
          v13 = *(_DWORD *)(v4 + 1192);
        }
        sendto(v13, v14, v15, 0, &to, 16);
        ++v11;
      }
      while ( (unsigned __int16)v11 <= v10 );
    }
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 1196) = GetTickCount();
    result = 0;
  }
  return result;
}

//----- (1000B690) --------------------------------------------------------
signed int __usercall sub_1000B690<eax>(int a1<eax>)
{
  int v1; // esi@1
  signed int v2; // ebx@1
  u_short v3; // ax@2
  int v4; // edi@3
  int v5; // ecx@4
  signed int v6; // eax@5
  signed int result; // eax@8
  int v8; // eax@11
  int v9; // eax@17
  size_t v10; // ecx@17
  void *v11; // eax@18

  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 120) < 3 )
  {
LABEL_25:
    result = v2;
  }
  else
  {
    while ( 1 )
    {
      v3 = ntohs(**(_WORD **)(v1 + 116));
      if ( v3 > 0x1000u )
      {
        v2 = 4;
LABEL_24:
        sub_1000B2B0(v1);
        goto LABEL_25;
      }
      v4 = v3;
      if ( *(_DWORD *)(v1 + 120) < (signed int)v3 )
        break;
      v5 = *(_DWORD *)(v1 + 116);
      switch ( *(_BYTE *)(v5 + 2) )
      {
        case 1:
          v6 = sub_1000ACA0((signed int *)(v5 + 3), v1, v3 - 3);
          goto LABEL_16;
        case 2:
          v6 = sub_1000AFB0(v1, v5 + 3, v3 - 3);
          goto LABEL_16;
        case 3:
          if ( send(*(_DWORD *)(v1 + 1192), (const char *)v5, v3, 0) > 0 )
            break;
          return 3;
        case 4:
          if ( v3 - 3 >= 6 )
          {
            v8 = sub_10009C60(v1, *(_DWORD *)(v5 + 3), *(_WORD *)(v5 + 7));
            if ( v8 == -1 )
            {
              v2 = 0;
            }
            else
            {
              sub_10009D00(v1, v8);
              v2 = 0;
            }
          }
          else
          {
            v2 = 4;
          }
          break;
        case 5:
          v6 = sub_1000AEA0(v3 - 3, v5 + 3, v1);
          goto LABEL_16;
        case 6:
          v6 = sub_1000AD70(v3 - 3, v5 + 3, v1);
LABEL_16:
          v2 = v6;
          break;
        default:
          break;
      }
      v9 = *(_DWORD *)(v1 + 120) - v4;
      *(_DWORD *)(v1 + 120) = v9;
      v10 = v9;
      if ( v9 )
      {
        v11 = *(void **)(v1 + 116);
        if ( v11 )
          memmove(v11, (char *)v11 + v4, v10);
      }
      if ( v2 )
        goto LABEL_24;
      if ( *(_DWORD *)(v1 + 120) < 3 )
        return 0;
    }
    result = 0;
  }
  return result;
}

//----- (1000B8A0) --------------------------------------------------------
signed int __cdecl sub_1000B8A0(int a1)
{
  signed int result; // eax@4
  int v2; // edi@8
  int v3; // eax@8
  int v4; // edx@10
  bool v5; // zf@10
  signed int v6; // eax@1

  sub_10009DA0(a1);
  v6 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v6 <= 1 || v6 > 3 )
    {
      result = 0;
    }
    else
    {
      result = sub_10004A40(*(_DWORD *)(a1 + 1192));
      if ( result )
      {
        v2 = *(_DWORD *)(a1 + 120);
        v3 = recv(*(_DWORD *)(a1 + 1192), (char *)(v2 + *(_DWORD *)(a1 + 116)), 4096 - v2, 0);
        if ( v3 != -1 && v3 )
        {
          v4 = v3 + *(_DWORD *)(a1 + 120);
          v5 = *(_DWORD *)a1 == 2;
          *(_DWORD *)(a1 + 120) = v4;
          if ( v5 || *(_DWORD *)(a1 + 1472) > 0 )
            sub_1000D480(a1 + 1204, v2 + *(_DWORD *)(a1 + 116), v4 - v2);
          if ( *(_DWORD *)a1 != 3 || (result = sub_1000A920(a1)) == 0 )
          {
            if ( *(_DWORD *)a1 != 2 || *(_DWORD *)(a1 + 120) <= 0 )
              result = 0;
            else
              result = sub_1000B690(a1);
          }
        }
        else
        {
          sub_1000B2B0(a1);
          result = 3;
        }
      }
    }
  }
  else
  {
    result = sub_1000B080(a1);
  }
  return result;
}

//----- (1000B8E0) --------------------------------------------------------
signed int __usercall sub_1000B8E0<eax>(int a1<eax>, const char *buf, int len)
{
  int v3; // esi@1
  signed int v4; // ebp@1
  SOCKET v5; // eax@6
  signed int v6; // edi@8

  v3 = a1;
  v4 = 1;
  while ( 1 )
  {
    --v4;
    if ( send(*(_DWORD *)(v3 + 1192), buf, len, 0) > 0 )
      break;
    if ( v4 < 0 )
      return 3;
    if ( *(_DWORD *)(v3 + 116) )
      free(*(void **)(v3 + 116));
    v5 = *(_DWORD *)(v3 + 1192);
    *(_DWORD *)(v3 + 116) = 0;
    *(_DWORD *)(v3 + 120) = 0;
    if ( v5 != -1 )
      closesocket(v5);
    *(_DWORD *)(v3 + 1192) = -1;
    *(_DWORD *)v3 = 1;
    sub_1000A2B0(v3);
    *(_DWORD *)(v3 + 1148) = -1;
    sub_1000A220(v3);
    v6 = sub_1000B350(v3, 0, 0, 2u, 0);
    if ( v6 )
    {
      sub_1000B2B0(v3);
      return v6;
    }
  }
  return 0;
}

//----- (1000B990) --------------------------------------------------------
signed int __cdecl sub_1000B990(int a1, int a2, __int16 a3)
{
  signed int result; // eax@3
  u_short v4; // [sp+4h] [bp-10h]@4
  char v5; // [sp+6h] [bp-Eh]@4
  int v6; // [sp+7h] [bp-Dh]@4
  __int16 v7; // [sp+Bh] [bp-9h]@4

  if ( *(_DWORD *)a1 != 1 || (sub_1000B350(a1, 0, 0, 2u, 0), *(_DWORD *)a1 != 1) )
  {
    v4 = htons(9u);
    v6 = a2;
    v5 = 1;
    v7 = a3;
    result = sub_1000B8E0(a1, (const char *)&v4, 9);
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (1000BA00) --------------------------------------------------------
signed int __cdecl sub_1000BA00(int a1, int a2, __int16 a3, const char *buf, int len)
{
  signed int result; // eax@3
  u_short v6; // [sp+4h] [bp-10h]@4
  char v7; // [sp+6h] [bp-Eh]@4
  int v8; // [sp+7h] [bp-Dh]@4
  __int16 v9; // [sp+Bh] [bp-9h]@4

  if ( *(_DWORD *)a1 != 1 || (sub_1000B350(a1, 0, 0, 2u, 0), *(_DWORD *)a1 != 1) )
  {
    v6 = htons(len + 9);
    v7 = 2;
    v8 = a2;
    v9 = a3;
    result = sub_1000B8E0(a1, (const char *)&v6, 9);
    if ( !result )
      result = ((send(*(_DWORD *)(a1 + 1192), buf, len, 0) >= 0) - 1) & 3;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (1000BBF0) --------------------------------------------------------
signed int __cdecl sub_1000BBF0(int a1, int a2, __int16 a3, u_long hostlong)
{
  char buf; // [sp+0h] [bp-Ch]@1
  char v6; // [sp+1h] [bp-Bh]@1
  char v7; // [sp+2h] [bp-Ah]@1
  char v8; // [sp+3h] [bp-9h]@1
  char v9; // [sp+4h] [bp-8h]@1
  char v10; // [sp+5h] [bp-7h]@1
  u_long v11; // [sp+6h] [bp-6h]@1

  buf = -3;
  v6 = -4;
  v7 = 30;
  v8 = 102;
  v9 = 106;
  v10 = -78;
  v11 = htonl(hostlong);
  return sub_1000BA00(a1, a2, a3, &buf, 10);
}

//----- (1000BC40) --------------------------------------------------------
void *__cdecl sub_1000BC40(int a1, int a2, signed int a3, int a4, int a5, int a6)
{
  void *v6; // edi@1
  int v7; // esi@1

  v6 = malloc(0x14u);
  v7 = 0;
  for ( *(_DWORD *)v6 = malloc(4 * a2); v7 < a2; ++v7 )
    *(_DWORD *)(*(_DWORD *)v6 + 4 * v7) = sub_10009330(a1, a3, a6);
  *((_DWORD *)v6 + 3) = a4;
  *((_DWORD *)v6 + 1) = a2;
  *((_DWORD *)v6 + 2) = a6;
  *((_DWORD *)v6 + 4) = a5;
  return v6;
}

//----- (1000BCB0) --------------------------------------------------------
void __cdecl sub_1000BCB0(void *Memory)
{
  int i; // edi@2

  if ( Memory )
  {
    for ( i = 0; i < *((_DWORD *)Memory + 1); ++i )
      sub_10009610(*(void **)(*(_DWORD *)Memory + 4 * i));
    free(*(void **)Memory);
    free(Memory);
  }
}

//----- (1000BCF0) --------------------------------------------------------
int __cdecl sub_1000BCF0(int a1)
{
  int v1; // ebx@1
  int result; // eax@2
  int i; // esi@3

  v1 = 0;
  if ( a1 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
      v1 += sub_100093A0(*(_DWORD *)(*(_DWORD *)a1 + 4 * i));
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000BD30) --------------------------------------------------------
void __cdecl sub_1000BD30(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ebx@2
  int v4; // eax@2

  if ( a1 )
  {
    v2 = (*(int (__cdecl **)(int, _DWORD))(a1 + 12))(a2, *(_DWORD *)(a1 + 4));
    v3 = v2;
    v4 = sub_10009840(*(_DWORD *)(*(_DWORD *)a1 + 4 * v2), a2, *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 16), 0, 0);
    if ( v4 == -1 )
      sub_10009940(*(_DWORD *)(*(_DWORD *)a1 + 4 * v3), (const void *)a2);
    else
      sub_100097F0(*(_DWORD *)(*(_DWORD *)a1 + 4 * v3), (const void *)a2, v4);
  }
}

//----- (1000BD90) --------------------------------------------------------
signed int __cdecl sub_1000BD90(int a1, int a2)
{
  signed int result; // eax@2
  int v3; // eax@3
  int v4; // edi@3
  int v5; // eax@3

  if ( a1 )
  {
    v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 12))(a2, *(_DWORD *)(a1 + 4));
    v4 = v3;
    v5 = sub_10009840(*(_DWORD *)(*(_DWORD *)a1 + 4 * v3), a2, *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 16), 0, 0);
    if ( v5 == -1 )
    {
      result = 0;
    }
    else
    {
      sub_10009790(*(_DWORD *)(*(_DWORD *)a1 + 4 * v4), v5);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000BDF0) --------------------------------------------------------
int __cdecl sub_1000BDF0(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // edi@3
  int v5; // eax@3

  if ( a1 )
  {
    v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 12))(a2, *(_DWORD *)(a1 + 4));
    v4 = v3;
    v5 = sub_10009840(*(_DWORD *)(*(_DWORD *)a1 + 4 * v3), a2, *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 16), 0, 0);
    if ( v5 == -1 )
      result = 0;
    else
      result = sub_100093B0(*(_DWORD *)(*(_DWORD *)a1 + 4 * v4), v5);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000BE50) --------------------------------------------------------
int __cdecl sub_1000BE50(int a1, void (__cdecl *a2)(_DWORD, _DWORD), int a3)
{
  int result; // eax@3
  int i; // esi@3

  if ( a1 )
  {
    if ( a2 )
    {
      result = *(_DWORD *)(a1 + 4);
      for ( i = 0; i < result; ++i )
      {
        sub_10009420(*(_DWORD *)(*(_DWORD *)a1 + 4 * i), a2, a3);
        result = *(_DWORD *)(a1 + 4);
      }
    }
  }
  return result;
}

//----- (1000BFD0) --------------------------------------------------------
signed int __cdecl sub_1000BFD0(int a1, int a2)
{
  char v2; // dl@1
  char v4; // al@8

  v2 = *(_BYTE *)a1;
  if ( *(_BYTE *)a1 <= 0x7Fu )
  {
    *(_WORD *)a2 = v2;
    return 1;
  }
  if ( (v2 & 0xE0) == -64 )
  {
    if ( (*(_BYTE *)(a1 + 1) & 0xC0) == -128 )
    {
      *(_WORD *)a2 = (*(_BYTE *)(a1 + 1) & 0x3F) + ((v2 & 0x1F) << 6);
      return 2;
    }
  }
  else
  {
    if ( (v2 & 0xF0) == -32 )
    {
      if ( (*(_BYTE *)(a1 + 1) & 0xC0) == -128 )
      {
        v4 = *(_BYTE *)(a1 + 2);
        if ( (v4 & 0xC0) == -128 )
        {
          *(_WORD *)a2 = (v4 & 0x3F) + ((((signed __int16)v2 << 6) + (*(_BYTE *)(a1 + 1) & 0x3F)) << 6);
          return 3;
        }
      }
    }
  }
  *(_WORD *)a2 = 63;
  return 1;
}

//----- (1000C170) --------------------------------------------------------
int __cdecl sub_1000C170(int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@2

  HIWORD(v2) = HIWORD(a1);
  v3 = a2;
  v4 = 0;
  v5 = a1;
  if ( a1 )
  {
    if ( *(_WORD *)a1 )
    {
      do
      {
        LOWORD(v2) = *(_WORD *)v5;
        if ( *(_WORD *)v5 > 0x7Fu )
        {
          if ( (unsigned __int16)v2 > 0x7FFu )
          {
            *(_BYTE *)v3 = ((unsigned __int16)v2 >> 12) | 0xE0;
            *(_BYTE *)(v3 + 2) = v2 & 0x3F | 0x80;
            *(_BYTE *)(v3 + 1) = (v2 >> 6) & 0x3F | 0x80;
            v2 = 3;
          }
          else
          {
            *(_BYTE *)(v3 + 1) = v2 & 0x3F | 0x80;
            *(_BYTE *)v3 = (v2 >> 6) | 0xC0;
            v2 = 2;
          }
        }
        else
        {
          *(_BYTE *)v3 = v2;
          v2 = 1;
        }
        v5 += 2;
        v3 += v2;
        v4 += v2;
      }
      while ( *(_WORD *)v5 );
    }
    result = v4 + 1;
    *(_BYTE *)v3 = 0;
  }
  else
  {
    result = 1;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

//----- (1000C200) --------------------------------------------------------
int __cdecl sub_1000C200(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@2

  v2 = a1;
  v3 = 0;
  v4 = a2;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 )
    {
      do
      {
        v2 += sub_1000BFD0(v2, v4);
        ++v3;
        v4 += 2;
      }
      while ( *(_BYTE *)v2 );
    }
    *(_WORD *)v4 = 0;
    result = v3 + 1;
  }
  else
  {
    *(_WORD *)a2 = a1;
    result = 1;
  }
  return result;
}

//----- (1000C250) --------------------------------------------------------
int __cdecl sub_1000C250(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2
  char v4; // dl@8

  v1 = a1;
  v2 = 0;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 )
    {
      do
      {
        if ( (*(_BYTE *)v1 & 0xE0) != -64 || (*(_BYTE *)(v1 + 1) & 0xC0) != -128 )
        {
          if ( (*(_BYTE *)v1 & 0xF0) != -32
            || (v4 = *(_BYTE *)(v1 + 1) & 0xC0, v4 != -128)
            || (*(_BYTE *)(v1 + 2) & 0xC0) != v4 )
            ++v1;
          else
            v1 += 3;
        }
        else
        {
          v1 += 2;
        }
        ++v2;
      }
      while ( *(_BYTE *)v1 );
    }
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000C2B0) --------------------------------------------------------
int __cdecl sub_1000C2B0(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // edx@1
  unsigned __int16 v2; // cx@1
  int result; // eax@1

  v1 = a1;
  v2 = *a1;
  for ( result = 0; v2; ++v1 )
  {
    if ( v2 > 0x7Fu )
    {
      if ( v2 > 0x7FFu )
        result += 3;
      else
        result += 2;
    }
    else
    {
      ++result;
    }
    v2 = v1[1];
  }
  return result;
}

//----- (1000C320) --------------------------------------------------------
int __cdecl sub_1000C320(int a1)
{
  int result; // eax@2
  int v2; // eax@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = sub_1000C2B0((unsigned __int16 *)a1);
    v3 = (int)malloc(v2 + 1);
    sub_1000C170(a1, v3);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000C450) --------------------------------------------------------
int __cdecl sub_1000C450(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // esi@1
  int result; // eax@2

  v2 = a1;
  v3 = a2;
  v4 = 0;
  if ( a1 )
  {
    if ( *(_WORD *)a1 )
    {
      do
      {
        *(_BYTE *)v3++ = *(_BYTE *)v2;
        v2 += 2;
        ++v4;
      }
      while ( *(_WORD *)v2 );
    }
    result = v4 + 1;
    *(_BYTE *)v3 = 0;
  }
  else
  {
    result = 1;
    *(_BYTE *)a2 = 0;
  }
  return result;
}

//----- (1000C5E0) --------------------------------------------------------
int __cdecl sub_1000C5E0(int a1, char *Dest)
{
  char *v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2

  v2 = Dest;
  v3 = 0;
  do
  {
    result = sprintf(v2, "%02x", *(_BYTE *)(v3++ + a1));
    v2 += 2;
  }
  while ( v3 < 0x10 );
  return result;
}

//----- (1000C620) --------------------------------------------------------
int __thiscall sub_1000C620(void *this, int a2)
{
  int v2; // ecx@1
  int *v3; // esi@1
  signed int v4; // edi@1
  int v5; // ebx@2
  int v6; // edx@2
  int v7; // esi@3
  int v8; // edi@3
  int v9; // edx@3
  unsigned int v10; // ecx@3
  int v11; // eax@3
  unsigned int v12; // edx@3
  int v13; // ecx@3
  unsigned int v14; // edi@3
  int v15; // edx@3
  signed __int64 v16; // qdi@3
  unsigned int v17; // eax@3
  unsigned int v18; // ecx@3
  unsigned int v19; // edx@3
  unsigned int v20; // eax@3
  unsigned int v21; // ecx@3
  unsigned int v22; // edx@3
  unsigned int v23; // eax@3
  unsigned int v24; // ecx@3
  unsigned int v25; // ebx@3
  int v26; // edx@3
  signed int v27; // ebx@3
  signed int v28; // ST10_4@3
  unsigned int v29; // ebx@3
  int v30; // eax@3
  unsigned int v31; // ecx@3
  unsigned int v32; // edx@3
  int v33; // eax@3
  unsigned int v34; // ecx@3
  unsigned int v35; // edx@3
  int v36; // eax@3
  unsigned int v37; // ecx@3
  unsigned int v38; // edx@3
  unsigned int v39; // eax@3
  unsigned int v40; // ecx@3
  unsigned int v41; // edx@3
  int v42; // eax@3
  unsigned int v43; // ecx@3
  unsigned int v44; // ecx@3
  int v45; // edx@3
  int v46; // ecx@3
  unsigned int v47; // ebx@3
  int v48; // eax@3
  unsigned int v49; // edx@3
  unsigned int v50; // ebx@3
  int v51; // ecx@3
  int v52; // eax@3
  unsigned int v53; // edx@3
  unsigned int v54; // ebx@3
  int v55; // ecx@3
  signed __int64 v56; // qax@3
  unsigned int v57; // ecx@3
  unsigned int v58; // ecx@3
  unsigned int v59; // ecx@3
  unsigned int v60; // ecx@3
  unsigned int v61; // ecx@3
  int result; // eax@3
  int v63; // [sp+14h] [bp-40h]@1
  int v64; // [sp+18h] [bp-3Ch]@3
  int v65; // [sp+1Ch] [bp-38h]@3
  int v66; // [sp+20h] [bp-34h]@3
  int v67; // [sp+24h] [bp-30h]@3
  int v68; // [sp+28h] [bp-2Ch]@3
  int v69; // [sp+2Ch] [bp-28h]@3
  int v70; // [sp+30h] [bp-24h]@3
  int v71; // [sp+34h] [bp-20h]@3
  int v72; // [sp+38h] [bp-1Ch]@3
  int v73; // [sp+3Ch] [bp-18h]@3
  int v74; // [sp+40h] [bp-14h]@3
  int v75; // [sp+44h] [bp-10h]@3
  int v76; // [sp+48h] [bp-Ch]@3
  int v77; // [sp+4Ch] [bp-8h]@3
  int v78; // [sp+50h] [bp-4h]@3

  v2 = (int)((char *)this + 2);
  v3 = &v63;
  v4 = 16;
  do
  {
    v5 = *(_BYTE *)(v2 - 1);
    BYTE3(v6) = 0;
    *(_WORD *)((char *)&v6 + 1) = *(_BYTE *)(v2 + 1);
    ++v3;
    v2 += 4;
    LOBYTE(v6) = *(_BYTE *)(v2 - 4);
    --v4;
    *(v3 - 1) = *(_BYTE *)(v2 - 6) | ((v5 | (v6 << 8)) << 8);
  }
  while ( v4 );
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 12);
  v10 = *(_DWORD *)a2 + v63 + (v7 & v8 | v9 & ~v7) - 680876936;
  v11 = v7 + ((v10 << 7) | (v10 >> 25));
  v12 = v9 + v64 + (v11 & v7 | v8 & ~(v7 + ((v10 << 7) | (v10 >> 25)))) - 389564586;
  v13 = v11 + ((v12 << 12) | (v12 >> 20));
  v14 = v8 + v65 + (v11 & v13 | v7 & ~(v11 + ((v12 << 12) | (v12 >> 20)))) + 606105819;
  v15 = v13 + ((v14 << 17) | (v14 >> 15));
  LODWORD(v16) = v7 + v66 + (v15 & v13 | v11 & ~(v13 + ((v14 << 17) | (v14 >> 15)))) - 1044525330;
  HIDWORD(v16) = v16;
  HIDWORD(v16) = v15 + (unsigned __int64)(v16 >> 10);
  LODWORD(v16) = v11 + v67 + (HIDWORD(v16) & v15 | v13 & ~HIDWORD(v16)) - 176418897;
  v17 = HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25));
  LODWORD(v16) = v13
               + v68
               + (v17 & HIDWORD(v16) | v15 & ~(HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25))))
               + 1200080426;
  v18 = v17 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20));
  LODWORD(v16) = v15
               + v69
               + (v17 & v18 | HIDWORD(v16) & ~(v17 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20))))
               - 1473231341;
  v19 = v18 + (((_DWORD)v16 << 17) | ((unsigned int)v16 >> 15));
  LODWORD(v16) = HIDWORD(v16)
               + v70
               + (v19 & v18 | v17 & ~(v18 + (((_DWORD)v16 << 17) | ((unsigned int)v16 >> 15))))
               - 45705983;
  HIDWORD(v16) = v16;
  HIDWORD(v16) = v19 + (unsigned __int64)(v16 >> 10);
  LODWORD(v16) = v17 + v71 + (HIDWORD(v16) & v19 | v18 & ~HIDWORD(v16)) + 1770035416;
  v20 = HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25));
  LODWORD(v16) = v18
               + v72
               + (v20 & HIDWORD(v16) | v19 & ~(HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25))))
               - 1958414417;
  v21 = v20 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20));
  LODWORD(v16) = v19
               + v73
               + (v20 & v21 | HIDWORD(v16) & ~(v20 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20))))
               - 42063;
  v22 = v21 + (((_DWORD)v16 << 17) | ((unsigned int)v16 >> 15));
  LODWORD(v16) = HIDWORD(v16)
               + v74
               + (v22 & v21 | v20 & ~(v21 + (((_DWORD)v16 << 17) | ((unsigned int)v16 >> 15))))
               - 1990404162;
  HIDWORD(v16) = v16;
  HIDWORD(v16) = v22 + (unsigned __int64)(v16 >> 10);
  LODWORD(v16) = v20 + v75 + (HIDWORD(v16) & v22 | v21 & ~HIDWORD(v16)) + 1804603682;
  v23 = HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25));
  LODWORD(v16) = v21
               + v76
               + (v23 & HIDWORD(v16) | v22 & ~(HIDWORD(v16) + (((_DWORD)v16 << 7) | ((unsigned int)v16 >> 25))))
               - 40341101;
  v24 = v23 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20));
  LODWORD(v16) = ~(v23 + (((_DWORD)v16 << 12) | ((unsigned int)v16 >> 20)));
  v25 = v22 + v77 + (v23 & v24 | HIDWORD(v16) & v16) - 1502002290;
  v26 = v24 + ((v25 << 17) | (v25 >> 15));
  v27 = ~(v24 + ((v25 << 17) | (v25 >> 15)));
  v28 = v27;
  v29 = HIDWORD(v16) + v78 + (v26 & v24 | v23 & v27) + 1236535329;
  HIDWORD(v16) = v26 + ((v29 >> 10) | (v29 << 22));
  LODWORD(v16) = v23 + v64 + (HIDWORD(v16) & v24 | v26 & v16) - 165796510;
  v30 = HIDWORD(v16) + (32 * v16 | ((unsigned int)v16 >> 27));
  LODWORD(v16) = v24 + v69 + (v30 & v26 | HIDWORD(v16) & v28) - 1069501632;
  v31 = v30 + (((_DWORD)v16 << 9) | ((unsigned int)v16 >> 23));
  LODWORD(v16) = v26 + v74 + (HIDWORD(v16) & v31 | v30 & ~(v26 + ((v29 >> 10) | (v29 << 22)))) + 643717713;
  v32 = v31 + (((_DWORD)v16 << 14) | ((unsigned int)v16 >> 18));
  HIDWORD(v16) = HIDWORD(v16) + v63 + (v30 & v32 | v31 & ~v30) - 373897302;
  LODWORD(v16) = HIDWORD(v16);
  HIDWORD(v16) = v32 + (unsigned __int64)(v16 >> 12);
  LODWORD(v16) = v30 + v68 + (HIDWORD(v16) & v31 | v32 & ~v31) - 701558691;
  v33 = HIDWORD(v16) + (32 * v16 | ((unsigned int)v16 >> 27));
  LODWORD(v16) = v31 + v73 + (v33 & v32 | HIDWORD(v16) & ~v32) + 38016083;
  v34 = v33 + (((_DWORD)v16 << 9) | ((unsigned int)v16 >> 23));
  v35 = v34
      + (((v32 + v78 + (HIDWORD(v16) & v34 | v33 & ~HIDWORD(v16)) - 660478335) << 14) | ((v32
                                                                                        + v78
                                                                                        + (HIDWORD(v16) & v34 | v33 & ~HIDWORD(v16))
                                                                                        - 660478335) >> 18));
  HIDWORD(v16) = HIDWORD(v16) + v67 + (v33 & v35 | v34 & ~v33) - 405537848;
  LODWORD(v16) = HIDWORD(v16);
  HIDWORD(v16) = v35 + (unsigned __int64)(v16 >> 12);
  LODWORD(v16) = v33 + v72 + (HIDWORD(v16) & v34 | v35 & ~v34) + 568446438;
  v36 = HIDWORD(v16) + (32 * v16 | ((unsigned int)v16 >> 27));
  LODWORD(v16) = v34 + v77 + (v36 & v35 | HIDWORD(v16) & ~v35) - 1019803690;
  v37 = v36 + (((_DWORD)v16 << 9) | ((unsigned int)v16 >> 23));
  LODWORD(v16) = v35 + v66 + (HIDWORD(v16) & v37 | v36 & ~HIDWORD(v16)) - 187363961;
  v38 = v37 + (((_DWORD)v16 << 14) | ((unsigned int)v16 >> 18));
  HIDWORD(v16) += v71 + (v36 & v38 | v37 & ~v36) + 1163531501;
  LODWORD(v16) = HIDWORD(v16);
  HIDWORD(v16) = v38 + (unsigned __int64)(v16 >> 12);
  v39 = HIDWORD(v16)
      + (32 * (v36 + v76 + (HIDWORD(v16) & v37 | v38 & ~v37) - 1444681467) | ((v36
                                                                             + v76
                                                                             + (HIDWORD(v16) & v37 | v38 & ~v37)
                                                                             - 1444681467) >> 27));
  LODWORD(v16) = v37 + v65 + (v39 & v38 | HIDWORD(v16) & ~v38) - 51403784;
  v40 = v39 + (((_DWORD)v16 << 9) | ((unsigned int)v16 >> 23));
  LODWORD(v16) = v38
               + v70
               + (HIDWORD(v16) & (v39 + (((_DWORD)v16 << 9) | ((unsigned int)v16 >> 23))) | v39 & ~HIDWORD(v16))
               + 1735328473;
  v41 = v40 + (((_DWORD)v16 << 14) | ((unsigned int)v16 >> 18));
  HIDWORD(v16) = HIDWORD(v16) + v75 + (v39 & v41 | v40 & ~v39) - 1926607734;
  LODWORD(v16) = HIDWORD(v16);
  HIDWORD(v16) = v41 + (unsigned __int64)(v16 >> 12);
  LODWORD(v16) = v39 + v68 + (HIDWORD(v16) ^ v41 ^ v40) - 378558;
  v42 = HIDWORD(v16) + (16 * v16 | ((unsigned int)v16 >> 28));
  v43 = v40 + v71 + (v42 ^ HIDWORD(v16) ^ v41) - 2022574463;
  LODWORD(v16) = v42 + ((v43 << 11) | (v43 >> 21));
  v44 = v41 + v74 + (v42 ^ HIDWORD(v16) ^ (v42 + ((v43 << 11) | (v43 >> 21)))) + 1839030562;
  v45 = v16 + ((v44 << 16) | (v44 >> 16));
  HIDWORD(v16) = HIDWORD(v16) + v77 + (v42 ^ v45 ^ v16) - 35309556;
  v46 = v45 + ((HIDWORD(v16) >> 9) | (HIDWORD(v16) << 23));
  v47 = v42 + v64 + (v46 ^ v45 ^ v16) - 1530992060;
  v48 = v46 + (16 * v47 | (v47 >> 28));
  LODWORD(v16) = v16 + v67 + (v48 ^ v46 ^ v45) + 1272893353;
  HIDWORD(v16) = v48 + (((_DWORD)v16 << 11) | ((unsigned int)v16 >> 21));
  LODWORD(v16) = v45 + v70 + (v48 ^ v46 ^ (v48 + (((_DWORD)v16 << 11) | ((unsigned int)v16 >> 21)))) - 155497632;
  v49 = HIDWORD(v16) + (((_DWORD)v16 << 16) | ((unsigned int)v16 >> 16));
  v50 = v46 + v73 + (v48 ^ v49 ^ HIDWORD(v16)) - 1094730640;
  v51 = v49 + ((v50 >> 9) | (v50 << 23));
  LODWORD(v16) = v48 + v76 + (v51 ^ v49 ^ HIDWORD(v16)) + 681279174;
  v52 = v51 + (16 * v16 | ((unsigned int)v16 >> 28));
  LODWORD(v16) = HIDWORD(v16) + v63 + (v52 ^ v51 ^ v49) - 358537222;
  HIDWORD(v16) = v52 + (((_DWORD)v16 << 11) | ((unsigned int)v16 >> 21));
  v53 = v49 + v66 + (v52 ^ v51 ^ (v52 + (((_DWORD)v16 << 11) | ((unsigned int)v16 >> 21)))) - 722521979;
  LODWORD(v16) = HIDWORD(v16) + ((v53 << 16) | (v53 >> 16));
  v54 = v51 + v69 + (v52 ^ v16 ^ HIDWORD(v16)) + 76029189;
  v55 = v16 + ((v54 >> 9) | (v54 << 23));
  LODWORD(v56) = v52 + v72 + (v55 ^ v16 ^ HIDWORD(v16)) - 640364487;
  HIDWORD(v56) = v56;
  LODWORD(v56) = v55 + (unsigned __int64)(v56 >> 28);
  HIDWORD(v16) = HIDWORD(v16) + v75 + (v56 ^ v55 ^ v16) - 421815835;
  HIDWORD(v56) = v56 + ((HIDWORD(v16) << 11) | (HIDWORD(v16) >> 21));
  LODWORD(v16) = v16 + v78 + (v56 ^ v55 ^ (v56 + ((HIDWORD(v16) << 11) | (HIDWORD(v16) >> 21)))) + 530742520;
  HIDWORD(v16) = HIDWORD(v56) + (((_DWORD)v16 << 16) | ((unsigned int)v16 >> 16));
  LODWORD(v16) = v55 + v65 + (v56 ^ HIDWORD(v16) ^ HIDWORD(v56)) - 995338651;
  v57 = HIDWORD(v16) + (((unsigned int)v16 >> 9) | ((_DWORD)v16 << 23));
  LODWORD(v16) = v56 + v63 + (HIDWORD(v16) ^ (v57 | ~HIDWORD(v56))) - 198630844;
  LODWORD(v56) = v57 + (((_DWORD)v16 << 6) | ((unsigned int)v16 >> 26));
  LODWORD(v16) = HIDWORD(v56) + v70 + (v57 ^ (v56 | ~HIDWORD(v16))) + 1126891415;
  HIDWORD(v56) = v56 + (((_DWORD)v16 << 10) | ((unsigned int)v16 >> 22));
  LODWORD(v16) = HIDWORD(v16) + v77 + (v56 ^ (HIDWORD(v56) | ~v57)) - 1416354905;
  HIDWORD(v16) = HIDWORD(v56) + (((_DWORD)v16 << 15) | ((unsigned int)v16 >> 17));
  LODWORD(v16) = v57 + v68 + (HIDWORD(v56) ^ (HIDWORD(v16) | ~(_DWORD)v56)) - 57434055;
  v58 = HIDWORD(v16) + (((unsigned int)v16 >> 11) | ((_DWORD)v16 << 21));
  LODWORD(v16) = v56 + v75 + (HIDWORD(v16) ^ (v58 | ~HIDWORD(v56))) + 1700485571;
  LODWORD(v56) = v58 + (((_DWORD)v16 << 6) | ((unsigned int)v16 >> 26));
  LODWORD(v16) = HIDWORD(v56) + v66 + (v58 ^ (v56 | ~HIDWORD(v16))) - 1894986606;
  HIDWORD(v56) = v56 + (((_DWORD)v16 << 10) | ((unsigned int)v16 >> 22));
  LODWORD(v16) = HIDWORD(v16) + v73 + (v56 ^ (HIDWORD(v56) | ~v58)) - 1051523;
  HIDWORD(v16) = HIDWORD(v56) + (((_DWORD)v16 << 15) | ((unsigned int)v16 >> 17));
  LODWORD(v16) = v58 + v64 + (HIDWORD(v56) ^ (HIDWORD(v16) | ~(_DWORD)v56)) - 2054922799;
  v59 = HIDWORD(v16) + (((unsigned int)v16 >> 11) | ((_DWORD)v16 << 21));
  LODWORD(v16) = v56 + v71 + (HIDWORD(v16) ^ (v59 | ~HIDWORD(v56))) + 1873313359;
  LODWORD(v56) = v59 + (((_DWORD)v16 << 6) | ((unsigned int)v16 >> 26));
  LODWORD(v16) = HIDWORD(v56) + v78 + (v59 ^ (v56 | ~HIDWORD(v16))) - 30611744;
  HIDWORD(v56) = v56 + (((_DWORD)v16 << 10) | ((unsigned int)v16 >> 22));
  LODWORD(v16) = HIDWORD(v16) + v69 + (v56 ^ (HIDWORD(v56) | ~v59)) - 1560198380;
  HIDWORD(v16) = HIDWORD(v56) + (((_DWORD)v16 << 15) | ((unsigned int)v16 >> 17));
  LODWORD(v16) = v59 + v76 + (HIDWORD(v56) ^ (HIDWORD(v16) | ~(_DWORD)v56)) + 1309151649;
  v60 = HIDWORD(v16) + (((unsigned int)v16 >> 11) | ((_DWORD)v16 << 21));
  LODWORD(v16) = v56 + v67 + (HIDWORD(v16) ^ (v60 | ~HIDWORD(v56))) - 145523070;
  LODWORD(v56) = v60 + (((_DWORD)v16 << 6) | ((unsigned int)v16 >> 26));
  LODWORD(v16) = HIDWORD(v56) + v74 + (v60 ^ (v56 | ~HIDWORD(v16))) - 1120210379;
  HIDWORD(v56) = v56 + (((_DWORD)v16 << 10) | ((unsigned int)v16 >> 22));
  HIDWORD(v16) += v65 + (v56 ^ (HIDWORD(v56) | ~v60)) + 718787259;
  LODWORD(v16) = HIDWORD(v16);
  LODWORD(v16) = HIDWORD(v56) + (unsigned __int64)(v16 >> 17);
  v61 = v60 + v72 + (HIDWORD(v56) ^ (v16 | ~(_DWORD)v56)) - 343485551;
  *(_DWORD *)a2 += v56;
  *(_DWORD *)(a2 + 4) += v16 + ((v61 >> 11) | (v61 << 21));
  *(_DWORD *)(a2 + 8) += v16;
  result = HIDWORD(v56) + *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (1000CF00) --------------------------------------------------------
unsigned int __cdecl sub_1000CF00(int a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  unsigned int v6; // ebp@3
  int v7; // esi@4
  unsigned int i; // edi@4
  unsigned int v9; // ecx@8
  const void *v10; // esi@8
  void *v11; // edi@8
  unsigned int result; // eax@8

  v3 = a3;
  v4 = *(_DWORD *)(a1 + 16) + 8 * a3;
  v5 = (*(_DWORD *)(a1 + 16) >> 3) & 0x3F;
  *(_DWORD *)(a1 + 16) = v4;
  if ( v4 < 8 * a3 )
    ++*(_DWORD *)(a1 + 20);
  v6 = 64 - v5;
  *(_DWORD *)(a1 + 20) += a3 >> 29;
  if ( a3 < 64 - v5 )
  {
    i = 0;
  }
  else
  {
    memcpy((void *)(v5 + a1 + 24), a2, v6);
    sub_1000C620((void *)(a1 + 24), a1);
    v7 = v6 + 63;
    for ( i = v6; v7 < a3; i += 64 )
    {
      sub_1000C620((char *)a2 + v7 - 63, a1);
      v7 += 64;
    }
    v3 = a3;
    v5 = 0;
  }
  v9 = v3 - i;
  v10 = (char *)a2 + i;
  v11 = (void *)(v5 + a1 + 24);
  result = v9;
  memcpy(v11, v10, v9);
  return result;
}

//----- (1000CFC0) --------------------------------------------------------
int __cdecl sub_1000CFC0(int a1, int a2)
{
  unsigned int v2; // ecx@1
  int v3; // eax@1
  int v4; // ecx@3
  signed int v5; // eax@3
  int v6; // ecx@5
  int v7; // eax@5
  signed int v8; // esi@5
  int result; // eax@7
  char v10; // [sp+8h] [bp-8h]@2
  char v11; // [sp+9h] [bp-7h]@2
  char v12; // [sp+Ah] [bp-6h]@2
  char v13[5]; // [sp+Bh] [bp-5h]@2

  v2 = 0;
  v3 = a2 + 18;
  do
  {
    *(&v10 + v2) = *(_BYTE *)(v3 - 2);
    *(&v11 + v2) = *(_BYTE *)(v3 - 1);
    *(&v12 + v2) = *(_BYTE *)v3;
    v13[v2] = *(_BYTE *)(v3 + 1);
    v2 += 4;
    v3 += 4;
  }
  while ( v2 < 8 );
  v4 = (*(_DWORD *)(a2 + 16) >> 3) & 0x3F;
  v5 = 56;
  if ( (unsigned int)v4 >= 0x38 )
    v5 = 120;
  sub_1000CF00(a2, &unk_100115C0, v5 - v4);
  sub_1000CF00(a2, &v10, 8u);
  v6 = a1 + 1;
  v7 = a2 + 2;
  v8 = 4;
  do
  {
    *(_BYTE *)(v6 - 1) = *(_BYTE *)(v7 - 2);
    *(_BYTE *)v6 = *(_BYTE *)(v7 - 1);
    *(_BYTE *)(v6 + 1) = *(_BYTE *)v7;
    *(_BYTE *)(v6 + 2) = *(_BYTE *)(v7 + 1);
    v7 += 4;
    v6 += 4;
    --v8;
  }
  while ( v8 );
  result = 0;
  memset((void *)a2, 0, 0x58u);
  return result;
}
// 1000CFC0: using guessed type char var_5[5];

//----- (1000D070) --------------------------------------------------------
int __cdecl sub_1000D070(const void *a1, unsigned int a2, char *Dest)
{
  int v4; // [sp+0h] [bp-68h]@1
  int v5; // [sp+10h] [bp-58h]@1
  int v6; // [sp+14h] [bp-54h]@1
  int v7; // [sp+18h] [bp-50h]@1
  int v8; // [sp+1Ch] [bp-4Ch]@1
  int v9; // [sp+20h] [bp-48h]@1
  int v10; // [sp+24h] [bp-44h]@1

  v10 = 0;
  v9 = 0;
  v5 = 1732584193;
  v6 = -271733879;
  v7 = -1732584194;
  v8 = 271733878;
  sub_1000CF00((int)&v5, a1, a2);
  sub_1000CFC0((int)&v4, (int)&v5);
  return sub_1000C5E0((int)&v4, Dest);
}

//----- (1000D0E0) --------------------------------------------------------
char __usercall sub_1000D0E0<al>(int a1<ecx>, int a2<esi>, int a3, unsigned int a4, int a5, unsigned __int8 a6)
{
  unsigned int v6; // eax@2
  int v7; // edi@3
  unsigned int i; // ebp@3
  int v9; // edx@5

  if ( a4 )
  {
    v7 = 1;
    for ( i = 0; v7 < a4; v7 = 2 * v7 + 1 )
      ;
    do
    {
      *(_BYTE *)a2 = *(_BYTE *)(*(_DWORD *)a1 + a5) + *(_BYTE *)(*(_BYTE *)a2 + a3);
      v9 = *(_DWORD *)a1 + 1;
      *(_DWORD *)a1 = v9;
      if ( v9 >= (unsigned int)a6 )
      {
        *(_DWORD *)a1 = 0;
        *(_BYTE *)a2 += a6;
      }
      v6 = (unsigned __int8)(v7 & *(_BYTE *)a2);
      ++i;
      if ( i > 0xB )
        v6 %= a4;
    }
    while ( v6 > a4 );
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  return v6;
}

//----- (1000D160) --------------------------------------------------------
signed int __cdecl sub_1000D160(int a1)
{
  signed int result; // eax@1
  signed int v2; // edx@1

  *(_BYTE *)(a1 + 256) = 1;
  *(_BYTE *)(a1 + 257) = 3;
  *(_BYTE *)(a1 + 258) = 5;
  *(_BYTE *)(a1 + 259) = 7;
  *(_BYTE *)(a1 + 260) = 11;
  result = 0;
  v2 = 255;
  do
    *(_BYTE *)(result++ + a1) = v2--;
  while ( result < 256 );
  return result;
}

//----- (1000D1A0) --------------------------------------------------------
char __cdecl sub_1000D1A0(int a1, int a2, unsigned __int8 a3)
{
  char result; // al@2
  signed int v4; // eax@3
  unsigned int v5; // ebp@5
  char v6; // al@6
  char v7; // cl@6
  int v8; // eax@6
  char v9; // al@7
  char v10; // dl@7
  int v11; // ecx@7
  unsigned __int8 v12; // [sp+3h] [bp-5h]@5
  int v13; // [sp+4h] [bp-4h]@5

  if ( a3 >= 1u )
  {
    v4 = 0;
    do
    {
      *(_BYTE *)(v4 + a1) = v4;
      ++v4;
    }
    while ( v4 < 256 );
    v13 = 0;
    v12 = 0;
    v5 = 255;
    do
    {
      v6 = sub_1000D0E0((int)&v13, (int)&v12, a1, v5, a2, a3);
      v7 = *(_BYTE *)(a1 + v5);
      v8 = (unsigned __int8)v6 + a1;
      *(_BYTE *)(a1 + v5--) = *(_BYTE *)v8;
      *(_BYTE *)v8 = v7;
    }
    while ( (v5 & 0x80000000u) == 0 );
    v9 = *(_BYTE *)(a1 + 1);
    v10 = *(_BYTE *)(a1 + 5);
    *(_BYTE *)(a1 + 257) = *(_BYTE *)(a1 + 3);
    v11 = v12;
    *(_BYTE *)(a1 + 256) = v9;
    result = *(_BYTE *)(a1 + 7);
    *(_BYTE *)(a1 + 258) = v10;
    *(_BYTE *)(a1 + 259) = result;
    *(_BYTE *)(a1 + 260) = *(_BYTE *)(v11 + a1);
  }
  else
  {
    result = sub_1000D160(a1);
  }
  return result;
}

//----- (1000D260) --------------------------------------------------------
char __cdecl sub_1000D260(int a1, char a2)
{
  int v2; // eax@1
  char v3; // cl@1
  unsigned __int8 v4; // bl@1
  int v5; // ecx@1
  unsigned __int8 v6; // dl@1
  int v7; // esi@1
  int v8; // edx@1
  unsigned __int8 v9; // bl@1

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 256);
  v4 = *(_BYTE *)(*(_BYTE *)(a1 + 256) + a1) + *(_BYTE *)(a1 + 257);
  *(_BYTE *)(a1 + 257) = v4;
  *(_BYTE *)(a1 + 256) = v3 + 1;
  v5 = *(_BYTE *)(a1 + 260);
  v6 = *(_BYTE *)(v5 + a1);
  *(_BYTE *)(v2 + v5) = *(_BYTE *)(v4 + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 257) + v2) = *(_BYTE *)(*(_BYTE *)(v2 + 259) + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 259) + v2) = *(_BYTE *)(*(_BYTE *)(v2 + 256) + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 256) + v2) = v6;
  v7 = *(_BYTE *)(a1 + 257);
  LOBYTE(v5) = *(_BYTE *)(v6 + a1);
  v8 = *(_BYTE *)(a1 + 259);
  v9 = v5 + *(_BYTE *)(a1 + 258);
  *(_BYTE *)(a1 + 258) = v9;
  LOBYTE(v8) = a2 ^ *(_BYTE *)((unsigned __int8)(*(_BYTE *)(*(_BYTE *)(a1 + 256) + a1) + *(_BYTE *)(v9 + a1)) + a1) ^ *(_BYTE *)(*(_BYTE *)((unsigned __int8)(*(_BYTE *)(*(_BYTE *)(v2 + 260) + v2) + *(_BYTE *)(v7 + a1) + *(_BYTE *)(v8 + v2)) + a1) + a1);
  *(_BYTE *)(a1 + 260) = v8;
  *(_BYTE *)(a1 + 259) = a2;
  return v8;
}

//----- (1000D390) --------------------------------------------------------
char __cdecl sub_1000D390(int a1, char a2)
{
  int v2; // eax@1
  char v3; // cl@1
  unsigned __int8 v4; // bl@1
  int v5; // ecx@1
  unsigned __int8 v6; // dl@1
  int v7; // esi@1
  int v8; // edx@1
  unsigned __int8 v9; // bl@1

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 256);
  v4 = *(_BYTE *)(*(_BYTE *)(a1 + 256) + a1) + *(_BYTE *)(a1 + 257);
  *(_BYTE *)(a1 + 257) = v4;
  *(_BYTE *)(a1 + 256) = v3 + 1;
  v5 = *(_BYTE *)(a1 + 260);
  v6 = *(_BYTE *)(v5 + a1);
  *(_BYTE *)(v2 + v5) = *(_BYTE *)(v4 + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 257) + v2) = *(_BYTE *)(*(_BYTE *)(v2 + 259) + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 259) + v2) = *(_BYTE *)(*(_BYTE *)(v2 + 256) + v2);
  *(_BYTE *)(*(_BYTE *)(v2 + 256) + v2) = v6;
  v7 = *(_BYTE *)(a1 + 257);
  LOBYTE(v5) = *(_BYTE *)(v6 + a1);
  v8 = *(_BYTE *)(a1 + 259);
  v9 = v5 + *(_BYTE *)(a1 + 258);
  *(_BYTE *)(a1 + 258) = v9;
  LOBYTE(v8) = a2 ^ *(_BYTE *)((unsigned __int8)(*(_BYTE *)(*(_BYTE *)(a1 + 256) + a1) + *(_BYTE *)(v9 + a1)) + a1) ^ *(_BYTE *)(*(_BYTE *)((unsigned __int8)(*(_BYTE *)(*(_BYTE *)(v2 + 260) + v2) + *(_BYTE *)(v7 + a1) + *(_BYTE *)(v8 + v2)) + a1) + a1);
  *(_BYTE *)(a1 + 259) = v8;
  *(_BYTE *)(a1 + 260) = a2;
  return v8;
}

//----- (1000D480) --------------------------------------------------------
void __cdecl sub_1000D480(int a1, int a2, int a3)
{
  int i; // esi@1

  for ( i = 0; i < a3; ++i )
    *(_BYTE *)(i + a2) = sub_1000D390(a1, *(_BYTE *)(i + a2));
}

//----- (1000DA6A) --------------------------------------------------------
void __cdecl sub_1000DA6A()
{
  unsigned int i; // [sp+Ch] [bp-1Ch]@1

  for ( i = (unsigned int)&unk_1000EDC0; i < (unsigned int)&unk_1000EDC0; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1000DAAE) --------------------------------------------------------
void __cdecl sub_1000DAAE()
{
  unsigned int i; // [sp+Ch] [bp-1Ch]@1

  for ( i = (unsigned int)&unk_1000EDC8; i < (unsigned int)&unk_1000EDC8; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1000DAF8) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 && !dword_1001208C )
    DisableThreadLibraryCalls(hinstDLL);
  return 1;
}
// 1001208C: using guessed type int dword_1001208C;

//----- (1000DC40) --------------------------------------------------------
int __usercall sub_1000DC40<eax>(int a1<ebp>)
{
  return FString::_FString(*(_DWORD *)(a1 - 20) + 24);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DC4C) --------------------------------------------------------
int __cdecl GameSpyMgr::GameSpyMgr()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DC60) --------------------------------------------------------
int __usercall sub_1000DC60<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DC69) --------------------------------------------------------
int __usercall sub_1000DC69<eax>(int a1<ebp>)
{
  return FStringTemp::_FStringTemp(a1 - 44);
}
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);

//----- (1000DC72) --------------------------------------------------------
int __usercall sub_1000DC72<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    result = FString::_FString(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DC8C) --------------------------------------------------------
int __cdecl GameSpyMgr::GetExtPlayerQueryResult()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DCA0) --------------------------------------------------------
int __cdecl GameSpyMgr::CDAuthCallback()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DCB0) --------------------------------------------------------
int __usercall sub_1000DCB0<eax>(int a1<ebp>)
{
  return FString::_FString(a1 + 24);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DCB9) --------------------------------------------------------
int __usercall sub_1000DCB9<eax>(int a1<ebp>)
{
  return FString::_FString(a1 + 16);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DCC2) --------------------------------------------------------
int __cdecl GameSpyMgr::AuthCDKey()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DCD0) --------------------------------------------------------
int __cdecl GameSpyMgr::ReleaseCDKey()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DCE0) --------------------------------------------------------
int __cdecl GameSpyMgr::ReleaseAllCDKey()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DCF0) --------------------------------------------------------
int __cdecl GameSpyMgr::adderror_callback()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DD00) --------------------------------------------------------
int __usercall sub_1000DD00<eax>(int a1<ebp>)
{
  return CDKeyResponseInterface::_CDKeyResponseInterface(*(_DWORD *)(a1 - 144));
}
// 1000E074: using guessed type int __thiscall CDKeyResponseInterface___CDKeyResponseInterface(_DWORD);

//----- (1000DD0C) --------------------------------------------------------
int __cdecl GameSpyCDKeyResponseInterface::GameSpyCDKeyResponseInterface()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DD20) --------------------------------------------------------
int __usercall sub_1000DD20<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 40);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD29) --------------------------------------------------------
int __usercall sub_1000DD29<eax>(int a1<ebp>)
{
  return FStringTemp::_FStringTemp(a1 - 48);
}
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);

//----- (1000DD32) --------------------------------------------------------
int __usercall sub_1000DD32<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    result = FString::_FString(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD4C) --------------------------------------------------------
int __cdecl GameSpyMgr::GetServerQueryResult()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DD60) --------------------------------------------------------
int __usercall sub_1000DD60<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 52);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD69) --------------------------------------------------------
int __usercall sub_1000DD69<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 44);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD72) --------------------------------------------------------
int __usercall sub_1000DD72<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD7B) --------------------------------------------------------
int __usercall sub_1000DD7B<eax>(int a1<ebp>)
{
  return FStringTemp::_FStringTemp(a1 - 60);
}
// 1000E028: using guessed type int __thiscall FStringTemp___FStringTemp(_DWORD);

//----- (1000DD84) --------------------------------------------------------
int __usercall sub_1000DD84<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    result = FString::_FString(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DD9E) --------------------------------------------------------
int __cdecl GameSpyMgr::GetExtServerQueryResult()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DDB0) --------------------------------------------------------
int __cdecl GameSpyMgr::BeginServerQuery()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DDC0) --------------------------------------------------------
int __cdecl GameSpyMgr::UnRegisterGame()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DDD0) --------------------------------------------------------
int __usercall sub_1000DDD0<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DDD9) --------------------------------------------------------
int __usercall sub_1000DDD9<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DDE2) --------------------------------------------------------
int __usercall sub_1000DDE2<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DDEB) --------------------------------------------------------
int __usercall sub_1000DDEB<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DDF4) --------------------------------------------------------
int __usercall sub_1000DDF4<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DDFD) --------------------------------------------------------
int __usercall sub_1000DDFD<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE06) --------------------------------------------------------
int __usercall sub_1000DE06<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE0F) --------------------------------------------------------
int __usercall sub_1000DE0F<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE18) --------------------------------------------------------
int __usercall sub_1000DE18<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE21) --------------------------------------------------------
int __usercall sub_1000DE21<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE2A) --------------------------------------------------------
int __usercall sub_1000DE2A<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE33) --------------------------------------------------------
int __usercall sub_1000DE33<eax>(int a1<ebp>)
{
  return FString::_FString(a1 - 36);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE3C) --------------------------------------------------------
int __cdecl GameSpyMgr::Exec()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DE50) --------------------------------------------------------
int __cdecl GameSpyMgr::serverkey_callback()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DE60) --------------------------------------------------------
int __cdecl GameSpyMgr::playerkey_callback()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DE70) --------------------------------------------------------
int __cdecl GameSpyMgr::count_callback()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DE80) --------------------------------------------------------
int __cdecl GameSpyMgr::RegisterGame()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

//----- (1000DE90) --------------------------------------------------------
int __usercall sub_1000DE90<eax>(int a1<ebp>)
{
  return FString::_FString(*(_DWORD *)(a1 - 24) + 24);
}
// 1000E018: using guessed type int __thiscall FString___FString(_DWORD);

//----- (1000DE9C) --------------------------------------------------------
int __cdecl GameSpyMgr::_GameSpyMgr()
{
  return _CxxFrameHandler();
}
// 1000D598: using guessed type int _CxxFrameHandler(void);

// ALL OK, 328 function(s) have been successfully decompiled
